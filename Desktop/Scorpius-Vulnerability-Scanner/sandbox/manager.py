"""Sandbox Manager for Scorpius Vulnerability Scanner

This module provides a centralized manager for different sandboxing technologies used
by the Scorpius Vulnerability Scanner. It abstracts the underlying sandboxing 
implementation and provides a consistent interface for secure code execution.
"""

import os
import logging
import asyncio
import json
import tempfile
from typing import Dict, Any, Optional, List, Tuple, Union
from enum import Enum

from sandbox.docker import DockerSandbox

logger = logging.getLogger("scorpius.sandbox.manager")


class SandboxType(Enum):
    """Types of sandboxes supported by the manager"""
    DOCKER = "docker"
    ISOLATED_VM = "isolated_vm"
    LOCAL = "local"  # Limited sandboxing, just for quick testing


class SandboxManager:
    """Manager for sandbox environments
    
    This class provides a unified interface to create, manage, and
    destroy sandbox environments for secure execution of vulnerability
    scanners and exploit simulations.
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        """Initialize the sandbox manager
        
        Args:
            config: Configuration options for the sandbox manager
        """
        self.config = config or {}
        self.active_sandboxes = {}
        self.default_sandbox_type = SandboxType(
            self.config.get("default_sandbox_type", SandboxType.DOCKER.value)
        )
        
        # Initialize sandbox implementations
        self.sandbox_impls = {
            SandboxType.DOCKER: DockerSandbox(self.config.get("docker", {}))
        }
        
        logger.info(f"Sandbox manager initialized with default type: {self.default_sandbox_type.value}")
        
    async def check_availability(self) -> Dict[SandboxType, bool]:
        """Check if all sandbox implementations are available
        
        Returns:
            Dict mapping sandbox types to their availability status
        """
        results = {}
        
        # Check Docker availability
        if SandboxType.DOCKER in self.sandbox_impls:
            docker_sandbox = self.sandbox_impls[SandboxType.DOCKER]
            results[SandboxType.DOCKER] = await docker_sandbox.check_docker_available()
            
        # Check other sandbox types as they're implemented
        
        logger.info(f"Sandbox availability: {results}")
        return results
    
    async def create_sandbox(self, sandbox_type: Optional[SandboxType] = None, 
                           options: Dict[str, Any] = None) -> str:
        """Create a new sandbox environment
        
        Args:
            sandbox_type: Type of sandbox to create
            options: Sandbox-specific options
            
        Returns:
            str: Sandbox ID that can be used to reference this sandbox
        """
        if sandbox_type is None:
            sandbox_type = self.default_sandbox_type
            
        options = options or {}
        
        if sandbox_type not in self.sandbox_impls:
            logger.error(f"Unsupported sandbox type: {sandbox_type}")
            raise ValueError(f"Unsupported sandbox type: {sandbox_type}")
            
        logger.info(f"Creating {sandbox_type.value} sandbox")
        
        if sandbox_type == SandboxType.DOCKER:
            docker_sandbox = self.sandbox_impls[SandboxType.DOCKER]
            
            # Get Docker-specific options
            image = options.get("image", "ethereum/solc:stable")
            command = options.get("command", ["tail", "-f", "/dev/null"])  # Keep container running
            volumes = options.get("volumes", {})
            env = options.get("env", {})
            
            # Run the container
            success, container_id, _, _ = await docker_sandbox.run_container(
                image=image,
                command=command,
                volumes=volumes,
                env=env,
                timeout=options.get("timeout", 3600),  # 1 hour default
                capture_output=False  # Run in detached mode
            )
            
            if not success or not container_id:
                logger.error("Failed to create Docker sandbox")
                raise RuntimeError("Failed to create Docker sandbox")
                
            # Store sandbox info
            sandbox_id = f"docker-{container_id}"
            self.active_sandboxes[sandbox_id] = {
                "type": sandbox_type,
                "id": container_id,
                "image": image,
                "volumes": volumes,
                "env": env
            }
            
            logger.info(f"Created sandbox {sandbox_id}")
            return sandbox_id
        
        # Support for other sandbox types would go here
        
        raise ValueError(f"Unsupported sandbox type: {sandbox_type}")
    
    async def execute_in_sandbox(self, sandbox_id: str, command: List[str], 
                               working_dir: Optional[str] = None,
                               timeout: Optional[int] = None) -> Tuple[bool, str, str]:
        """Execute a command within a sandbox
        
        Args:
            sandbox_id: ID of the sandbox to use
            command: Command to execute
            working_dir: Working directory within the sandbox
            timeout: Command timeout in seconds
            
        Returns:
            Tuple containing (success, stdout, stderr)
        """
        if sandbox_id not in self.active_sandboxes:
            logger.error(f"Sandbox {sandbox_id} not found")
            return False, "", f"Sandbox {sandbox_id} not found"
            
        sandbox_info = self.active_sandboxes[sandbox_id]
        sandbox_type = sandbox_info["type"]
        
        logger.info(f"Executing command in sandbox {sandbox_id}: {' '.join(command)}")
        
        if sandbox_type == SandboxType.DOCKER:
            docker_sandbox = self.sandbox_impls[SandboxType.DOCKER]
            container_id = sandbox_info["id"]
            
            # Prepend working directory if specified
            if working_dir:
                cmd = ["cd", working_dir, "&&"] + command
            else:
                cmd = command
                
            # Execute the command
            success, stdout, stderr = await docker_sandbox.execute_in_container(
                container_id=container_id,
                command=cmd
            )
            
            return success, stdout or "", stderr or ""
        
        # Support for other sandbox types would go here
        
        return False, "", f"Unsupported sandbox type: {sandbox_type}"
    
    async def copy_to_sandbox(self, sandbox_id: str, local_path: str, 
                            sandbox_path: str) -> bool:
        """Copy a file from the local system to the sandbox
        
        Args:
            sandbox_id: ID of the sandbox
            local_path: Path on the local system
            sandbox_path: Path within the sandbox
            
        Returns:
            bool: True if successful, False otherwise
        """
        if sandbox_id not in self.active_sandboxes:
            logger.error(f"Sandbox {sandbox_id} not found")
            return False
            
        sandbox_info = self.active_sandboxes[sandbox_id]
        sandbox_type = sandbox_info["type"]
        
        if sandbox_type == SandboxType.DOCKER:
            docker_sandbox = self.sandbox_impls[SandboxType.DOCKER]
            container_id = sandbox_info["id"]
            
            return await docker_sandbox.copy_file_to_container(
                container_id=container_id,
                local_path=local_path,
                container_path=sandbox_path
            )
        
        # Support for other sandbox types would go here
        
        return False
    
    async def copy_from_sandbox(self, sandbox_id: str, sandbox_path: str,
                              local_path: str) -> bool:
        """Copy a file from the sandbox to the local system
        
        Args:
            sandbox_id: ID of the sandbox
            sandbox_path: Path within the sandbox
            local_path: Path on the local system
            
        Returns:
            bool: True if successful, False otherwise
        """
        if sandbox_id not in self.active_sandboxes:
            logger.error(f"Sandbox {sandbox_id} not found")
            return False
            
        sandbox_info = self.active_sandboxes[sandbox_id]
        sandbox_type = sandbox_info["type"]
        
        if sandbox_type == SandboxType.DOCKER:
            docker_sandbox = self.sandbox_impls[SandboxType.DOCKER]
            container_id = sandbox_info["id"]
            
            return await docker_sandbox.copy_file_from_container(
                container_id=container_id,
                container_path=sandbox_path,
                local_path=local_path
            )
        
        # Support for other sandbox types would go here
        
        return False
    
    async def destroy_sandbox(self, sandbox_id: str) -> bool:
        """Destroy a sandbox environment
        
        Args:
            sandbox_id: ID of the sandbox to destroy
            
        Returns:
            bool: True if successful, False otherwise
        """
        if sandbox_id not in self.active_sandboxes:
            logger.error(f"Sandbox {sandbox_id} not found")
            return False
            
        sandbox_info = self.active_sandboxes[sandbox_id]
        sandbox_type = sandbox_info["type"]
        
        logger.info(f"Destroying sandbox {sandbox_id}")
        
        if sandbox_type == SandboxType.DOCKER:
            docker_sandbox = self.sandbox_impls[SandboxType.DOCKER]
            container_id = sandbox_info["id"]
            
            success = await docker_sandbox.stop_container(container_id)
            
            if success:
                del self.active_sandboxes[sandbox_id]
                logger.info(f"Sandbox {sandbox_id} destroyed")
                
            return success
        
        # Support for other sandbox types would go here
        
        return False
    
    async def cleanup(self) -> None:
        """Clean up all sandbox resources"""
        logger.info("Cleaning up all sandbox resources")
        
        # Clean up Docker sandboxes
        if SandboxType.DOCKER in self.sandbox_impls:
            docker_sandbox = self.sandbox_impls[SandboxType.DOCKER]
            await docker_sandbox.cleanup()
            
        # Clean up other sandbox types as they're implemented
        
        # Clear active sandboxes
        self.active_sandboxes.clear()
        logger.info("All sandbox resources cleaned up")


async def execute_in_sandbox(command: List[str], sandbox_type: SandboxType = SandboxType.DOCKER,
                          image: str = "ethereum/solc:stable", cleanup: bool = True,
                          volumes: Dict[str, str] = None, env: Dict[str, str] = None) -> Tuple[bool, str, str]:
    """Helper function to execute a command in a temporary sandbox
    
    This function creates a sandbox, executes a command, and optionally cleans up the sandbox.
    
    Args:
        command: Command to execute
        sandbox_type: Type of sandbox to use
        image: Docker image to use (for Docker sandboxes)
        cleanup: Whether to destroy the sandbox after execution
        volumes: Volume mappings (for Docker sandboxes)
        env: Environment variables
        
    Returns:
        Tuple containing (success, stdout, stderr)
    """
    manager = SandboxManager()
    
    options = {
        "image": image,
        "volumes": volumes or {},
        "env": env or {}
    }
    
    try:
        # Create the sandbox
        sandbox_id = await manager.create_sandbox(sandbox_type, options)
        
        # Execute the command
        success, stdout, stderr = await manager.execute_in_sandbox(
            sandbox_id=sandbox_id,
            command=command
        )
        
        return success, stdout, stderr
    finally:
        # Clean up if requested
        if cleanup:
            await manager.cleanup()
