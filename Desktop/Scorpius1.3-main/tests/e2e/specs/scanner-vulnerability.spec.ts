import { test, expect } from '@playwright/test';
import * as fs from 'fs';
import * as path from 'path';

interface VulnerabilityFinding {
  id: string;
  title: string;
  description: string;
  severity: 'HIGH' | 'MEDIUM' | 'LOW' | 'CRITICAL' | 'INFO';
  confidence: number;
  vulnerability_type: string;
  location: string;
  cwe_id?: string;
  cvss_score?: number;
  recommendation?: string;
  references: string[];
  tags: string[];
  exploit_scenario?: string;
  proof?: Record<string, any>;
}

interface TokenScanResponse {
  success: boolean;
  request_id: string;
  contract_address: string;
  chain_id: number;
  token_name?: string;
  token_symbol?: string;
  is_verified: boolean;
  risk_score: number;
  risk_factors: string[];
  liquidity_analysis: Record<string, any>;
  ownership_analysis: Record<string, any>;
  findings: VulnerabilityFinding[];
  total_findings: number;
  critical_findings: number;
  high_findings: number;
  medium_findings: number;
  low_findings: number;
  scan_timestamp: number;
  processing_time_ms: number;
}

test.describe('Scanner Vulnerability Testing', () => {
  // Test contract address - known vulnerable ERC-20 with "beef" and "dead" patterns
  const VULNERABLE_CONTRACT = '0xBEEF0123456789abcdef0123456789abcdef0dead';
  const ARTIFACTS_DIR = path.join(__dirname, '..', '..', '..', 'artifacts', 'tests');

  test.beforeEach(async ({ page }) => {
    // Navigate to the scanner page
    await page.goto('/scanner');
    
    // Wait for the page to load completely
    await page.waitForLoadState('networkidle');
    
    // Ensure the scanner interface is visible
    await expect(page.locator('h1')).toContainText(/scanner|vulnerability/i);
  });

  test('should detect vulnerabilities in known vulnerable contract', async ({ page }) => {
    console.log('🔍 Starting vulnerability scanner test...');
    
    // Step 1: Find the contract address input field
    const contractInput = page.locator('input[type="text"]').filter({ 
      hasText: '' 
    }).or(
      page.locator('input[placeholder*="contract"]')
    ).or(
      page.locator('input[placeholder*="address"]')
    ).or(
      page.locator('input[name*="contract"]')
    ).or(
      page.locator('input[id*="contract"]')
    ).first();

    // Ensure the input field is visible and enabled
    await expect(contractInput).toBeVisible();
    await expect(contractInput).toBeEnabled();

    // Step 2: Paste the vulnerable contract address
    console.log(`📝 Entering contract address: ${VULNERABLE_CONTRACT}`);
    await contractInput.clear();
    await contractInput.fill(VULNERABLE_CONTRACT);
    
    // Verify the address was entered correctly
    await expect(contractInput).toHaveValue(VULNERABLE_CONTRACT);

    // Step 3: Find and click the "Run Scan" button
    const scanButton = page.locator('button').filter({ 
      hasText: /run scan|start scan|scan now|analyze/i 
    }).first();

    await expect(scanButton).toBeVisible();
    await expect(scanButton).toBeEnabled();

    // Set up API response listener before clicking scan
    let apiResponse: TokenScanResponse | null = null;
    
    page.on('response', async (response) => {
      const url = response.url();
      
      // Listen for the token scan API call
      if (url.includes('/api/v2/scan/token') || url.includes('/api/scan/token')) {
        console.log(`🌐 API Response received from: ${url}`);
        console.log(`📊 Status: ${response.status()}`);
        
        if (response.status() === 200) {
          try {
            const responseData = await response.json();
            apiResponse = responseData as TokenScanResponse;
            console.log('✅ API response parsed successfully');
            console.log(`📈 Risk Score: ${apiResponse.risk_score}`);
            console.log(`🔍 Total Findings: ${apiResponse.total_findings}`);
          } catch (error) {
            console.error('❌ Failed to parse API response:', error);
          }
        }
      }
    });

    // Step 4: Click the scan button
    console.log('🚀 Starting vulnerability scan...');
    await scanButton.click();

    // Step 5: Wait for the scan to complete
    // Look for loading indicators and wait for them to disappear
    const loadingIndicators = [
      page.locator('[data-testid*="loading"]'),
      page.locator('.loading'),
      page.locator('[class*="spinner"]'),
      page.locator('[class*="loading"]'),
      page.locator('text=/scanning|analyzing|processing/i')
    ];

    // Wait for loading to start (if any loading indicator appears)
    try {
      await Promise.race([
        ...loadingIndicators.map(indicator => indicator.waitFor({ state: 'visible', timeout: 2000 })),
        page.waitForTimeout(1000) // Fallback timeout
      ]);
      console.log('⏳ Scan started, waiting for completion...');
    } catch {
      console.log('⚡ No loading indicator detected, scan may be fast');
    }

    // Wait for loading to complete (all loading indicators should disappear)
    for (const indicator of loadingIndicators) {
      try {
        await indicator.waitFor({ state: 'hidden', timeout: 30000 });
      } catch {
        // Continue if indicator doesn't exist or doesn't hide
      }
    }

    // Additional wait for API response to be processed
    await page.waitForTimeout(3000);

    // Step 6: Wait for results to appear
    const resultsContainer = page.locator('[data-testid*="results"]').or(
      page.locator('.results')
    ).or(
      page.locator('[class*="result"]')
    ).or(
      page.locator('text=/vulnerability|finding|risk/i').first()
    );

    try {
      await resultsContainer.waitFor({ state: 'visible', timeout: 10000 });
      console.log('📋 Results container found');
    } catch {
      console.log('⚠️ Results container not found with specific selectors, checking page content');
    }

    // Step 7: Verify API response was received and contains expected data
    expect(apiResponse).not.toBeNull();
    expect(apiResponse!.success).toBe(true);
    expect(apiResponse!.contract_address.toLowerCase()).toBe(VULNERABLE_CONTRACT.toLowerCase());

    // Step 8: Assert vulnerability findings requirements
    console.log('🔍 Validating vulnerability findings...');
    
    // Check that we have at least 3 findings
    expect(apiResponse!.total_findings).toBeGreaterThanOrEqual(3);
    expect(apiResponse!.findings).toHaveLength(apiResponse!.total_findings);

    // Check that we have findings with the required severities
    const severities = apiResponse!.findings.map(f => f.severity);
    const uniqueSeverities = [...new Set(severities)];
    
    console.log(`📊 Found severities: ${uniqueSeverities.join(', ')}`);
    expect(uniqueSeverities).toContain('HIGH');
    expect(uniqueSeverities).toContain('MEDIUM'); 
    expect(uniqueSeverities).toContain('LOW');

    // Check that the first finding contains "reentrancy" in its title
    const firstFinding = apiResponse!.findings[0];
    expect(firstFinding.title.toLowerCase()).toContain('reentrancy');
    console.log(`✅ First finding confirmed as reentrancy: "${firstFinding.title}"`);

    // Validate finding structure
    for (const finding of apiResponse!.findings) {
      expect(finding.id).toBeTruthy();
      expect(finding.title).toBeTruthy();
      expect(finding.description).toBeTruthy();
      expect(['HIGH', 'MEDIUM', 'LOW', 'CRITICAL', 'INFO']).toContain(finding.severity);
      expect(finding.confidence).toBeGreaterThan(0);
      expect(finding.confidence).toBeLessThanOrEqual(1);
      expect(finding.vulnerability_type).toBeTruthy();
      expect(finding.location).toBeTruthy();
    }

    // Step 9: Save the full JSON response to artifacts
    const jsonFilePath = path.join(ARTIFACTS_DIR, 'scanner_vuln_report.json');
    fs.writeFileSync(jsonFilePath, JSON.stringify(apiResponse, null, 2));
    console.log(`💾 Saved vulnerability report to: ${jsonFilePath}`);

    // Step 10: Take a screenshot of the results panel
    const screenshotPath = path.join(ARTIFACTS_DIR, 'scanner_ui.png');
    
    // Try to find and focus on the results area
    try {
      const resultsArea = page.locator('[data-testid*="results"]').or(
        page.locator('.results')
      ).or(
        page.locator('[class*="result"]')
      ).first();
      
      if (await resultsArea.isVisible()) {
        await resultsArea.scrollIntoViewIfNeeded();
      }
    } catch {
      // If no specific results area found, screenshot the full page
    }

    await page.screenshot({ 
      path: screenshotPath, 
      fullPage: true,
      animations: 'disabled'
    });
    console.log(`📸 Saved screenshot to: ${screenshotPath}`);

    // Step 11: Additional validations on the UI
    // Check if vulnerability information is displayed on the page
    const pageContent = await page.textContent('body');
    
    // Look for vulnerability-related keywords in the page
    const vulnerabilityKeywords = ['vulnerability', 'finding', 'risk', 'security', 'reentrancy'];
    const foundKeywords = vulnerabilityKeywords.filter(keyword => 
      pageContent!.toLowerCase().includes(keyword)
    );
    
    expect(foundKeywords.length).toBeGreaterThan(0);
    console.log(`🏷️ Found vulnerability keywords on page: ${foundKeywords.join(', ')}`);

    // Final validation
    console.log('✅ All vulnerability scanner tests passed!');
    console.log(`📊 Summary:`);
    console.log(`   - Total findings: ${apiResponse!.total_findings}`);
    console.log(`   - High severity: ${apiResponse!.high_findings}`);
    console.log(`   - Medium severity: ${apiResponse!.medium_findings}`);
    console.log(`   - Low severity: ${apiResponse!.low_findings}`);
    console.log(`   - Risk score: ${apiResponse!.risk_score}/100`);
    console.log(`   - First finding: ${firstFinding.title}`);
  });

  test('should handle API errors gracefully', async ({ page }) => {
    console.log('🧪 Testing error handling...');

    // Test with an invalid contract address
    const invalidContract = '0xinvalid';
    
    const contractInput = page.locator('input[type="text"]').first();
    await contractInput.fill(invalidContract);
    
    const scanButton = page.locator('button').filter({ 
      hasText: /run scan|start scan|scan now|analyze/i 
    }).first();
    
    let errorResponse = false;
    page.on('response', async (response) => {
      if (response.url().includes('/api/v2/scan/token') || response.url().includes('/api/scan/token')) {
        if (response.status() >= 400) {
          errorResponse = true;
          console.log(`⚠️ Expected error response: ${response.status()}`);
        }
      }
    });
    
    await scanButton.click();
    await page.waitForTimeout(3000);
    
    // Should either show an error message or handle invalid input gracefully
    const pageContent = await page.textContent('body');
    const hasErrorIndicator = pageContent!.toLowerCase().includes('error') || 
                             pageContent!.toLowerCase().includes('invalid') ||
                             errorResponse;
    
    console.log(hasErrorIndicator ? '✅ Error handling works correctly' : '⚠️ No explicit error handling detected');
  });
});
