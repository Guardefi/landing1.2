const { ethers } = require("hardhat");

/**
 * @title Smart Vulnerability Scanner
 * @notice Distinguishes between legitimate DeFi functions and actual backdoors
 * @dev Focuses on unverified contracts and suspicious patterns
 */

// Known legitimate protocols to exclude
const LEGITIMATE_PROTOCOLS = [
  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
  "0xBA12222222228d8Ba445958a75a0704d566BF2C8", // Balancer
  "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B", // Compound
  "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84", // Lido
];

// Suspicious function patterns
const BACKDOOR_PATTERNS = [
  { sig: "0x78e111f6", name: "execute(address,bytes)", risk: "HIGH" },
  { sig: "0x9e8c708e", name: "adminCall(address,bytes)", risk: "HIGH" },
  { sig: "0xae169a50", name: "recover(address,uint256)", risk: "MEDIUM" },
  { sig: "0x69fe0e2d", name: "emergencyWithdraw()", risk: "MEDIUM" },
  { sig: "0x13af4035", name: "setOwner(address)", risk: "HIGH" },
  { sig: "0x3659cfe6", name: "upgradeTo(address)", risk: "HIGH" },
  { sig: "0xb2c87c61", name: "sweepETH()", risk: "MEDIUM" }
];

// Additional unverified high-value contracts to scan
const UNVERIFIED_TARGETS = [
  // Add addresses from Etherscan's unverified contracts
  "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C", // Our known vulnerable vault
  "0x1234567890123456789012345678901234567890", // Example - replace with real addresses
  "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd", // Example - replace with real addresses
];

/**
 * Enhanced vulnerability detection
 */
async function enhancedVulnCheck(address, provider) {
  try {
    const code = await provider.getCode(address);
    const balance = await provider.getBalance(address);
    
    if (code === "0x" || code.length <= 10) {
      return null;
    }
    
    // Check if legitimate protocol
    if (LEGITIMATE_PROTOCOLS.includes(address)) {
      return { 
        address, 
        isLegitimate: true,
        reason: "Known DeFi protocol"
      };
    }
    
    // Find backdoors
    const foundBackdoors = [];
    for (const pattern of BACKDOOR_PATTERNS) {
      if (code.includes(pattern.sig.slice(2))) {
        foundBackdoors.push(pattern);
      }
    }
    
    // Get balances
    let usdcBalance = "0";
    try {
      const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
      const usdcABI = ["function balanceOf(address) view returns (uint256)"];
      const usdc = new ethers.Contract(USDC, usdcABI, provider);
      const bal = await usdc.balanceOf(address);
      usdcBalance = ethers.formatUnits(bal, 6);
    } catch (e) {}
    
    // Analyze risk
    const totalValueUSD = (parseFloat(ethers.formatEther(balance)) * 3500) + parseFloat(usdcBalance);
    const highRiskBackdoors = foundBackdoors.filter(b => b.risk === "HIGH");
    
    return {
      address,
      isLegitimate: false,
      ethBalance: ethers.formatEther(balance),
      usdcBalance,
      totalValueUSD,
      codeSize: code.length,
      backdoors: foundBackdoors,
      riskLevel: highRiskBackdoors.length > 0 ? "HIGH" : 
                 foundBackdoors.length > 0 ? "MEDIUM" : "LOW",
      isVulnerable: foundBackdoors.length > 0
    };
    
  } catch (error) {
    return null;
  }
}

/**
 * Find unverified contracts on chain
 */
async function findUnverifiedContracts() {
  console.log("\nüîç SEARCHING FOR UNVERIFIED CONTRACTS");
  console.log("====================================");
  
  const provider = ethers.provider;
  const currentBlock = await provider.getBlockNumber();
  const vulnerableContracts = [];
  
  // Scan recent blocks for contract creations
  console.log(`Scanning last 100 blocks from ${currentBlock}...`);
  
  for (let i = currentBlock - 100; i < currentBlock; i++) {
    try {
      const block = await provider.getBlock(i, true);
      if (!block || !block.transactions) continue;
      
      for (const tx of block.transactions) {
        // Contract creation has null 'to' address
        if (!tx.to && tx.creates) {
          const result = await enhancedVulnCheck(tx.creates, provider);
          if (result && result.isVulnerable) {
            vulnerableContracts.push(result);
            console.log(`\n‚úÖ Found vulnerable contract: ${tx.creates}`);
          }
        }
      }
    } catch (e) {
      // Continue scanning
    }
  }
  
  return vulnerableContracts;
}

/**
 * Main smart scanner
 */
async function smartScanner() {
  console.log("\nüß† SMART VULNERABILITY SCANNER");
  console.log("==============================");
  console.log("Filtering out legitimate DeFi protocols...\n");
  
  const provider = ethers.provider;
  const actualVulnerabilities = [];
  
  // First scan our known targets
  console.log("üìä Scanning known targets...");
  
  for (const address of UNVERIFIED_TARGETS) {
    const result = await enhancedVulnCheck(address, provider);
    if (result && result.isVulnerable) {
      actualVulnerabilities.push(result);
    }
  }
  
  // Find new unverified contracts
  const newVulnerable = await findUnverifiedContracts();
  actualVulnerabilities.push(...newVulnerable);
  
  // Display results
  console.log("\n\nüéØ ACTUAL VULNERABILITIES FOUND");
  console.log("================================");
  console.log(`Total suspicious contracts: ${actualVulnerabilities.length}`);
  
  if (actualVulnerabilities.length > 0) {
    // Sort by risk and value
    actualVulnerabilities.sort((a, b) => {
      if (a.riskLevel !== b.riskLevel) {
        return a.riskLevel === "HIGH" ? -1 : 1;
      }
      return b.totalValueUSD - a.totalValueUSD;
    });
    
    actualVulnerabilities.forEach((contract, i) => {
      console.log(`\n${i + 1}. ${contract.address}`);
      console.log(`   üí∞ Value: $${contract.totalValueUSD.toFixed(0)}`);
      console.log(`   üö® Risk Level: ${contract.riskLevel}`);
      console.log(`   üì¶ Code size: ${contract.codeSize} bytes`);
      console.log(`   üîì Backdoors found:`);
      contract.backdoors.forEach(b => {
        console.log(`      ‚Ä¢ ${b.name} (${b.risk} risk)`);
      });
      
      if (contract.riskLevel === "HIGH") {
        console.log(`   \n   üéØ EXPLOIT COMMAND:`);
        console.log(`   npx hardhat run scripts/deep_backdoor_exploit.js --network localhost`);
      }
    });
  }
  
  console.log("\n\nüí° KEY INSIGHTS:");
  console.log("================");
  console.log("‚Ä¢ Legitimate DeFi protocols excluded");
  console.log("‚Ä¢ Focus on unverified contracts");
  console.log("‚Ä¢ High-risk backdoors prioritized");
  console.log("‚Ä¢ Look for execute(), adminCall(), setOwner()");
  
  console.log("\nüìç WHERE TO FIND MORE TARGETS:");
  console.log("‚Ä¢ Etherscan unverified contracts section");
  console.log("‚Ä¢ Recent deployments with high ETH transfers");
  console.log("‚Ä¢ Contracts receiving funds from mixers");
  console.log("‚Ä¢ Clone contracts of known scams");
}

// Execute
smartScanner()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
