const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Trace All Withdrawals
 * @notice Find all major USDC movements from vault
 * @dev Map the complete withdrawal history
 */
async function main() {
  console.log("\nðŸ“Š COMPLETE WITHDRAWAL HISTORY ANALYSIS");
  console.log("=====================================");
  
  const USDC_ABI = [
    "function balanceOf(address account) view returns (uint256)"
  ];
  
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  const currentBlock = await ethers.provider.getBlockNumber();
  const currentBalance = await usdc.balanceOf(VAULT_ADDRESS);
  
  console.log(`Current: ${ethers.formatUnits(currentBalance, 6)} USDC at block ${currentBlock}`);
  
  // Track balance history
  const balanceHistory = [];
  const withdrawals = [];
  
  console.log("\nðŸ“ˆ Tracking balance changes (every 50k blocks)...");
  
  let lastBalance = currentBalance;
  let peakBalance = currentBalance;
  let peakBlock = currentBlock;
  
  // Go back up to 1M blocks (~5 months)
  for (let block = currentBlock; block > currentBlock - 1000000; block -= 50000) {
    try {
      const balance = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: block });
      const balanceNum = parseFloat(ethers.formatUnits(balance, 6));
      
      // Track peak
      if (balance > peakBalance) {
        peakBalance = balance;
        peakBlock = block;
      }
      
      // Check for significant changes
      const diff = lastBalance - balance;
      const diffNum = parseFloat(ethers.formatUnits(diff > 0n ? diff : -diff, 6));
      
      if (diffNum > 100000) { // More than 100k USDC change
        const direction = diff > 0n ? "â¬‡ï¸ Withdrawal" : "â¬†ï¸ Deposit";
        console.log(`Block ${block}: ${balanceNum.toFixed(2)} USDC ${direction} ${diffNum.toFixed(2)}`);
        
        if (diff > 0n && diffNum > 1000000) { // Withdrawal > 1M
          withdrawals.push({
            startBlock: block,
            endBlock: block + 50000,
            amount: diffNum,
            fromBalance: parseFloat(ethers.formatUnits(balance + diff, 6)),
            toBalance: balanceNum
          });
        }
      }
      
      balanceHistory.push({ block, balance: balanceNum });
      lastBalance = balance;
      
      // Stop if balance is 0
      if (balance === 0n) {
        console.log("\nReached zero balance, vault was empty");
        break;
      }
      
    } catch (e) {
      // Skip errors
    }
  }
  
  console.log(`\nðŸ“Š Peak balance: ${ethers.formatUnits(peakBalance, 6)} USDC at block ${peakBlock}`);
  
  // Analyze major withdrawals
  console.log("\nðŸ’¸ MAJOR WITHDRAWALS FOUND:");
  console.log("=====================================");
  
  let totalWithdrawn = 0;
  
  for (const w of withdrawals.sort((a, b) => b.amount - a.amount)) {
    console.log(`\nðŸ”´ ${w.amount.toFixed(2)} USDC withdrawn`);
    console.log(`   Blocks: ${w.startBlock} - ${w.endBlock}`);
    console.log(`   Balance: ${w.fromBalance.toFixed(2)} â†’ ${w.toBalance.toFixed(2)}`);
    totalWithdrawn += w.amount;
  }
  
  console.log(`\nðŸ“Š Total withdrawn: ${totalWithdrawn.toFixed(2)} USDC`);
  
  // Focus on largest withdrawal
  if (withdrawals.length > 0) {
    const largest = withdrawals[0];
    console.log(`\nðŸŽ¯ Analyzing largest withdrawal (${largest.amount.toFixed(2)} USDC)...`);
    
    // Binary search for exact block
    let low = largest.startBlock;
    let high = largest.endBlock;
    
    while (high - low > 1) {
      const mid = Math.floor((low + high) / 2);
      const midBal = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: mid });
      const midNum = parseFloat(ethers.formatUnits(midBal, 6));
      
      if (midNum > largest.toBalance) {
        low = mid;
      } else {
        high = mid;
      }
    }
    
    console.log(`\nâœ… Exact withdrawal at block ${high}`);
    
    // Get transaction
    const block = await ethers.provider.getBlock(high, true);
    
    for (const txHash of block.transactions) {
      const tx = await ethers.provider.getTransaction(txHash);
      
      if (tx.to?.toLowerCase() === VAULT_ADDRESS.toLowerCase()) {
        console.log(`\nðŸ”“ Potential backdoor transaction:`);
        console.log(`   Hash: ${txHash}`);
        console.log(`   From: ${tx.from}`);
        console.log(`   Selector: ${tx.data.slice(0, 10)}`);
        console.log(`   Data length: ${tx.data.length}`);
        
        // This is likely our backdoor!
        return {
          selector: tx.data.slice(0, 10),
          txHash,
          block: high,
          amount: largest.amount
        };
      }
    }
  }
  
  console.log("\nðŸ’¡ INSIGHTS:");
  console.log("- Multiple large withdrawals suggest active exploitation");
  console.log("- Backdoor function is being used repeatedly");
  console.log("- Pattern indicates insider knowledge required");
}

main()
  .then(result => {
    if (result) {
      console.log("\nðŸ”‘ Backdoor selector:", result.selector);
      console.log("Investigate this transaction on Etherscan!");
    }
  })
  .catch((error) => {
    console.error("\nðŸ’¥ Script error:", error);
    process.exit(1);
  });
