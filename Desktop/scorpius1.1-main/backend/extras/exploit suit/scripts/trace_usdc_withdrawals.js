const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Trace USDC Withdrawals
 * @notice Analyze how 13.8M USDC was withdrawn from the vault
 * @dev Look for Transfer events and analyze the withdrawal transactions
 */
async function main() {
  console.log("\nüïµÔ∏è TRACING USDC WITHDRAWALS");
  console.log("=====================================");
  console.log("Vault had: 22M USDC");
  console.log("Vault now has: 8.2M USDC");
  console.log("Missing: ~13.8M USDC");
  
  const provider = ethers.provider;
  const currentBlock = await provider.getBlockNumber();
  
  // Get USDC contract interface
  const usdcAbi = [
    "event Transfer(address indexed from, address indexed to, uint256 value)",
    "function balanceOf(address account) view returns (uint256)"
  ];
  const usdc = new ethers.Contract(USDC_ADDRESS, usdcAbi, provider);
  
  // Current balance verification
  const currentBalance = await usdc.balanceOf(VAULT_ADDRESS);
  console.log("\nCurrent USDC balance:", ethers.formatUnits(currentBalance, 6), "USDC");
  
  console.log("\nüìä Searching for large USDC transfers FROM vault...");
  console.log("This may take a moment...\n");
  
  // Search in chunks to avoid timeout
  const BLOCK_CHUNK = 1000;
  const START_BLOCK = currentBlock - 5000; // Look back ~17 hours
  
  let totalTransferred = 0n;
  const transfers = [];
  
  for (let fromBlock = START_BLOCK; fromBlock < currentBlock; fromBlock += BLOCK_CHUNK) {
    const toBlock = Math.min(fromBlock + BLOCK_CHUNK - 1, currentBlock);
    
    try {
      // Get Transfer events FROM the vault
      const filter = usdc.filters.Transfer(VAULT_ADDRESS, null);
      const events = await usdc.queryFilter(filter, fromBlock, toBlock);
      
      for (const event of events) {
        const amount = event.args.value;
        const amountUSDC = ethers.formatUnits(amount, 6);
        
        // Only show transfers > 100k USDC
        if (amount > ethers.parseUnits("100000", 6)) {
          const block = await provider.getBlock(event.blockNumber);
          const tx = await provider.getTransaction(event.transactionHash);
          
          transfers.push({
            block: event.blockNumber,
            txHash: event.transactionHash,
            to: event.args.to,
            amount: amountUSDC,
            timestamp: new Date(block.timestamp * 1000).toLocaleString(),
            from: tx.from,
            methodId: tx.data.slice(0, 10)
          });
          
          totalTransferred += amount;
          
          console.log(`üí∏ Transfer Found:`);
          console.log(`   Block: ${event.blockNumber}`);
          console.log(`   Amount: ${amountUSDC} USDC`);
          console.log(`   To: ${event.args.to}`);
          console.log(`   Tx: ${event.transactionHash}`);
          console.log(`   Time: ${new Date(block.timestamp * 1000).toLocaleString()}`);
          console.log(`   Called by: ${tx.from}`);
          console.log(`   Method: ${tx.data.slice(0, 10)}`);
          console.log("");
        }
      }
    } catch (e) {
      console.log(`Error scanning blocks ${fromBlock}-${toBlock}:`, e.message);
    }
  }
  
  console.log("\nüìà WITHDRAWAL ANALYSIS:");
  console.log("=====================================");
  console.log(`Total USDC transferred out: ${ethers.formatUnits(totalTransferred, 6)} USDC`);
  console.log(`Number of large transfers: ${transfers.length}`);
  
  if (transfers.length > 0) {
    // Analyze the methods used
    console.log("\nüîç Methods used for withdrawals:");
    const methods = {};
    transfers.forEach(t => {
      methods[t.methodId] = (methods[t.methodId] || 0) + 1;
    });
    
    for (const [method, count] of Object.entries(methods)) {
      console.log(`${method}: used ${count} times`);
      
      // Try to decode the method
      const possibleSigs = [
        { sig: "withdraw(uint256)", selector: "0x2e1a7d4d" },
        { sig: "transfer(address,uint256)", selector: "0xa9059cbb" },
        { sig: "withdrawTo(address,uint256)", selector: "0x205c2878" },
        { sig: "withdrawToken(address,uint256)", selector: "0x9e281a98" },
        { sig: "emergencyWithdraw(address,uint256)", selector: "0x5312ea8e" },
        { sig: "adminWithdraw(address,uint256)", selector: "0xf3fef3a3" },
        { sig: "execute(address,uint256,bytes)", selector: "0xb61d27f6" }
      ];
      
      const match = possibleSigs.find(s => s.selector === method);
      if (match) {
        console.log(`  ‚Üí Likely: ${match.sig}`);
      }
    }
    
    // Analyze recipients
    console.log("\nüí∞ Top recipients:");
    const recipients = {};
    transfers.forEach(t => {
      recipients[t.to] = (recipients[t.to] || 0) + parseFloat(t.amount);
    });
    
    const sortedRecipients = Object.entries(recipients)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);
    
    for (const [addr, amount] of sortedRecipients) {
      console.log(`${addr}: ${amount.toLocaleString()} USDC`);
    }
    
    // Show who initiated the withdrawals
    console.log("\nüë§ Who initiated withdrawals:");
    const initiators = {};
    transfers.forEach(t => {
      initiators[t.from] = (initiators[t.from] || 0) + 1;
    });
    
    for (const [addr, count] of Object.entries(initiators)) {
      console.log(`${addr}: ${count} transactions`);
    }
    
    // Get the most recent successful withdrawal transaction
    if (transfers.length > 0) {
      const lastWithdrawal = transfers[transfers.length - 1];
      console.log("\nüéØ LAST SUCCESSFUL WITHDRAWAL:");
      console.log(`Transaction: ${lastWithdrawal.txHash}`);
      console.log(`Method: ${lastWithdrawal.methodId}`);
      
      // Analyze this transaction in detail
      console.log("\nüî¨ Analyzing last withdrawal transaction...");
      const tx = await provider.getTransaction(lastWithdrawal.txHash);
      console.log("Full calldata:", tx.data);
      
      // Decode if it's a known pattern
      if (tx.data.startsWith("0xb61d27f6")) {
        console.log("\n‚úÖ This is execute(address,uint256,bytes)!");
        const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
          ["address", "uint256", "bytes"],
          "0x" + tx.data.slice(10)
        );
        console.log("Target:", decoded[0]);
        console.log("Value:", decoded[1].toString());
        console.log("Data:", decoded[2]);
        
        if (decoded[2].startsWith("0xa9059cbb")) {
          console.log("\nüí° The execute function is calling transfer() on USDC!");
          const transferDecoded = ethers.AbiCoder.defaultAbiCoder().decode(
            ["address", "uint256"],
            "0x" + decoded[2].slice(10)
          );
          console.log("Transfer to:", transferDecoded[0]);
          console.log("Transfer amount:", ethers.formatUnits(transferDecoded[1], 6), "USDC");
        }
      }
      
      console.log("\nüöÄ TO REPRODUCE THIS WITHDRAWAL:");
      console.log("1. Use the same method selector:", lastWithdrawal.methodId);
      console.log("2. Called by:", lastWithdrawal.from);
      console.log("3. You might need admin privileges");
    }
  } else {
    console.log("\n‚ùå No large USDC transfers found in recent blocks");
    console.log("The funds might have been withdrawn earlier or through multiple small transactions");
  }
}

main().catch((error) => {
  console.error("\nüí• Script error:", error);
  process.exit(1);
});
