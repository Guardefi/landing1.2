const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

async function main() {
  console.log("\n🏁 FINAL ATTACK SUMMARY");
  console.log("=====================================");
  console.log("Target Vault:", VAULT_ADDRESS);
  console.log("Date:", new Date().toISOString());
  
  const [attacker] = await ethers.getSigners();
  
  // Get ETH balances
  const vaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  const attackerETH = await ethers.provider.getBalance(attacker.address);
  
  // Get USDC contract and balances
  const USDC = await ethers.getContractAt("contracts/IERC20.sol:IERC20", USDC_ADDRESS);
  const vaultUSDC = await USDC.balanceOf(VAULT_ADDRESS);
  const attackerUSDC = await USDC.balanceOf(attacker.address);
  
  // Get vault code info
  const vaultCode = await ethers.provider.getCode(VAULT_ADDRESS);
  
  console.log("\n💰 ETH EXTRACTION RESULTS:");
  console.log("Original vault ETH: 290.68 ETH");
  console.log("Current vault ETH:", ethers.formatEther(vaultETH), "ETH");
  console.log("ETH extracted:", ethers.formatEther(ethers.parseEther("290.68") - vaultETH), "ETH");
  console.log("Extraction rate:", ((Number(ethers.parseEther("290.68") - vaultETH) / Number(ethers.parseEther("290.68"))) * 100).toFixed(2), "%");
  
  console.log("\n💵 USDC EXTRACTION RESULTS:");
  console.log("Vault USDC balance:", ethers.formatUnits(vaultUSDC, 6), "USDC");
  console.log("Attacker USDC balance:", ethers.formatUnits(attackerUSDC, 6), "USDC");
  
  console.log("\n🔍 CONTRACT STATE:");
  console.log("Vault code intact:", vaultCode.length > 2 ? "Yes" : "No");
  console.log("Code size:", vaultCode.length / 2 - 1, "bytes");
  
  // Check implementation
  try {
    const implCall = await attacker.call({
      to: VAULT_ADDRESS,
      data: "0x60c7d295"
    });
    const impl = "0x" + implCall.slice(26, 66);
    console.log("Current implementation:", impl);
  } catch (e) {
    console.log("Implementation check failed");
  }
  
  // Check owner
  try {
    const ownerCall = await attacker.call({
      to: VAULT_ADDRESS,
      data: "0x8da5cb5b"
    });
    const owner = "0x" + ownerCall.slice(26);
    console.log("Current owner:", owner);
  } catch (e) {
    console.log("Owner check failed");
  }
  
  console.log("\n📊 ATTACK TECHNIQUES USED:");
  console.log("✅ Direct function calls (withdraw variants)");
  console.log("✅ Delegatecall exploitation");
  console.log("✅ Storage manipulation");
  console.log("✅ Proxy upgrade attempts");
  console.log("✅ Force send attacks");
  console.log("✅ USDC token extraction attempts");
  
  console.log("\n🎯 VULNERABILITY FINDINGS:");
  console.log("- Contract uses proxy pattern (implementation at", "0x11fb858ee4bf594857483bcf86eb825aef1cbf91)");
  console.log("- Owner is uninitialized (0x0)");
  console.log("- Delegatecall functions present");
  console.log("- Multiple unknown function selectors discovered");
  console.log("- Contract accepted transactions but prevented fund extraction");
  
  console.log("\n💡 LESSONS LEARNED:");
  console.log("1. The vault has security mechanisms preventing direct withdrawals");
  console.log("2. Proxy upgrade succeeded but didn't grant access to funds");
  console.log("3. Storage manipulation didn't bypass access controls");
  console.log("4. USDC tokens may require different extraction approach");
  console.log("5. Further analysis of unknown functions needed");
  
  const totalETHExtracted = ethers.parseEther("290.68") - vaultETH;
  if (totalETHExtracted > 0n) {
    console.log("\n🏆 PARTIAL SUCCESS!");
    console.log("Successfully extracted", ethers.formatEther(totalETHExtracted), "ETH from the vault!");
  }
  
  console.log("\n✅ Attack simulation complete on forked mainnet.");
  console.log("No real funds were at risk during this educational exercise.");
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
