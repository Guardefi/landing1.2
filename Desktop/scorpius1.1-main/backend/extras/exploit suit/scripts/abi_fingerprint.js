const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

// Common function signatures to test
const COMMON_SIGNATURES = {
  // Standard functions
  "0x3ccfd60b": "withdraw()",
  "0xdb006a75": "emergencyWithdraw(uint256)",
  "0x69328dec": "emergencyWithdraw(address,uint256)",
  "0x9890220b": "drain()",
  "0x853828b6": "withdrawAll()",
  "0x8da5cb5b": "owner()",
  "0x715018a6": "renounceOwnership()",
  "0xf2fde38b": "transferOwnership(address)",
  
  // Access control
  "0xa217fddf": "DEFAULT_ADMIN_ROLE()",
  "0x91d14854": "hasRole(bytes32,address)",
  "0x2f2ff15d": "grantRole(bytes32,address)",
  
  // Balance and state
  "0x70a08231": "balanceOf(address)",
  "0x18160ddd": "totalSupply()",
  "0xd0e30db0": "deposit()",
  "0x2e1a7d4d": "withdraw(uint256)",
  
  // Dangerous functions
  "0x5b34b966": "delegatecall(address,bytes)",
  "0x61461954": "execute(address,uint256,bytes)",
  "0x4e71e0c8": "claimOwnership()",
  "0x47f57b32": "setImplementation(address)",
  
  // Proxy patterns
  "0x5c60da1b": "implementation()",
  "0x3659cfe6": "upgradeTo(address)",
  "0x4f1ef286": "upgradeToAndCall(address,bytes)",
  
  // Flash loan
  "0x5cffe9de": "flashLoan(address,address,uint256,bytes)",
  "0xaab20ec3": "flashLoanCallback(address,uint256,uint256,bytes)",
  
  // Reentrancy vectors
  "0": "fallback()",
  "0xe8e33700": "call(address,uint256,bytes)",
  "0x2e1a7d4d": "withdraw(uint256)",
  "0x3ccfd60b": "withdraw()",
  
  // Admin functions
  "0x5c975abb": "paused()",
  "0x8456cb59": "pause()",
  "0x3f4ba83a": "unpause()",
  "0x83197ef0": "destroy()",
  "0x41c0e1b5": "kill()"
};

async function main() {
  console.log("\nðŸ” ABI FINGERPRINTING - CONTRACT ANALYSIS");
  console.log("=========================================");
  console.log("Target:", VAULT_ADDRESS);
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\nðŸ“‹ TESTING KNOWN FUNCTION SIGNATURES:");
  console.log("Format: [selector] name() â†’ result\n");
  
  const workingFunctions = [];
  const failedFunctions = [];
  
  for (const [selector, name] of Object.entries(COMMON_SIGNATURES)) {
    try {
      // Try static call first
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 100000
      });
      
      if (result && result !== "0x") {
        console.log(`âœ… [${selector}] ${name} â†’ ${result.slice(0, 66)}...`);
        workingFunctions.push({ selector, name, result });
        
        // Try to decode common return types
        try {
          if (name.includes("()") && result.length === 66) {
            // Might be address
            const decoded = ethers.AbiCoder.defaultAbiCoder().decode(["address"], result);
            console.log(`   Decoded: ${decoded[0]}`);
          }
        } catch (e) {
          // Silent fail on decode
        }
      } else {
        // Function exists but returns empty
        console.log(`âš ï¸  [${selector}] ${name} â†’ (empty/void)`);
        workingFunctions.push({ selector, name, result: "void" });
      }
    } catch (error) {
      // Function doesn't exist or reverts
      if (error.message.includes("revert")) {
        console.log(`ðŸš« [${selector}] ${name} â†’ REVERTED`);
        failedFunctions.push({ selector, name, error: "reverted" });
      } else {
        // Doesn't exist
        failedFunctions.push({ selector, name, error: "not found" });
      }
    }
  }
  
  console.log("\nðŸ“Š SUMMARY:");
  console.log(`Working functions: ${workingFunctions.length}`);
  console.log(`Failed/Missing: ${failedFunctions.length}`);
  
  if (workingFunctions.length > 0) {
    console.log("\nâœ… CONFIRMED FUNCTIONS:");
    workingFunctions.forEach(f => {
      console.log(`  - ${f.name} [${f.selector}]`);
    });
  }
  
  // Try to brute force some selectors
  console.log("\nðŸŽ¯ TESTING ADDITIONAL SELECTORS:");
  
  // Generate selectors for common patterns
  const additionalTests = [
    "transfer(address,uint256)",
    "transferFrom(address,address,uint256)",
    "approve(address,uint256)",
    "mint(address,uint256)",
    "burn(uint256)",
    "initialize()",
    "init()",
    "setOwner(address)",
    "setAdmin(address)",
    "sweep()",
    "rescue()",
    "claim()",
    "harvest()",
    "compound()",
    "stake(uint256)",
    "unstake(uint256)",
    "getReward()",
    "exit()"
  ];
  
  for (const funcSig of additionalTests) {
    const selector = ethers.id(funcSig).slice(0, 10);
    
    try {
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 100000
      });
      
      if (result && result !== "0x") {
        console.log(`âœ… FOUND: ${funcSig} [${selector}]`);
        workingFunctions.push({ selector, name: funcSig, result });
      }
    } catch (e) {
      // Silent fail
    }
  }
  
  // Export results
  console.log("\nðŸ’¾ EXPORT READY:");
  console.log("Working function selectors for use in exploits:");
  const selectors = workingFunctions.map(f => f.selector);
  console.log(JSON.stringify(selectors, null, 2));
  
  console.log("\nâœ… Fingerprinting complete!");
}

main().catch((error) => {
  console.error("\nðŸ’¥ Script failed:", error);
  process.exit(1);
});
