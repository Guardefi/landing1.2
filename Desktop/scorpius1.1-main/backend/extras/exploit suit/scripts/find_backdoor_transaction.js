const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Find Backdoor Transaction
 * @notice Fork at earlier block and find the 13.8M USDC withdrawal
 * @dev Trace the exact backdoor mechanism used
 */
async function main() {
  console.log("\nüïµÔ∏è BACKDOOR TRANSACTION HUNTER");
  console.log("=====================================");
  console.log("Mission: Find when and how 13.8M USDC was withdrawn");
  
  // Get USDC interface
  const USDC_ABI = [
    "function balanceOf(address account) view returns (uint256)",
    "event Transfer(address indexed from, address indexed to, uint256 value)"
  ];
  
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  // Check current balance
  const currentBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const currentBlock = await ethers.provider.getBlockNumber();
  
  console.log(`Current block: ${currentBlock}`);
  console.log(`Current USDC balance: ${ethers.formatUnits(currentBalance, 6)}`);
  
  // Binary search to find when balance was ~22M
  console.log("\nüîç Searching for block with 22M USDC...");
  
  let highBlock = currentBlock;
  let lowBlock = currentBlock - 100000; // Start 100k blocks back (~2 weeks)
  let targetBlock = 0;
  let foundBlock = false;
  
  // Quick check if we need to go further back
  const oldBalance = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: lowBlock });
  console.log(`Balance at block ${lowBlock}: ${ethers.formatUnits(oldBalance, 6)} USDC`);
  
  if (oldBalance < ethers.parseUnits("20000000", 6)) {
    console.log("Need to search further back...");
    lowBlock = currentBlock - 500000; // Go back ~2 months
  }
  
  // Binary search for the withdrawal
  while (highBlock - lowBlock > 10) {
    const midBlock = Math.floor((highBlock + lowBlock) / 2);
    
    try {
      const balance = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: midBlock });
      const balanceFormatted = parseFloat(ethers.formatUnits(balance, 6));
      
      console.log(`Block ${midBlock}: ${balanceFormatted.toFixed(2)} USDC`);
      
      if (balanceFormatted > 20000000) {
        // Still has high balance, withdrawal is after this
        lowBlock = midBlock;
        targetBlock = midBlock;
      } else if (balanceFormatted < 10000000) {
        // Already withdrawn, go back
        highBlock = midBlock;
      } else {
        // Found the range!
        console.log(`\n‚úÖ Found withdrawal range: blocks ${midBlock-1000} to ${midBlock+1000}`);
        foundBlock = true;
        targetBlock = midBlock;
        break;
      }
    } catch (e) {
      console.log(`Error at block ${midBlock}, adjusting...`);
      highBlock = midBlock;
    }
  }
  
  if (!foundBlock) {
    targetBlock = lowBlock;
  }
  
  console.log(`\nüìç Focusing on block range around: ${targetBlock}`);
  
  // Now scan for the exact withdrawal transaction
  console.log("\nüîé Scanning for large USDC transfers...");
  
  const scanRange = 2000; // Scan 2000 blocks
  const startBlock = targetBlock - scanRange/2;
  const endBlock = targetBlock + scanRange/2;
  
  console.log(`Scanning blocks ${startBlock} to ${endBlock}...`);
  
  // Get Transfer events from USDC contract where vault is sender
  const filter = usdc.filters.Transfer(VAULT_ADDRESS, null, null);
  
  try {
    const events = await usdc.queryFilter(filter, startBlock, endBlock);
    
    console.log(`\nFound ${events.length} transfers from vault`);
    
    // Find large transfers (> 1M USDC)
    const largeTransfers = events.filter(event => {
      const amount = event.args[2];
      return amount > ethers.parseUnits("1000000", 6);
    });
    
    console.log(`\nüí∞ Found ${largeTransfers.length} large transfers:`);
    
    for (const event of largeTransfers) {
      const amount = ethers.formatUnits(event.args[2], 6);
      const recipient = event.args[1];
      const txHash = event.transactionHash;
      const block = event.blockNumber;
      
      console.log(`\nüéØ Transfer of ${amount} USDC`);
      console.log(`   To: ${recipient}`);
      console.log(`   Block: ${block}`);
      console.log(`   Tx: ${txHash}`);
      
      // Get the transaction details
      const tx = await ethers.provider.getTransaction(txHash);
      console.log(`   From EOA: ${tx.from}`);
      console.log(`   Gas Used: ${tx.gasLimit}`);
      
      // Decode the transaction data
      console.log(`\n   üìú Analyzing transaction data...`);
      console.log(`   Data length: ${tx.data.length}`);
      console.log(`   Function selector: ${tx.data.slice(0, 10)}`);
      
      // If this is the ~13.8M withdrawal, analyze deeply
      if (parseFloat(amount) > 10000000) {
        console.log(`\n   üö® THIS IS THE BACKDOOR TRANSACTION!`);
        console.log(`   Full data: ${tx.data}`);
        
        // Try to decode the function call
        const selector = tx.data.slice(0, 10);
        console.log(`\n   üîì Backdoor function selector: ${selector}`);
        
        // Save this for testing
        console.log(`\n   üíæ Saving backdoor details...`);
        
        return {
          selector: selector,
          data: tx.data,
          from: tx.from,
          block: block,
          amount: amount,
          recipient: recipient
        };
      }
    }
  } catch (e) {
    console.log("Error scanning events:", e.message);
    console.log("\nTrying alternative approach...");
    
    // Alternative: Check specific blocks
    for (let block = startBlock; block <= endBlock; block += 100) {
      try {
        const balance = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: block });
        const nextBalance = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: block + 100 });
        
        const diff = balance - nextBalance;
        if (diff > ethers.parseUnits("1000000", 6)) {
          console.log(`\nüéØ Large withdrawal between blocks ${block} and ${block + 100}`);
          console.log(`   Amount: ${ethers.formatUnits(diff, 6)} USDC`);
          
          // Narrow down
          for (let b = block; b < block + 100; b++) {
            const bal1 = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: b });
            const bal2 = await usdc.balanceOf(VAULT_ADDRESS, { blockTag: b + 1 });
            
            if (bal1 > bal2 && (bal1 - bal2) > ethers.parseUnits("10000000", 6)) {
              console.log(`\n   ‚úÖ Found exact block: ${b + 1}`);
              console.log(`   Withdrawn: ${ethers.formatUnits(bal1 - bal2, 6)} USDC`);
              
              // Get block transactions
              const block = await ethers.provider.getBlock(b + 1, true);
              console.log(`   Block has ${block.transactions.length} transactions`);
              
              // Find vault transactions
              for (const txHash of block.transactions) {
                const tx = await ethers.provider.getTransaction(txHash);
                if (tx.to?.toLowerCase() === VAULT_ADDRESS.toLowerCase()) {
                  console.log(`\n   üéØ Found vault transaction!`);
                  console.log(`   From: ${tx.from}`);
                  console.log(`   Data: ${tx.data}`);
                  console.log(`   Selector: ${tx.data.slice(0, 10)}`);
                }
              }
              
              return;
            }
          }
        }
      } catch (e) {
        // Skip errors
      }
    }
  }
  
  console.log("\nüìä INVESTIGATION COMPLETE");
  console.log("=====================================");
  console.log("To proceed:");
  console.log("1. Fork at the block BEFORE the withdrawal");
  console.log("2. Replay the backdoor transaction");
  console.log("3. Analyze the exact mechanism");
  console.log("4. Attempt to use the backdoor ourselves");
}

main()
  .then(backdoor => {
    if (backdoor) {
      console.log("\nüîë BACKDOOR FOUND!");
      console.log("Selector:", backdoor.selector);
      console.log("Use this to extract remaining funds!");
    }
  })
  .catch((error) => {
    console.error("\nüí• Script error:", error);
    process.exit(1);
  });
