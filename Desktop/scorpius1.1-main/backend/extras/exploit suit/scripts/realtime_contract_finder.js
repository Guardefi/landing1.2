const { ethers } = require("hardhat");

/**
 * @title Realtime Contract Finder
 * @notice Finds real contracts from actual Ethereum activity
 */

const BACKDOORS = [
  { sig: "0x78e111f6", name: "execute(address,bytes)" },
  { sig: "0x9e8c708e", name: "adminCall(address,bytes)" },
  { sig: "0x13af4035", name: "setOwner(address)" },
  { sig: "0x3659cfe6", name: "upgradeTo(address)" },
  { sig: "0x24a084df", name: "adminExecute(address,bytes)" }
];

/**
 * Find contracts from recent mainnet activity
 */
async function findRealContracts() {
  console.log("üîç Finding real contracts from mainnet activity...");
  const contracts = new Set();
  
  try {
    const currentBlock = await ethers.provider.getBlockNumber();
    console.log(`Current block: ${currentBlock}`);
    
    // Scan last 50 blocks for contract interactions
    for (let i = 0; i < 50; i++) {
      const blockNumber = currentBlock - i;
      
      try {
        const block = await ethers.provider.getBlock(blockNumber, true);
        if (!block || !block.transactions) continue;
        
        console.log(`Block ${blockNumber}: ${block.transactions.length} txs`);
        
        for (const tx of block.transactions) {
          // Contract creation
          if (!tx.to && tx.creates) {
            contracts.add(tx.creates);
          }
          
          // Contract interaction (to address with code)
          if (tx.to) {
            try {
              const code = await ethers.provider.getCode(tx.to);
              if (code && code !== "0x" && code.length > 100) {
                contracts.add(tx.to);
              }
            } catch (e) {}
          }
          
          // Stop if we have enough
          if (contracts.size > 200) break;
        }
        
        if (contracts.size > 200) break;
        
      } catch (e) {
        console.log(`Error on block ${blockNumber}:`, e.message);
      }
    }
    
  } catch (e) {
    console.log("Error scanning blocks:", e.message);
  }
  
  // Add some known high-value addresses from Etherscan top accounts
  const knownAddresses = [
    "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C", // Our known vulnerable
    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
    "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
    "0xBA12222222228d8Ba445958a75a0704d566BF2C8", // Balancer
    "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", // Uniswap V2
    "0xE592427A0AEce92De3Edee1F18E0157C05861564", // Uniswap V3
    "0x1111111254fb6c44bAC0beD2854e76F90643097d", // 1inch
    "0x6B175474E89094C44Da98b954EedeAC495271d0F", // DAI
    "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599", // WBTC
    "0x514910771AF9Ca656af840dff83E8264EcF986CA", // LINK
    "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84", // Lido stETH
    "0x5f98805A4E8be255a32880FDeC7F6728C6568bA0", // Lido Curve Pool
    "0x06325440D014e39736583c165C2963BA99fAf14E", // Curve stETH
    "0xDC24316b9AE028F1497c275EB9192a3Ea0f67022", // Curve stETH/ETH
    // Add more from Etherscan's rich list
    "0x28C6c06298d514Db089934071355E5743bf21d60", // Binance 1
    "0xDFd5293D8e347dFe59E90eFd55b2956a1343963d", // Binance 2
    "0xF977814e90dA44bFA03b6295A0616a897441aceC", // Binance 3
    "0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a", // Arbitrum Bridge
    "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"  // Optimism Bridge
  ];
  
  knownAddresses.forEach(addr => contracts.add(addr));
  
  console.log(`Found ${contracts.size} unique contracts`);
  return Array.from(contracts);
}

/**
 * Quick vulnerability scan
 */
async function quickVulnScan(address) {
  try {
    const code = await ethers.provider.getCode(address);
    if (!code || code === "0x" || code.length < 50) {
      return null;
    }
    
    // Check for backdoors
    const foundBackdoors = [];
    for (const backdoor of BACKDOORS) {
      if (code.includes(backdoor.sig.slice(2))) {
        foundBackdoors.push(backdoor);
      }
    }
    
    // Get balances
    const ethBalance = await ethers.provider.getBalance(address);
    const ethValue = parseFloat(ethers.formatEther(ethBalance));
    
    // Quick USDC check
    let usdcValue = 0;
    try {
      const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
      const usdcContract = new ethers.Contract(
        USDC,
        ["function balanceOf(address) view returns (uint256)"],
        ethers.provider
      );
      const usdcBalance = await usdcContract.balanceOf(address);
      usdcValue = parseFloat(ethers.formatUnits(usdcBalance, 6));
    } catch (e) {}
    
    const totalValueUSD = ethValue * 3500 + usdcValue;
    
    return {
      address,
      ethValue,
      usdcValue,
      totalValueUSD,
      backdoors: foundBackdoors,
      codeSize: code.length,
      isVulnerable: foundBackdoors.length > 0,
      isHighValue: totalValueUSD > 10000
    };
    
  } catch (error) {
    return null;
  }
}

/**
 * Main scanning function
 */
async function main() {
  console.log("\nüåç REALTIME CONTRACT VULNERABILITY SCANNER");
  console.log("==========================================");
  
  // Find real contracts
  const contracts = await findRealContracts();
  
  console.log(`\nüîç Scanning ${contracts.length} real contracts for vulnerabilities...`);
  console.log("‚îÄ".repeat(60));
  
  const results = [];
  let scanned = 0;
  
  for (const address of contracts) {
    const result = await quickVulnScan(address);
    scanned++;
    
    if (result) {
      results.push(result);
      
      // Log interesting contracts
      if (result.isVulnerable || result.isHighValue) {
        const status = result.isVulnerable ? "üö® VULNERABLE" : "üí∞ HIGH VALUE";
        console.log(`${status}: ${address}`);
        console.log(`   Value: $${result.totalValueUSD.toFixed(0)} (${result.ethValue.toFixed(2)} ETH + ${result.usdcValue.toFixed(0)} USDC)`);
        if (result.backdoors.length > 0) {
          console.log(`   Backdoors: ${result.backdoors.map(b => b.name).join(", ")}`);
        }
      }
    }
    
    // Progress update
    if (scanned % 20 === 0) {
      console.log(`Progress: ${scanned}/${contracts.length} (${((scanned/contracts.length)*100).toFixed(1)}%)`);
    }
  }
  
  // Analysis
  const vulnerable = results.filter(r => r.isVulnerable);
  const highValue = results.filter(r => r.isHighValue);
  const criticalTargets = results.filter(r => r.isVulnerable && r.isHighValue);
  
  console.log("\n\nüìä SCAN RESULTS");
  console.log("===============");
  console.log(`Total Scanned: ${results.length}`);
  console.log(`Vulnerable: ${vulnerable.length}`);
  console.log(`High Value: ${highValue.length}`);
  console.log(`Critical (Vulnerable + High Value): ${criticalTargets.length}`);
  
  if (criticalTargets.length > 0) {
    console.log("\nüéØ CRITICAL TARGETS:");
    console.log("===================");
    criticalTargets.sort((a, b) => b.totalValueUSD - a.totalValueUSD);
    
    criticalTargets.forEach((target, i) => {
      console.log(`\n${i + 1}. ${target.address}`);
      console.log(`   üí∞ Total Value: $${target.totalValueUSD.toFixed(0)}`);
      console.log(`   üíé ETH: ${target.ethValue.toFixed(3)}`);
      console.log(`   üíµ USDC: ${target.usdcValue.toFixed(0)}`);
      console.log(`   üîì Backdoors:`);
      target.backdoors.forEach(b => {
        console.log(`      ‚Ä¢ ${b.sig} - ${b.name}`);
      });
    });
  }
  
  if (vulnerable.length > 0) {
    console.log("\nüîì ALL VULNERABLE CONTRACTS:");
    console.log("============================");
    vulnerable.forEach((v, i) => {
      console.log(`${i + 1}. ${v.address} - $${v.totalValueUSD.toFixed(0)} - ${v.backdoors.length} backdoors`);
    });
  }
  
  console.log("\nüí° RECOMMENDATIONS:");
  console.log("===================");
  console.log(`‚Ä¢ ${criticalTargets.length} contracts need immediate attention`);
  console.log(`‚Ä¢ ${vulnerable.length} total vulnerable contracts found`);
  console.log("‚Ä¢ Run deep_backdoor_exploit.js on critical targets");
  console.log("‚Ä¢ Monitor these contracts for new deposits");
  console.log("‚Ä¢ Set up alerts for similar bytecode patterns");
  
  const totalAtRisk = vulnerable.reduce((sum, v) => sum + v.totalValueUSD, 0);
  console.log(`‚Ä¢ Total value at risk: $${totalAtRisk.toFixed(0)}`);
}

main()
  .then(() => {
    console.log("\n‚úÖ Scan complete!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
