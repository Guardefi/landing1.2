const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

async function main() {
  console.log("\nüîç TRACING STATE CHANGES - FORKED MAINNET");
  console.log("==========================================");
  console.log("Target:", VAULT_ADDRESS);
  
  const provider = ethers.provider;
  const [attacker] = await ethers.getSigners();
  
  // Get initial state snapshot
  console.log("\nüì∏ INITIAL STATE SNAPSHOT:");
  
  // Balance
  const balance = await provider.getBalance(VAULT_ADDRESS);
  console.log("Balance:", ethers.formatEther(balance), "ETH");
  
  // Code
  const code = await provider.getCode(VAULT_ADDRESS);
  console.log("Code size:", code.length / 2 - 1, "bytes");
  console.log("Code hash:", ethers.keccak256(code).slice(0, 10) + "...");
  
  // Storage slots (check first 20 slots)
  console.log("\nüì¶ STORAGE ANALYSIS:");
  const storageMap = new Map();
  
  for (let i = 0; i < 20; i++) {
    try {
      const value = await provider.getStorage(VAULT_ADDRESS, i);
      if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
        storageMap.set(i, value);
        console.log(`Slot ${i}: ${value}`);
        
        // Try to interpret common patterns
        if (value.length === 66) { // 32 bytes
          // Check if it's an address (20 bytes with padding)
          const possibleAddr = "0x" + value.slice(26);
          if (ethers.isAddress(possibleAddr)) {
            console.log(`  ‚Üí Possible address: ${possibleAddr}`);
            
            // Check if it's a contract
            const codeAtAddr = await provider.getCode(possibleAddr);
            if (codeAtAddr !== "0x") {
              console.log(`    ‚Üí Is contract!`);
            }
          }
          
          // Check if it's a small number
          const asNumber = BigInt(value);
          if (asNumber < 1000000n) {
            console.log(`  ‚Üí As number: ${asNumber}`);
          }
          
          // Check if it's a balance-sized number
          if (asNumber > ethers.parseEther("0.001") && asNumber < ethers.parseEther("1000000")) {
            console.log(`  ‚Üí As ETH: ${ethers.formatEther(asNumber)} ETH`);
          }
        }
      }
    } catch (e) {
      console.log(`Slot ${i}: Error reading - ${e.message}`);
    }
  }
  
  // Try to find owner slot
  console.log("\nüîç SEARCHING FOR OWNER SLOT:");
  const ownerSelectors = [
    "0x8da5cb5b", // owner()
    "0x893d20e8", // getOwner()
    "0x0c340a24", // governor()
  ];
  
  for (const selector of ownerSelectors) {
    try {
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: selector
      });
      
      if (result && result !== "0x") {
        console.log(`Found via ${selector}:`, result);
        const decoded = ethers.AbiCoder.defaultAbiCoder().decode(["address"], result);
        console.log(`Decoded owner: ${decoded[0]}`);
      }
    } catch (e) {
      // Silent fail
    }
  }
  
  // Test transaction simulation
  console.log("\nüß™ SIMULATING STATE CHANGES:");
  
  // Simulate a withdraw call
  try {
    const withdrawSelector = "0x3ccfd60b"; // withdraw()
    console.log("\nSimulating withdraw()...");
    
    const result = await attacker.call({
      to: VAULT_ADDRESS,
      data: withdrawSelector,
      gasLimit: 1000000
    });
    
    console.log("Static call result:", result);
  } catch (e) {
    console.log("Withdraw simulation error:", e.message);
  }
  
  // Check for common vulnerability patterns
  console.log("\nüö® VULNERABILITY PATTERN CHECK:");
  
  // Check for delegatecall
  if (code.includes("f4")) {
    console.log("‚ö†Ô∏è  DELEGATECALL opcode found!");
  }
  
  // Check for selfdestruct
  if (code.includes("ff")) {
    console.log("‚ö†Ô∏è  SELFDESTRUCT opcode found!");
  }
  
  // Check for create2
  if (code.includes("f5")) {
    console.log("‚ö†Ô∏è  CREATE2 opcode found!");
  }
  
  // Check storage patterns
  if (storageMap.size === 0) {
    console.log("üìå No storage values found - might be using packed storage");
  } else {
    console.log(`üìå Found ${storageMap.size} non-zero storage slots`);
  }
  
  console.log("\n‚úÖ State analysis complete!");
}

main().catch((error) => {
  console.error("\nüí• Script failed:", error);
  process.exit(1);
});
