const { ethers } = require("hardhat");

/**
 * @title Investigate WETH Success
 * @notice Debug why the delegatecall exploit showed successful
 * @dev This needs investigation
 */

async function investigateWETH() {
  console.log("\n🔍 INVESTIGATING WETH 'SUCCESSFUL' EXPLOIT");
  console.log("=========================================");
  
  const WETH = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
  const [attacker] = await ethers.getSigners();
  
  // Check initial balances
  const attackerBalanceBefore = await ethers.provider.getBalance(attacker.address);
  const wethBalanceBefore = await ethers.provider.getBalance(WETH);
  
  console.log("\n📊 Initial State:");
  console.log(`Attacker ETH: ${ethers.formatEther(attackerBalanceBefore)}`);
  console.log(`WETH Contract ETH: ${ethers.formatEther(wethBalanceBefore)}`);
  
  // Check if WETH has execute function
  console.log("\n🔍 Checking for execute function (0x78e111f6)...");
  const code = await ethers.provider.getCode(WETH);
  const hasExecute = code.includes("78e111f6");
  console.log(`Execute function present: ${hasExecute}`);
  
  // Try the delegatecall exploit that showed "successful"
  console.log("\n💣 Attempting delegatecall exploit...");
  
  try {
    // Build the same payload from exploit_weth.js
    const wethABI = ["function withdraw(uint256 wad)"];
    const wethInterface = new ethers.Interface(wethABI);
    const exploitData = wethInterface.encodeFunctionData("withdraw", [wethBalanceBefore]);
    
    const tx = await attacker.sendTransaction({
      to: WETH,
      data: "0x78e111f6" + 
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [WETH, exploitData]
        ).slice(2),
      gasLimit: 1000000
    });
    
    console.log(`Transaction sent: ${tx.hash}`);
    const receipt = await tx.wait();
    console.log(`Gas used: ${receipt.gasUsed.toString()}`);
    
    // Check balances after
    const attackerBalanceAfter = await ethers.provider.getBalance(attacker.address);
    const wethBalanceAfter = await ethers.provider.getBalance(WETH);
    
    console.log("\n📊 After Transaction:");
    console.log(`Attacker ETH: ${ethers.formatEther(attackerBalanceAfter)}`);
    console.log(`WETH Contract ETH: ${ethers.formatEther(wethBalanceAfter)}`);
    
    const attackerGained = attackerBalanceAfter - attackerBalanceBefore;
    const wethLost = wethBalanceBefore - wethBalanceAfter;
    
    console.log("\n💰 Balance Changes:");
    console.log(`Attacker gained: ${ethers.formatEther(attackerGained)} ETH`);
    console.log(`WETH lost: ${ethers.formatEther(wethLost)} ETH`);
    
    if (wethLost > 0) {
      console.log("\n🚨 CRITICAL: WETH ACTUALLY LOST FUNDS!");
      console.log("This should not be possible!");
    } else {
      console.log("\n✅ Transaction succeeded but no funds moved");
      console.log("The 'success' was misleading - no actual exploit");
    }
    
  } catch (error) {
    console.log("\n❌ Transaction failed:");
    console.log(error.message);
    
    // Decode the error
    if (error.data) {
      console.log("\nError data:", error.data);
    }
  }
  
  // Additional checks
  console.log("\n\n🔬 DETAILED ANALYSIS:");
  console.log("====================");
  
  // Check WETH bytecode for execute selector
  const executePos = code.indexOf("78e111f6");
  if (executePos > -1) {
    console.log(`⚠️  Function selector 0x78e111f6 found at position ${executePos}`);
    console.log("This could be:");
    console.log("• A different function with same selector (collision)");
    console.log("• A legitimate function that happens to match");
  } else {
    console.log("✅ No execute function found in bytecode");
  }
  
  // Try direct withdraw to verify WETH works normally
  console.log("\n🧪 Testing legitimate WETH functionality...");
  
  try {
    // First deposit some ETH to get WETH
    const wethABI = [
      "function deposit() payable",
      "function withdraw(uint256)",
      "function balanceOf(address) view returns (uint256)"
    ];
    const weth = new ethers.Contract(WETH, wethABI, attacker);
    
    // Deposit 0.1 ETH
    const depositTx = await weth.deposit({ value: ethers.parseEther("0.1") });
    await depositTx.wait();
    console.log("✅ Deposited 0.1 ETH to WETH");
    
    // Check WETH balance
    const wethTokenBalance = await weth.balanceOf(attacker.address);
    console.log(`WETH token balance: ${ethers.formatEther(wethTokenBalance)}`);
    
    // Withdraw it back
    const withdrawTx = await weth.withdraw(wethTokenBalance);
    await withdrawTx.wait();
    console.log("✅ Withdrew WETH back to ETH");
    
    console.log("\n✅ WETH is functioning normally");
    console.log("The contract is secure and working as intended");
    
  } catch (e) {
    console.log("Error testing WETH:", e.message);
  }
}

// Execute investigation
investigateWETH()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n💥 Error:", error);
    process.exit(1);
  });
