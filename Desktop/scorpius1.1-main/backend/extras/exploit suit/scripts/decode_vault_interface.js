const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Decode Vault Interface
 * @notice Extract and test all function selectors systematically
 * @dev Focus on finding the legitimate USDC withdrawal method
 */
async function main() {
  console.log("\n🔓 DECODING VAULT INTERFACE");
  console.log("=====================================");
  
  const [user] = await ethers.getSigners();
  const USDC = await ethers.getContractAt("contracts/IERC20.sol:IERC20", USDC_ADDRESS);
  
  // Get vault bytecode and extract selectors
  const vaultCode = await ethers.provider.getCode(VAULT_ADDRESS);
  const selectors = extractAllSelectors(vaultCode);
  
  console.log(`\n📊 Found ${selectors.length} unique function selectors\n`);
  
  // Get current balances
  const vaultUSDC = await USDC.balanceOf(VAULT_ADDRESS);
  const userUSDC = await USDC.balanceOf(user.address);
  console.log("Vault USDC:", ethers.formatUnits(vaultUSDC, 6));
  console.log("User USDC:", ethers.formatUnits(userUSDC, 6));
  
  // Test each selector systematically
  console.log("\n🧪 Testing selectors for USDC withdrawal capability:\n");
  
  const results = [];
  
  for (let i = 0; i < selectors.length; i++) {
    const selector = selectors[i];
    
    process.stdout.write(`Testing ${i+1}/${selectors.length}: ${selector} `);
    
    // Test as view function first
    const viewResult = await testAsView(user, VAULT_ADDRESS, selector);
    if (viewResult) {
      process.stdout.write(`[VIEW: ${viewResult}] `);
      results.push({ selector, type: "view", result: viewResult });
    }
    
    // Test with different parameter patterns
    const patterns = [
      { name: "no-params", data: selector },
      { name: "address", data: selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [USDC_ADDRESS]).slice(2) },
      { name: "uint256", data: selector + ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [ethers.parseUnits("100", 6)]).slice(2) },
      { name: "addr+uint", data: selector + ethers.AbiCoder.defaultAbiCoder().encode(["address", "uint256"], [USDC_ADDRESS, ethers.parseUnits("100", 6)]).slice(2) },
      { name: "addr+addr", data: selector + ethers.AbiCoder.defaultAbiCoder().encode(["address", "address"], [user.address, USDC_ADDRESS]).slice(2) },
      { name: "uint+addr", data: selector + ethers.AbiCoder.defaultAbiCoder().encode(["uint256", "address"], [ethers.parseUnits("100", 6), user.address]).slice(2) }
    ];
    
    let success = false;
    for (const pattern of patterns) {
      try {
        const tx = await user.sendTransaction({
          to: VAULT_ADDRESS,
          data: pattern.data,
          gasLimit: 300000
        });
        await tx.wait();
        
        // Check if USDC moved
        const newVaultUSDC = await USDC.balanceOf(VAULT_ADDRESS);
        const newUserUSDC = await USDC.balanceOf(user.address);
        
        if (newVaultUSDC < vaultUSDC || newUserUSDC > userUSDC) {
          process.stdout.write(`✅ [${pattern.name} - USDC MOVED!] `);
          results.push({ 
            selector, 
            type: "withdraw", 
            pattern: pattern.name,
            extracted: ethers.formatUnits(vaultUSDC - newVaultUSDC, 6) 
          });
          success = true;
          break;
        } else {
          process.stdout.write(`[${pattern.name}:ok] `);
        }
      } catch (e) {
        // Silent fail, try next pattern
      }
    }
    
    if (!success && !viewResult) {
      process.stdout.write("❌");
    }
    
    console.log(); // New line
  }
  
  // Summary of findings
  console.log("\n📋 SUMMARY OF FINDINGS:");
  console.log("=====================================");
  
  const withdrawalFunctions = results.filter(r => r.type === "withdraw");
  const viewFunctions = results.filter(r => r.type === "view");
  
  if (withdrawalFunctions.length > 0) {
    console.log("\n🎯 WITHDRAWAL FUNCTIONS FOUND:");
    withdrawalFunctions.forEach(f => {
      console.log(`  ${f.selector} - Pattern: ${f.pattern} - Extracted: ${f.extracted} USDC`);
    });
  } else {
    console.log("\n❌ No direct USDC withdrawal functions found");
  }
  
  console.log(`\n📖 View functions: ${viewFunctions.length}`);
  viewFunctions.forEach(f => {
    console.log(`  ${f.selector}: ${f.result}`);
  });
  
  // Additional analysis
  console.log("\n🔍 Additional Analysis:");
  
  // Check if vault has any approval to spend its own USDC
  const selfAllowance = await USDC.allowance(VAULT_ADDRESS, VAULT_ADDRESS);
  console.log("Vault self-allowance:", ethers.formatUnits(selfAllowance, 6), "USDC");
  
  // Check common DeFi patterns
  await checkCommonPatterns(user, VAULT_ADDRESS);
}

function extractAllSelectors(bytecode) {
  const selectors = new Set();
  
  // Multiple patterns to catch all selectors
  const patterns = [
    /63([0-9a-f]{8})/g,        // PUSH4 selector
    /8063([0-9a-f]{8})/g,      // DUP1 PUSH4
    /6003356110([0-9a-f]{4})/g, // Common pattern
    /7c01([0-9a-f]{8})/g       // Another pattern
  ];
  
  patterns.forEach(pattern => {
    let match;
    while ((match = pattern.exec(bytecode)) !== null) {
      if (match[1] && match[1].length === 8) {
        selectors.add("0x" + match[1]);
      }
    }
  });
  
  // Look for selector jumptable pattern
  const jumptablePattern = /5b60e01c([0-9a-f]{2,}?)(?:5b|$)/g;
  let match;
  while ((match = jumptablePattern.exec(bytecode)) !== null) {
    const table = match[1];
    for (let i = 0; i < table.length; i += 8) {
      if (i + 8 <= table.length) {
        selectors.add("0x" + table.substr(i, 8));
      }
    }
  }
  
  return Array.from(selectors);
}

async function testAsView(user, target, selector) {
  try {
    const result = await user.call({
      to: target,
      data: selector
    });
    
    if (result && result !== "0x" && result.length >= 66) {
      // Try to decode common return types
      if (result.length === 66) {
        const value = BigInt(result);
        
        // Check if it's likely an address
        if (result.slice(2, 26) === "000000000000000000000000") {
          return "0x" + result.slice(26);
        }
        
        // Check if it's a reasonable number
        if (value > 0n && value < 1000000000000000000000000n) {
          if (value < 1000000000000n) {
            return ethers.formatUnits(value, 6) + " (6 dec)";
          } else {
            return ethers.formatUnits(value, 18) + " (18 dec)";
          }
        }
        
        return result.slice(0, 10) + "...";
      }
      
      return result.slice(0, 10) + "...";
    }
  } catch (e) {
    // Silent fail
  }
  
  return null;
}

async function checkCommonPatterns(user, vault) {
  // Check if it's a proxy with specific upgrade pattern
  const EIP1967_IMPLEMENTATION_SLOT = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
  const implSlotValue = await ethers.provider.getStorage(vault, EIP1967_IMPLEMENTATION_SLOT);
  
  if (implSlotValue !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
    console.log("EIP-1967 Implementation:", "0x" + implSlotValue.slice(26));
  }
  
  // Check OpenZeppelin proxy admin slot
  const EIP1967_ADMIN_SLOT = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";
  const adminSlotValue = await ethers.provider.getStorage(vault, EIP1967_ADMIN_SLOT);
  
  if (adminSlotValue !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
    console.log("EIP-1967 Admin:", "0x" + adminSlotValue.slice(26));
  }
  
  // Check beacon proxy pattern
  const EIP1967_BEACON_SLOT = "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50";
  const beaconSlotValue = await ethers.provider.getStorage(vault, EIP1967_BEACON_SLOT);
  
  if (beaconSlotValue !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
    console.log("EIP-1967 Beacon:", "0x" + beaconSlotValue.slice(26));
  }
  
  // Check if paused
  const pausedSlot = await ethers.provider.getStorage(vault, 0);
  if (pausedSlot !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
    console.log("Slot 0 (potential paused state):", pausedSlot);
  }
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
