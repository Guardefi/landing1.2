const { ethers } = require("hardhat");
const fs = require("fs");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const IMPLEMENTATION_ADDRESS = "0x11fb858ee4bf594857483bcf86eb825aef1cbf91";

/**
 * @title Vault Reverse Engineering
 * @notice Deep analysis to understand the legitimate withdrawal mechanism
 * @dev Disassemble bytecode and find intended functions
 */
async function main() {
  console.log("\n🔬 VAULT REVERSE ENGINEERING");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Get both bytecodes
  const vaultCode = await ethers.provider.getCode(VAULT_ADDRESS);
  const implCode = await ethers.provider.getCode(IMPLEMENTATION_ADDRESS);
  
  console.log("\n📊 Contract Analysis:");
  console.log("Vault code size:", vaultCode.length / 2 - 1, "bytes");
  console.log("Implementation code size:", implCode.length / 2 - 1, "bytes");
  
  // Extract all function selectors from vault bytecode
  console.log("\n🔍 Extracting function selectors from vault...");
  const vaultSelectors = extractSelectors(vaultCode);
  console.log("Found", vaultSelectors.size, "potential selectors in vault");
  
  // Extract all function selectors from implementation
  console.log("\n🔍 Extracting function selectors from implementation...");
  const implSelectors = extractSelectors(implCode);
  console.log("Found", implSelectors.size, "potential selectors in implementation");
  
  // Common withdrawal/claim function signatures
  const knownSignatures = {
    "0x3ccfd60b": "withdraw()",
    "0x2e1a7d4d": "withdraw(uint256)",
    "0xf3fef3a3": "withdraw(address,uint256)",
    "0x69328dec": "harvest(address,uint256,uint256,uint256,bool)",
    "0xdb006a75": "redeem(uint256)",
    "0x853828b6": "withdrawAll()",
    "0x01681a62": "emergencyWithdraw(address)",
    "0x4e71d92d": "claim()",
    "0xb69ef8a8": "balance()",
    "0x70a08231": "balanceOf(address)",
    "0xdd62ed3e": "allowance(address,address)",
    "0xa9059cbb": "transfer(address,uint256)",
    "0x23b872dd": "transferFrom(address,address,uint256)",
    "0x095ea7b3": "approve(address,uint256)",
    "0x8da5cb5b": "owner()",
    "0x715018a6": "renounceOwnership()",
    "0xf2fde38b": "transferOwnership(address)",
    "0x5c975abb": "paused()",
    "0x8456cb59": "pause()",
    "0x3f4ba83a": "unpause()",
    "0x60c7d295": "getImplementation()",
    "0x3659cfe6": "upgradeTo(address)",
    "0x4f1ef286": "upgradeToAndCall(address,bytes)",
    "0x8129fc1c": "initialize()"
  };
  
  // Match found selectors with known signatures
  console.log("\n✅ Matching known signatures:");
  for (const [selector, name] of Object.entries(knownSignatures)) {
    if (vaultSelectors.has(selector) || implSelectors.has(selector)) {
      console.log(`${selector}: ${name} - Found in ${vaultSelectors.has(selector) ? 'vault' : 'implementation'}`);
    }
  }
  
  // Test each selector to understand behavior
  console.log("\n🧪 Testing withdrawal-related functions:");
  
  const withdrawalSelectors = [
    "0x3ccfd60b", "0x2e1a7d4d", "0xf3fef3a3", "0x69328dec",
    "0xdb006a75", "0x853828b6", "0x01681a62", "0x4e71d92d"
  ];
  
  for (const selector of withdrawalSelectors) {
    if (!vaultSelectors.has(selector) && !implSelectors.has(selector)) continue;
    
    console.log(`\n📌 Testing ${selector} (${knownSignatures[selector] || 'unknown'}):`);
    
    // Test with different parameter combinations
    await testSelector(attacker, VAULT_ADDRESS, selector);
  }
  
  // Analyze storage layout
  console.log("\n📦 Analyzing storage layout:");
  await analyzeStorage(VAULT_ADDRESS);
  
  // Look for owner/admin patterns
  console.log("\n👤 Searching for access control:");
  await findAccessControl(attacker, VAULT_ADDRESS);
  
  // Generate disassembly report
  console.log("\n📄 Generating disassembly report...");
  generateDisassemblyReport(vaultCode, implCode);
}

function extractSelectors(bytecode) {
  const selectors = new Set();
  
  // Pattern 1: PUSH4 followed by selector (63 xx xx xx xx)
  const push4Pattern = /63([0-9a-f]{8})/g;
  let match;
  while ((match = push4Pattern.exec(bytecode)) !== null) {
    selectors.add("0x" + match[1]);
  }
  
  // Pattern 2: DUP1 PUSH4 (80 63)
  const dup1Push4Pattern = /8063([0-9a-f]{8})/g;
  while ((match = dup1Push4Pattern.exec(bytecode)) !== null) {
    selectors.add("0x" + match[1]);
  }
  
  // Pattern 3: Look for selector comparisons (EQ after PUSH4)
  const eqPattern = /63([0-9a-f]{8})14/g;
  while ((match = eqPattern.exec(bytecode)) !== null) {
    selectors.add("0x" + match[1]);
  }
  
  return selectors;
}

async function testSelector(signer, target, selector) {
  const results = [];
  
  // Test 1: No parameters
  try {
    const tx = await signer.sendTransaction({
      to: target,
      data: selector,
      gasLimit: 100000
    });
    await tx.wait();
    results.push("✅ No params - Success");
  } catch (e) {
    if (e.message.includes("revert")) {
      results.push("❌ No params - Reverted: " + extractRevertReason(e));
    }
  }
  
  // Test 2: uint256 parameter (common for withdraw)
  try {
    const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
      ["uint256"],
      [ethers.parseEther("1")]
    ).slice(2);
    
    const tx = await signer.sendTransaction({
      to: target,
      data: data,
      gasLimit: 100000
    });
    await tx.wait();
    results.push("✅ uint256 param - Success");
  } catch (e) {
    if (e.message.includes("revert")) {
      results.push("❌ uint256 param - Reverted: " + extractRevertReason(e));
    }
  }
  
  // Test 3: address parameter
  try {
    const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
      ["address"],
      [signer.address]
    ).slice(2);
    
    const tx = await signer.sendTransaction({
      to: target,
      data: data,
      gasLimit: 100000
    });
    await tx.wait();
    results.push("✅ address param - Success");
  } catch (e) {
    if (e.message.includes("revert")) {
      results.push("❌ address param - Reverted: " + extractRevertReason(e));
    }
  }
  
  // Test 4: Read function (static call)
  try {
    const result = await signer.call({
      to: target,
      data: selector
    });
    if (result !== "0x") {
      results.push("📖 Read function - Returns: " + result.slice(0, 66));
    }
  } catch (e) {
    // Silent
  }
  
  results.forEach(r => console.log("  " + r));
}

async function analyzeStorage(target) {
  const provider = ethers.provider;
  
  // Check first 20 storage slots
  for (let i = 0; i < 20; i++) {
    const value = await provider.getStorage(target, i);
    if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
      console.log(`Slot ${i}: ${value}`);
      
      // Try to interpret as address
      if (value.startsWith("0x000000000000000000000000")) {
        const addr = "0x" + value.slice(26);
        console.log(`  → Possible address: ${addr}`);
      }
      
      // Try to interpret as number
      try {
        const num = BigInt(value);
        if (num < 10000000n) {
          console.log(`  → As number: ${num}`);
        }
      } catch (e) {}
    }
  }
  
  // Check mapping slots for common patterns
  const testAddresses = [
    "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266", // attacker
    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
    "0x0000000000000000000000000000000000000000"  // zero address
  ];
  
  console.log("\nChecking potential balance mappings:");
  for (let slot = 0; slot < 5; slot++) {
    for (const addr of testAddresses) {
      const balanceSlot = ethers.solidityPackedKeccak256(
        ["address", "uint256"],
        [addr, slot]
      );
      const value = await provider.getStorage(target, balanceSlot);
      if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
        console.log(`Mapping[${addr}] at slot ${slot}: ${value}`);
      }
    }
  }
}

async function findAccessControl(signer, target) {
  const accessFunctions = [
    { selector: "0x8da5cb5b", name: "owner()" },
    { selector: "0xf851a440", name: "admin()" },
    { selector: "0x91d14854", name: "hasRole(bytes32,address)" },
    { selector: "0x248a9ca3", name: "getRoleAdmin(bytes32)" },
    { selector: "0xa217fddf", name: "DEFAULT_ADMIN_ROLE()" },
    { selector: "0x5c975abb", name: "paused()" }
  ];
  
  for (const func of accessFunctions) {
    try {
      const result = await signer.call({
        to: target,
        data: func.selector
      });
      
      if (result && result !== "0x") {
        console.log(`${func.name}: ${result}`);
        
        // If it's an address
        if (result.length === 66) {
          const addr = "0x" + result.slice(26);
          console.log(`  → Address: ${addr}`);
        }
      }
    } catch (e) {
      // Silent
    }
  }
}

function extractRevertReason(error) {
  const match = error.message.match(/reverted with reason string '(.+?)'/);
  if (match) return match[1];
  
  if (error.message.includes("UNPREDICTABLE_GAS_LIMIT")) return "Gas estimation failed";
  if (error.message.includes("execution reverted")) return "Generic revert";
  
  return "Unknown";
}

function generateDisassemblyReport(vaultCode, implCode) {
  const report = {
    timestamp: new Date().toISOString(),
    vault: {
      address: VAULT_ADDRESS,
      codeSize: vaultCode.length / 2 - 1,
      codeHash: ethers.keccak256(vaultCode),
      selectors: Array.from(extractSelectors(vaultCode))
    },
    implementation: {
      address: IMPLEMENTATION_ADDRESS,
      codeSize: implCode.length / 2 - 1,
      codeHash: ethers.keccak256(implCode),
      selectors: Array.from(extractSelectors(implCode))
    }
  };
  
  fs.writeFileSync(
    "vault_disassembly_report.json",
    JSON.stringify(report, null, 2)
  );
  
  console.log("Report saved to vault_disassembly_report.json");
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
