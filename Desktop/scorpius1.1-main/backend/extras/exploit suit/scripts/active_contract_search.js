const { ethers } = require("hardhat");

/**
 * @title Active Contract Search
 * @notice Actively searches for vulnerable contracts
 * @dev Real-time scanning and pattern matching
 */

// Target signatures we're hunting for
const TARGET_SIGS = [
  "78e111f6", // execute(address,bytes)
  "61461954", // execute(address,uint256,bytes)
  "b61d27f6", // execute(address,uint256,bytes)
  "9e8c708e", // adminCall(address,bytes)
  "24a084df", // adminExecute(address,bytes)
  "1cff79cd", // execute(address,bytes) variant
];

/**
 * Scan recent blocks for vulnerable contracts
 */
async function scanRecentBlocks(blocksToScan = 100) {
  console.log(`\nüîç Scanning last ${blocksToScan} blocks for vulnerable contracts...`);
  
  const currentBlock = await ethers.provider.getBlockNumber();
  const startBlock = currentBlock - blocksToScan;
  
  const foundContracts = [];
  
  for (let i = startBlock; i <= currentBlock; i++) {
    if (i % 10 === 0) {
      console.log(`Scanning block ${i}...`);
    }
    
    const block = await ethers.provider.getBlock(i);
    
    if (block && block.transactions) {
      for (const txHash of block.transactions) {
        const tx = await ethers.provider.getTransaction(txHash);
        
        // Check if it's a contract creation
        if (!tx.to && tx.data && tx.data.length > 1000) {
          // Check for our target signatures
          for (const sig of TARGET_SIGS) {
            if (tx.data.includes(sig)) {
              const receipt = await ethers.provider.getTransactionReceipt(txHash);
              console.log(`\n‚úÖ FOUND VULNERABLE CONTRACT!`);
              console.log(`   Block: ${i}`);
              console.log(`   Address: ${receipt.contractAddress}`);
              console.log(`   Signature: 0x${sig}`);
              console.log(`   Creator: ${tx.from}`);
              
              foundContracts.push({
                address: receipt.contractAddress,
                signature: sig,
                block: i,
                creator: tx.from
              });
            }
          }
        }
      }
    }
  }
  
  return foundContracts;
}

/**
 * Get high-value contracts from known addresses
 */
async function getHighValueTargets() {
  console.log("\nüí∞ Checking known high-value contract patterns...");
  
  // Common patterns for vault/treasury contracts
  const patterns = [
    "Vault",
    "Treasury", 
    "Pool",
    "Reserve",
    "Staking"
  ];
  
  // These would come from blockchain indexers
  const knownTargets = [
    {
      address: "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C",
      name: "Unverified Vault",
      value: "$8.3M USDC"
    }
  ];
  
  console.log("\nKnown high-value targets:");
  knownTargets.forEach(t => {
    console.log(`   ${t.address} - ${t.name} (${t.value})`);
  });
  
  return knownTargets;
}

/**
 * Quick scan a specific address
 */
async function quickScan(address) {
  console.log(`\n‚ö° Quick scanning ${address}...`);
  
  const code = await ethers.provider.getCode(address);
  const balance = await ethers.provider.getBalance(address);
  
  console.log(`   Code size: ${code.length} bytes`);
  console.log(`   ETH balance: ${ethers.formatEther(balance)}`);
  
  // Check for signatures
  const found = [];
  for (const sig of TARGET_SIGS) {
    if (code.includes(sig)) {
      found.push(sig);
    }
  }
  
  if (found.length > 0) {
    console.log(`   ‚úÖ VULNERABLE! Found signatures:`);
    found.forEach(s => console.log(`      0x${s}`));
    return true;
  } else {
    console.log(`   ‚ùå No vulnerable signatures found`);
    return false;
  }
}

/**
 * Main search function
 */
async function searchForContracts() {
  console.log("\nüéØ ACTIVE CONTRACT SEARCH");
  console.log("========================");
  
  console.log("\nüìç WHERE TO FIND CONTRACTS:");
  console.log("============================");
  
  console.log("\n1Ô∏è‚É£ ETHERSCAN.IO:");
  console.log("   ‚Ä¢ Go to: https://etherscan.io/accounts");
  console.log("   ‚Ä¢ Sort by: Balance (descending)");
  console.log("   ‚Ä¢ Filter: Contract accounts only");
  console.log("   ‚Ä¢ Look for: Unverified contracts");
  console.log("   ‚Ä¢ Check names: Vault, Treasury, Pool, etc.");
  
  console.log("\n2Ô∏è‚É£ DUNE ANALYTICS:");
  console.log("   ‚Ä¢ Search query: 'unverified contracts high balance'");
  console.log("   ‚Ä¢ Filter: Created in last 6 months");
  console.log("   ‚Ä¢ Sort: By USD value held");
  
  console.log("\n3Ô∏è‚É£ DEFI PULSE / DEFI LLAMA:");
  console.log("   ‚Ä¢ Check new protocols");
  console.log("   ‚Ä¢ Look for unaudited projects");
  console.log("   ‚Ä¢ Focus on: Yield farms, vaults, staking");
  
  console.log("\n4Ô∏è‚É£ TWITTER / DISCORD:");
  console.log("   ‚Ä¢ Monitor new project launches");
  console.log("   ‚Ä¢ Join DeFi communities");
  console.log("   ‚Ä¢ Watch for 'stealth launches'");
  
  console.log("\n5Ô∏è‚É£ BLOCKCHAIN EXPLORERS:");
  console.log("   ‚Ä¢ BscScan for BSC contracts");
  console.log("   ‚Ä¢ PolygonScan for Polygon");
  console.log("   ‚Ä¢ Arbiscan for Arbitrum");
  
  // Get known targets
  const targets = await getHighValueTargets();
  
  // Example: scan a specific contract
  console.log("\nüìã EXAMPLE SCAN:");
  await quickScan("0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C");
  
  console.log("\nüîß HOW TO USE FOUND CONTRACTS:");
  console.log("================================");
  console.log("1. Copy the contract address");
  console.log("2. Run: npx hardhat run scripts/quick_exploit.js --network localhost [ADDRESS]");
  console.log("3. Or use: node scripts/universal_backdoor_scanner.js [ADDRESS]");
  
  console.log("\nüí° PRO TIPS:");
  console.log("‚Ä¢ Focus on contracts with >$100k value");
  console.log("‚Ä¢ Unverified = more likely vulnerable");
  console.log("‚Ä¢ New contracts = less audited");
  console.log("‚Ä¢ Check transaction history for admin calls");
  
  // Uncomment to scan recent blocks
  // const recent = await scanRecentBlocks(10);
  // console.log(`\nFound ${recent.length} contracts in recent blocks`);
}

// Run the search
searchForContracts()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
