// Complete function signature dumping implementation
const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

// Function to extract 4-byte selectors from bytecode
function extractSelectors(bytecode) {
  const selectors = new Set();
  
  // Remove 0x prefix
  const code = bytecode.slice(2);
  
  // Look for PUSH4 instructions (63) followed by 4 bytes
  for (let i = 0; i < code.length - 10; i += 2) {
    if (code.substring(i, i + 2) === '63') {
      const selector = '0x' + code.substring(i + 2, i + 10);
      // Validate it looks like a selector (not 0x00000000 or 0xffffffff)
      if (selector !== '0x00000000' && selector !== '0xffffffff') {
        selectors.add(selector);
      }
    }
  }
  
  // Also look for common patterns in dispatcher
  // DUP1 PUSH4 selector EQ
  const pattern = /80635b34b966|806361461954|80633ccfd60b|8063db006a75/g;
  let match;
  while ((match = pattern.exec(code)) !== null) {
    const selector = '0x' + match[0].substring(4);
    selectors.add(selector);
  }
  
  return Array.from(selectors);
}

// Database of known function signatures
const KNOWN_SIGS = {
  "0x3ccfd60b": "withdraw()",
  "0xdb006a75": "emergencyWithdraw(uint256)",
  "0x2e1a7d4d": "withdraw(uint256)",
  "0x8da5cb5b": "owner()",
  "0x715018a6": "renounceOwnership()",
  "0xf2fde38b": "transferOwnership(address)",
  "0x5b34b966": "delegatecall(address,bytes)",
  "0x61461954": "execute(address,uint256,bytes)",
  "0x70a08231": "balanceOf(address)",
  "0x18160ddd": "totalSupply()",
  "0xdd62ed3e": "allowance(address,address)",
  "0x095ea7b3": "approve(address,uint256)",
  "0xa9059cbb": "transfer(address,uint256)",
  "0x23b872dd": "transferFrom(address,address,uint256)",
  "0x06fdde03": "name()",
  "0x95d89b41": "symbol()",
  "0x313ce567": "decimals()",
  "0x5c975abb": "paused()",
  "0x8456cb59": "pause()",
  "0x3f4ba83a": "unpause()"
};

async function main() {
  console.log("\n DUMPING FUNCTION SIGNATURES");
  console.log("==============================");
  console.log("Target:", VAULT_ADDRESS);
  
  const provider = ethers.provider;
  const [attacker] = await ethers.getSigners();
  
  // Get contract bytecode
  console.log("\n Fetching contract bytecode...");
  const bytecode = await provider.getCode(VAULT_ADDRESS);
  console.log(`Bytecode size: ${(bytecode.length - 2) / 2} bytes`);
  
  // Extract selectors
  console.log("\n Extracting function selectors...");
  const selectors = extractSelectors(bytecode);
  console.log(`Found ${selectors.length} potential selectors`);
  
  // Test each selector
  console.log("\n TESTING SELECTORS:");
  const workingSelectors = [];
  const unknownSelectors = [];
  
  for (const selector of selectors) {
    try {
      // Try to call with the selector
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 100000
      });
      
      const knownSig = KNOWN_SIGS[selector];
      if (knownSig) {
        console.log(` ${selector} → ${knownSig}`);
        workingSelectors.push({ selector, signature: knownSig, known: true });
      } else {
        console.log(` ${selector} → Unknown function (works)`);
        unknownSelectors.push(selector);
        workingSelectors.push({ selector, signature: "unknown", known: false });
      }
      
      // If it returns data, show preview
      if (result && result !== "0x" && result.length > 2) {
        console.log(`   Returns: ${result.slice(0, 66)}...`);
      }
    } catch (e) {
      // Function reverts or doesn't exist
      if (KNOWN_SIGS[selector]) {
        console.log(` ${selector} → ${KNOWN_SIGS[selector]} (reverts)`);
      }
    }
  }
  
  // Try common selectors not found in bytecode
  console.log("\n TESTING ADDITIONAL COMMON SELECTORS:");
  const additionalSelectors = Object.keys(KNOWN_SIGS).filter(s => !selectors.includes(s));
  
  for (const selector of additionalSelectors) {
    try {
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: selector,
        gasLimit: 100000
      });
      
      if (result !== "0x" || result === "0x") { // Function exists
        console.log(` ${selector} → ${KNOWN_SIGS[selector]} (hidden)`);
        workingSelectors.push({ selector, signature: KNOWN_SIGS[selector], known: true });
      }
    } catch (e) {
      // Silent fail
    }
  }
  
  // Generate report
  console.log("\n SUMMARY REPORT:");
  console.log(`Total selectors found: ${selectors.length}`);
  console.log(`Working functions: ${workingSelectors.length}`);
  console.log(`Unknown functions: ${unknownSelectors.length}`);
  
  console.log("\n CONFIRMED FUNCTIONS:");
  workingSelectors.forEach(f => {
    console.log(`  ${f.selector} → ${f.signature}`);
  });
  
  if (unknownSelectors.length > 0) {
    console.log("\n UNKNOWN WORKING SELECTORS:");
    console.log("These selectors work but signature is unknown:");
    unknownSelectors.forEach(s => {
      console.log(`  ${s}`);
    });
    
    console.log("\n TIP: Use cast sig-event or 4byte.directory to lookup unknown selectors");
  }
  
  // Check for patterns
  console.log("\n VULNERABILITY INDICATORS:");
  
  const dangerousSelectors = [
    { sel: "0x5b34b966", name: "delegatecall", risk: "HIGH" },
    { sel: "0x61461954", name: "execute", risk: "HIGH" },
    { sel: "0x9623609d", name: "upgradeToAndCall", risk: "HIGH" },
    { sel: "0x3ccfd60b", name: "withdraw", risk: "MEDIUM" },
    { sel: "0x715018a6", name: "renounceOwnership", risk: "MEDIUM" }
  ];
  
  dangerousSelectors.forEach(d => {
    if (workingSelectors.some(w => w.selector === d.sel)) {
      console.log(`  ${d.risk}: ${d.name} function found!`);
    }
  });
  
  // Export for other scripts
  console.log("\n EXPORT DATA:");
  const exportData = {
    target: VAULT_ADDRESS,
    bytecodeSize: (bytecode.length - 2) / 2,
    selectors: workingSelectors.map(w => w.selector),
    signatures: Object.fromEntries(workingSelectors.map(w => [w.selector, w.signature]))
  };
  
  console.log(JSON.stringify(exportData, null, 2));
  
  console.log("\n Function signature dump complete!");
}

main().catch((error) => {
  console.error("\n Script failed:", error);
  process.exit(1);
});