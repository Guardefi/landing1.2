const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";

/**
 * @title Legitimate Withdrawal Finder
 * @notice Find and understand the intended withdrawal mechanism
 * @dev Test common DeFi vault patterns
 */
async function main() {
  console.log("\n🔍 FINDING LEGITIMATE WITHDRAWAL MECHANISM");
  console.log("=====================================");
  
  const [user] = await ethers.getSigners();
  
  // Common DeFi vault patterns
  console.log("\n📋 Testing common DeFi vault patterns:");
  
  // Pattern 1: Share-based vaults (like yearn)
  console.log("\n1️⃣ Share-based vault pattern:");
  await testSharePattern(user, VAULT_ADDRESS);
  
  // Pattern 2: Deposit/Withdraw pattern
  console.log("\n2️⃣ Deposit/Withdraw pattern:");
  await testDepositWithdrawPattern(user, VAULT_ADDRESS);
  
  // Pattern 3: Stake/Unstake pattern
  console.log("\n3️⃣ Stake/Unstake pattern:");
  await testStakePattern(user, VAULT_ADDRESS);
  
  // Pattern 4: LP token pattern
  console.log("\n4️⃣ LP Token pattern:");
  await testLPPattern(user, VAULT_ADDRESS);
  
  // Pattern 5: Timelock pattern
  console.log("\n5️⃣ Timelock pattern:");
  await testTimelockPattern(user, VAULT_ADDRESS);
  
  // Check for user balances or shares
  console.log("\n📊 Checking user balance mechanisms:");
  await checkUserBalances(user, VAULT_ADDRESS);
  
  // Test all found selectors with view calls
  console.log("\n👁️ Testing all selectors as view functions:");
  await testAllSelectorsAsViews(user, VAULT_ADDRESS);
}

async function testSharePattern(user, vault) {
  const shareFunctions = [
    { sig: "0x70a08231", name: "balanceOf(address)", params: ["address"] },
    { sig: "0x18160ddd", name: "totalSupply()", params: [] },
    { sig: "0xce96cb77", name: "shares(address)", params: ["address"] },
    { sig: "0xd1af0c7d", name: "pricePerShare()", params: [] },
    { sig: "0xb69ef8a8", name: "balance()", params: [] },
    { sig: "0xdb006a75", name: "redeem(uint256)", params: ["uint256"] },
    { sig: "0x2e1a7d4d", name: "withdraw(uint256)", params: ["uint256"] },
    { sig: "0xb6b55f25", name: "deposit(uint256)", params: ["uint256"] },
    { sig: "0x6e553f65", name: "deposit(uint256,address)", params: ["uint256", "address"] }
  ];
  
  for (const func of shareFunctions) {
    await testFunction(user, vault, func);
  }
}

async function testDepositWithdrawPattern(user, vault) {
  const dwFunctions = [
    { sig: "0xd0e30db0", name: "deposit()", params: [] },
    { sig: "0x47e7ef24", name: "deposit(address,uint256)", params: ["address", "uint256"] },
    { sig: "0x3ccfd60b", name: "withdraw()", params: [] },
    { sig: "0xf3fef3a3", name: "withdraw(address,uint256)", params: ["address", "uint256"] },
    { sig: "0x853828b6", name: "withdrawAll()", params: [] },
    { sig: "0x69328dec", name: "withdrawAndHarvest(uint256,uint256)", params: ["uint256", "uint256"] }
  ];
  
  for (const func of dwFunctions) {
    await testFunction(user, vault, func);
  }
}

async function testStakePattern(user, vault) {
  const stakeFunctions = [
    { sig: "0xa694fc3a", name: "stake(uint256)", params: ["uint256"] },
    { sig: "0x2e17de78", name: "unstake(uint256)", params: ["uint256"] },
    { sig: "0x7b0472f0", name: "stake(uint256,address)", params: ["uint256", "address"] },
    { sig: "0x5eac6239", name: "unstake(uint256,address)", params: ["uint256", "address"] },
    { sig: "0x4e71d92d", name: "claim()", params: [] },
    { sig: "0xe6f1daf2", name: "claimRewards()", params: [] }
  ];
  
  for (const func of stakeFunctions) {
    await testFunction(user, vault, func);
  }
}

async function testLPPattern(user, vault) {
  const lpFunctions = [
    { sig: "0x441a3e70", name: "removeLiquidity(uint256,uint256)", params: ["uint256", "uint256"] },
    { sig: "0xbaa2abde", name: "removeLiquidity(uint256,uint256,address)", params: ["uint256", "uint256", "address"] },
    { sig: "0x1a4d01d2", name: "exit(uint256)", params: ["uint256"] },
    { sig: "0xe9fad8ee", name: "exit()", params: [] }
  ];
  
  for (const func of lpFunctions) {
    await testFunction(user, vault, func);
  }
}

async function testTimelockPattern(user, vault) {
  const timelockFunctions = [
    { sig: "0x0c340a24", name: "governor()", params: [] },
    { sig: "0xb1c5f427", name: "getActions(uint256)", params: ["uint256"] },
    { sig: "0x8d928af8", name: "getVault()", params: [] },
    { sig: "0xc1a287e2", name: "GRACE_PERIOD()", params: [] },
    { sig: "0x7d645fab", name: "delay()", params: [] }
  ];
  
  for (const func of timelockFunctions) {
    await testFunction(user, vault, func);
  }
}

async function testFunction(user, vault, func) {
  try {
    let calldata = func.sig;
    
    // Build parameters based on function signature
    if (func.params.length > 0) {
      const values = func.params.map(param => {
        if (param === "address") return user.address;
        if (param === "uint256") return ethers.parseEther("0.1");
        return "0x0";
      });
      
      calldata += ethers.AbiCoder.defaultAbiCoder().encode(func.params, values).slice(2);
    }
    
    // Try as view function first
    try {
      const result = await user.call({ to: vault, data: calldata });
      if (result && result !== "0x") {
        console.log(`✅ ${func.name} (view): ${result.slice(0, 66)}...`);
        
        // Decode common return types
        if (result.length === 66) {
          const value = BigInt(result);
          if (value > 0n && value < ethers.parseEther("1000000")) {
            console.log(`   → Decoded: ${ethers.formatEther(value)} ETH`);
          } else if (value > 0n && value < 1000000000000n) {
            console.log(`   → Decoded: ${ethers.formatUnits(value, 6)} (6 decimals)`);
          }
        }
      }
    } catch (viewError) {
      // Try as transaction
      const tx = await user.sendTransaction({
        to: vault,
        data: calldata,
        gasLimit: 200000
      });
      await tx.wait();
      console.log(`✅ ${func.name} (tx): Success`);
    }
  } catch (e) {
    // Silent fail
  }
}

async function checkUserBalances(user, vault) {
  // Common balance check patterns
  const balanceChecks = [
    { method: "balanceOf", slot: 0 },
    { method: "shares", slot: 1 },
    { method: "deposits", slot: 2 },
    { method: "stakes", slot: 3 },
    { method: "userInfo", slot: 4 }
  ];
  
  console.log("\nChecking direct storage for user balances:");
  
  for (const check of balanceChecks) {
    // Check mapping storage
    const slot = ethers.solidityPackedKeccak256(
      ["address", "uint256"],
      [user.address, check.slot]
    );
    
    const value = await ethers.provider.getStorage(vault, slot);
    if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
      console.log(`${check.method} mapping at slot ${check.slot}: ${value}`);
      
      try {
        const amount = BigInt(value);
        console.log(`  → Amount: ${amount}`);
      } catch (e) {}
    }
  }
  
  // Check struct patterns (user info might be packed)
  for (let i = 0; i < 10; i++) {
    const baseSlot = ethers.solidityPackedKeccak256(
      ["address", "uint256"],
      [user.address, i]
    );
    
    // Check base slot and next few slots (for structs)
    for (let j = 0; j < 3; j++) {
      const slot = BigInt(baseSlot) + BigInt(j);
      const value = await ethers.provider.getStorage(vault, "0x" + slot.toString(16));
      
      if (value !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
        console.log(`Potential user data at slot ${i}+${j}: ${value}`);
      }
    }
  }
}

async function testAllSelectorsAsViews(user, vault) {
  // Get all selectors from the vault
  const code = await ethers.provider.getCode(vault);
  const selectors = extractSelectors(code);
  
  console.log(`\nTesting ${selectors.size} selectors as view functions:`);
  
  for (const selector of selectors) {
    try {
      const result = await user.call({
        to: vault,
        data: selector
      });
      
      if (result && result !== "0x" && result.length > 2) {
        console.log(`${selector}: ${result.slice(0, 66)}...`);
        
        // Try to interpret the result
        if (result.length === 66) {
          // 32 bytes - could be address, uint256, or bytes32
          const asAddress = "0x" + result.slice(26);
          const asUint = BigInt(result);
          
          if (result.slice(2, 26) === "000000000000000000000000") {
            console.log(`  → Address: ${asAddress}`);
          } else if (asUint < 1000000000000000000000n) {
            console.log(`  → Number: ${asUint}`);
          }
        }
      }
    } catch (e) {
      // Silent fail for view calls
    }
  }
}

function extractSelectors(bytecode) {
  const selectors = new Set();
  const push4Pattern = /63([0-9a-f]{8})/g;
  let match;
  
  while ((match = push4Pattern.exec(bytecode)) !== null) {
    selectors.add("0x" + match[1]);
  }
  
  return selectors;
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
