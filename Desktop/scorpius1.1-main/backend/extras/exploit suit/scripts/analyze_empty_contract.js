const { ethers } = require("hardhat");

async function analyzeContract() {
  const target = "0xcA8Fa8f0b631EcdB18Cda619C4Fc9d197c8aFfCa";
  
  console.log("\nüîç ANALYZING CONTRACT");
  console.log("====================");
  console.log("Target:", target);
  
  try {
    const code = await ethers.provider.getCode(target);
    const balance = await ethers.provider.getBalance(target);
    
    console.log("\nüìä Contract Details:");
    console.log(`Balance: ${ethers.formatEther(balance)} ETH`);
    console.log(`Code: ${code}`);
    console.log(`Code length: ${code.length} characters (${(code.length - 2) / 2} bytes)`);
    
    if (code === "0x") {
      console.log("\n‚ö†Ô∏è  This is an EOA (Externally Owned Account), not a contract!");
      console.log("The ETH is controlled by whoever has the private key.");
      console.log("Cannot be exploited through contract vulnerabilities.");
    } else if (code.length <= 10) {
      console.log("\n‚ö†Ô∏è  This contract has minimal bytecode!");
      console.log("It might be:");
      console.log("‚Ä¢ A destroyed contract (selfdestructed)");
      console.log("‚Ä¢ A minimal proxy");
      console.log("‚Ä¢ An EOA that received ETH");
    }
    
    // Check if it's actually deployed
    const nonce = await ethers.provider.getTransactionCount(target);
    console.log(`\nTransaction count: ${nonce}`);
    
    // Try to get contract creation
    console.log("\nChecking deployment status...");
    
  } catch (error) {
    console.log("Error:", error.message);
  }
}

analyzeContract()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("Error:", error);
    process.exit(1);
  });
