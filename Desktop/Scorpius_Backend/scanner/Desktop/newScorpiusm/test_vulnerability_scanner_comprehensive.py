#!/usr/bin/env python3
"""
Comprehensive Vulnerability Scanner Integration Test
Tests the scanner end-to-end with real vulnerable contracts and all plugins
"""

import asyncio
import json
import time
from typing import Any

import requests


class VulnerabilityTestContract:
    """Test contracts with known vulnerabilities"""
    
    REENTRANCY_VULNERABLE = """
pragma solidity ^0.8.0;

contract ReentrancyVulnerable {
    mapping(address => uint256) public balances;
    
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // VULNERABLE: External call before state change
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        balances[msg.sender] -= amount; // State change after external call
    }
}
"""

    INTEGER_OVERFLOW = """
pragma solidity ^0.7.0; // Older version without SafeMath

contract IntegerOverflow {
    mapping(address => uint256) public balances;
    
    function add(uint256 amount) public {
        // VULNERABLE: Integer overflow possible
        balances[msg.sender] += amount;
    }
    
    function subtract(uint256 amount) public {
        // VULNERABLE: Integer underflow possible
        balances[msg.sender] -= amount;
    }
}
"""

    ACCESS_CONTROL_WEAK = """
pragma solidity ^0.8.0;

contract WeakAccessControl {
    address public owner;
    mapping(address => bool) public admins;
    
    constructor() {
        owner = msg.sender;
    }
    
    // VULNERABLE: tx.origin instead of msg.sender
    modifier onlyOwner() {
        require(tx.origin == owner, "Not owner");
        _;
    }
    
    // VULNERABLE: Public function with no access control
    function setAdmin(address user, bool isAdmin) public {
        admins[user] = isAdmin;
    }
    
    function sensitiveOperation() public onlyOwner {
        // Sensitive operation
    }
}
"""

    MULTIPLE_VULNERABILITIES = """
pragma solidity ^0.8.0;

contract MultipleVulns {
    mapping(address => uint256) public balances;
    address public owner;
    uint256 public constant MAX_SUPPLY = 1000000;
    
    constructor() {
        owner = msg.sender;
    }
    
    // Reentrancy vulnerability
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount);
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
        
        balances[msg.sender] -= amount;
    }
    
    // Weak access control (tx.origin)
    modifier onlyOwner() {
        require(tx.origin == owner);
        _;
    }
    
    // Unchecked external call
    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount);
        
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        // VULNERABLE: Unchecked call
        to.call("");
    }
    
    // Potential DoS with gas limit
    function batchTransfer(address[] memory recipients, uint256[] memory amounts) public {
        for (uint i = 0; i < recipients.length; i++) {
            balances[recipients[i]] += amounts[i];
        }
    }
}
"""


class ScannerIntegrationTester:
    """Integration tester for vulnerability scanner"""
    
    def __init__(self, 
                 backend_url: str = "http://localhost:8000",
                 scanner_url: str = "http://localhost:8001"):
        self.backend_url = backend_url
        self.scanner_url = scanner_url
        self.test_results: list[dict[str, Any]] = []
    
    async def wait_for_services(self, timeout: int = 120) -> bool:
        """Wait for both backend and scanner services to be ready"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                # Check backend health
                backend_response = requests.get(f"{self.backend_url}/health", timeout=5)
                backend_ready = backend_response.status_code == 200
                
                # Check scanner health
                scanner_response = requests.get(f"{self.scanner_url}/health", timeout=5)
                scanner_ready = scanner_response.status_code == 200
                
                if backend_ready and scanner_ready:
                    print("✅ Both services are ready!")
                    return True
                    
            except requests.exceptions.RequestException:
                pass
            
            print(f"⏳ Waiting for services... ({int(time.time() - start_time)}s)")
            time.sleep(5)
        
        print("❌ Services did not become ready in time")
        return False
    
    async def test_scanner_health(self) -> dict[str, Any]:
        """Test scanner service health"""
        print("\n🏥 Testing Scanner Service Health...")
        
        try:
            response = requests.get(f"{self.scanner_url}/health", timeout=10)
            
            if response.status_code == 200:
                health_data = response.json()
                print(f"✅ Scanner Health: {health_data}")
                
                return {
                    "test": "scanner_health",
                    "status": "pass",
                    "health_data": health_data
                }
            else:
                print(f"❌ Scanner health check failed: {response.status_code}")
                return {
                    "test": "scanner_health",
                    "status": "fail",
                    "error": f"HTTP {response.status_code}"
                }
                
        except Exception as e:
            print(f"❌ Scanner health check error: {e}")
            return {
                "test": "scanner_health",
                "status": "error",
                "error": str(e)
            }
    
    async def test_scanner_plugins(self) -> dict[str, Any]:
        """Test scanner plugins endpoint"""
        print("\n🔌 Testing Scanner Plugins...")
        
        try:
            response = requests.get(f"{self.scanner_url}/plugins", timeout=10)
            
            if response.status_code == 200:
                plugins = response.json()
                print(f"✅ Available Plugins: {len(plugins)}")
                
                for plugin in plugins:
                    print(f"  - {plugin['name']}: {plugin['description']}")
                
                return {
                    "test": "scanner_plugins",
                    "status": "pass",
                    "plugins": plugins
                }
            else:
                print(f"❌ Scanner plugins failed: {response.status_code}")
                return {
                    "test": "scanner_plugins",
                    "status": "fail",
                    "error": f"HTTP {response.status_code}"
                }
                
        except Exception as e:
            print(f"❌ Scanner plugins error: {e}")
            return {
                "test": "scanner_plugins",
                "status": "error",
                "error": str(e)
            }
    
    async def test_vulnerability_scan(self, 
                                    contract_code: str, 
                                    test_name: str,
                                    expected_findings: list[str] = None) -> dict[str, Any]:
        """Test vulnerability scan with a specific contract"""
        print(f"\n🔍 Testing Vulnerability Scan: {test_name}...")
        
        try:
            # Start scan via backend API
            scan_request = {
                "target": contract_code,
                "plugins": ["slither-static", "mythril-symbolic", "reentrancy"],
                "enable_simulation": True
            }
            
            response = requests.post(
                f"{self.backend_url}/api/scanner/scan",
                json=scan_request,
                timeout=10
            )
            
            if response.status_code != 200:
                print(f"❌ Scan initiation failed: {response.status_code}")
                return {
                    "test": f"scan_{test_name}",
                    "status": "fail",
                    "error": f"HTTP {response.status_code}"
                }
            
            scan_response = response.json()
            scan_id = scan_response["scan_id"]
            print(f"📝 Scan started with ID: {scan_id}")
            
            # Poll for results
            max_polls = 30  # 30 * 2 seconds = 1 minute
            for poll_count in range(max_polls):
                time.sleep(2)
                
                status_response = requests.get(
                    f"{self.backend_url}/api/scanner/scan/{scan_id}",
                    timeout=10
                )
                
                if status_response.status_code != 200:
                    continue
                
                status_data = status_response.json()
                print(f"📊 Scan status: {status_data['status']} (poll {poll_count + 1})")
                
                if status_data["status"] == "completed":
                    findings = status_data.get("findings", [])
                    print(f"✅ Scan completed! Found {len(findings)} findings:")
                    
                    for finding in findings:
                        severity_emoji = {
                            "high": "🔴",
                            "medium": "🟡", 
                            "low": "🟢",
                            "info": "ℹ️"
                        }.get(finding["severity"], "❓")
                        
                        print(f"  {severity_emoji} {finding['title']} "
                              f"({finding['severity']}, {finding['source_tool']})")
                        if finding.get("location"):
                            print(f"    📍 {finding['location']}")
                    
                    # Validate expected findings
                    validation_results = []
                    if expected_findings:
                        for expected in expected_findings:
                            found = any(expected.lower() in finding["title"].lower() 
                                      or expected.lower() in finding["description"].lower()
                                      for finding in findings)
                            validation_results.append({
                                "expected": expected,
                                "found": found
                            })
                            
                            status_emoji = "✅" if found else "❌"
                            print(f"    {status_emoji} Expected '{expected}': {'Found' if found else 'Not found'}")
                    
                    return {
                        "test": f"scan_{test_name}",
                        "status": "pass",
                        "scan_id": scan_id,
                        "findings_count": len(findings),
                        "findings": findings,
                        "validation": validation_results
                    }
                
                elif status_data["status"] == "failed":
                    error = status_data.get("error", "Unknown error")
                    print(f"❌ Scan failed: {error}")
                    return {
                        "test": f"scan_{test_name}",
                        "status": "fail",
                        "error": error
                    }
            
            print("⏰ Scan timed out")
            return {
                "test": f"scan_{test_name}",
                "status": "timeout",
                "error": "Scan did not complete within timeout"
            }
            
        except Exception as e:
            print(f"❌ Scan test error: {e}")
            return {
                "test": f"scan_{test_name}",
                "status": "error",
                "error": str(e)
            }
    
    async def test_backend_scanner_integration(self) -> dict[str, Any]:
        """Test backend to scanner service communication"""
        print("\n🔗 Testing Backend-Scanner Integration...")
        
        try:
            # Test scanner health via backend
            response = requests.get(f"{self.backend_url}/api/scanner/health", timeout=10)
            
            if response.status_code == 200:
                health_data = response.json()
                external_scanner = health_data.get("external_scanner", False)
                
                if external_scanner:
                    print("✅ Backend successfully communicates with scanner service")
                    return {
                        "test": "backend_scanner_integration",
                        "status": "pass",
                        "health_data": health_data
                    }
                else:
                    print("❌ Backend reports scanner service unavailable")
                    return {
                        "test": "backend_scanner_integration",
                        "status": "fail",
                        "error": "Scanner service not available to backend"
                    }
            else:
                print(f"❌ Backend scanner health failed: {response.status_code}")
                return {
                    "test": "backend_scanner_integration",
                    "status": "fail",
                    "error": f"HTTP {response.status_code}"
                }
                
        except Exception as e:
            print(f"❌ Backend-scanner integration error: {e}")
            return {
                "test": "backend_scanner_integration",
                "status": "error",
                "error": str(e)
            }
    
    async def run_comprehensive_tests(self) -> dict[str, Any]:
        """Run all comprehensive vulnerability scanner tests"""
        print("🚀 Starting Comprehensive Vulnerability Scanner Tests")
        print("=" * 60)
        
        # Wait for services
        if not await self.wait_for_services():
            return {
                "overall_status": "fail",
                "error": "Services not ready",
                "tests": []
            }
        
        # Run individual tests
        test_suite = [
            # Service health tests
            self.test_scanner_health(),
            self.test_scanner_plugins(),
            self.test_backend_scanner_integration(),
            
            # Vulnerability detection tests
            self.test_vulnerability_scan(
                VulnerabilityTestContract.REENTRANCY_VULNERABLE,
                "reentrancy",
                ["reentrancy", "external call", "state change"]
            ),
            self.test_vulnerability_scan(
                VulnerabilityTestContract.ACCESS_CONTROL_WEAK,
                "access_control",
                ["tx.origin", "access control"]
            ),
            self.test_vulnerability_scan(
                VulnerabilityTestContract.MULTIPLE_VULNERABILITIES,
                "multiple_vulns",
                ["reentrancy", "tx.origin", "external call"]
            )
        ]
        
        # Execute tests
        for test_coro in test_suite:
            result = await test_coro
            self.test_results.append(result)
        
        # Summary
        print("\n" + "=" * 60)
        print("📊 Test Summary")
        print("=" * 60)
        
        passed = len([r for r in self.test_results if r["status"] == "pass"])
        failed = len([r for r in self.test_results if r["status"] in ["fail", "error", "timeout"]])
        
        print(f"✅ Passed: {passed}")
        print(f"❌ Failed: {failed}")
        print(f"📈 Success Rate: {passed / len(self.test_results) * 100:.1f}%")
        
        # Detailed results
        for result in self.test_results:
            status_emoji = {
                "pass": "✅",
                "fail": "❌", 
                "error": "💥",
                "timeout": "⏰"
            }.get(result["status"], "❓")
            
            print(f"{status_emoji} {result['test']}: {result['status'].upper()}")
            
            if result["status"] != "pass" and "error" in result:
                print(f"    Error: {result['error']}")
        
        overall_status = "pass" if failed == 0 else "fail"
        
        return {
            "overall_status": overall_status,
            "passed": passed,
            "failed": failed,
            "total": len(self.test_results),
            "success_rate": passed / len(self.test_results),
            "tests": self.test_results
        }


async def main():
    """Main test runner"""
    tester = ScannerIntegrationTester()
    results = await tester.run_comprehensive_tests()
    
    # Save results to file
    with open("scanner_test_results.json", "w") as f:
        json.dump(results, f, indent=2)
    
    print("\n💾 Results saved to: scanner_test_results.json")
    
    # Exit with appropriate code
    exit_code = 0 if results["overall_status"] == "pass" else 1
    print(f"\n🏁 Tests completed with exit code: {exit_code}")
    
    return exit_code


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    exit(exit_code)
