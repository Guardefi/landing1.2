#!/usr/bin/env python3
"""
Comprehensive Vulnerability Scanner Integration Test

Tests the vulnerability scanner both as a standalone module and through API integration.
Verifies detection of various Solidity vulnerabilities and proper API functionality.
"""

import asyncio
import json
import os
import sys
import tempfile
import uuid
from pathlib import Path
from typing import Any, Dict, List

# Add backend to path
backend_path = Path(__file__).parent / "backend"
sys.path.insert(0, str(backend_path))

# Test contracts with various vulnerabilities
TEST_CONTRACTS = {
    "reentrancy_vulnerable": """
pragma solidity ^0.8.0;

contract ReentrancyVulnerable {
    mapping(address => uint256) public balances;
    
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // Vulnerable: external call before state update
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        balances[msg.sender] -= amount;  // State update after external call
    }
    
    function getBalance() public view returns (uint256) {
        return balances[msg.sender];
    }
}
""",
    "tx_origin_vulnerable": """
pragma solidity ^0.8.0;

contract TxOriginVulnerable {
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        // Vulnerable: using tx.origin instead of msg.sender
        require(tx.origin == owner, "Not owner");
        _;
    }
    
    function sensitiveFunction() public onlyOwner {
        // Some sensitive operation
    }
}
""",
    "unchecked_transfer": """
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

contract UncheckedTransfer {
    IERC20 public token;
    
    constructor(address _token) {
        token = IERC20(_token);
    }
    
    function unsafeTransfer(address to, uint256 amount) public {
        // Vulnerable: not checking return value
        token.transfer(to, amount);
    }
}
""",
    "integer_overflow": """
pragma solidity ^0.6.0;  // Older version without automatic overflow protection

contract IntegerOverflow {
    mapping(address => uint256) public balances;
    
    function add(uint256 amount) public {
        // Vulnerable to overflow in older Solidity versions
        balances[msg.sender] += amount;
    }
    
    function subtract(uint256 amount) public {
        // Vulnerable to underflow
        balances[msg.sender] -= amount;
    }
}
""",
    "safe_contract": """
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SafeContract is ReentrancyGuard, Ownable {
    mapping(address => uint256) public balances;
    
    event Deposit(address indexed user, uint256 amount);
    event Withdrawal(address indexed user, uint256 amount);
    
    function deposit() public payable {
        require(msg.value > 0, "Must deposit positive amount");
        balances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    function withdraw(uint256 amount) public nonReentrant {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        require(amount > 0, "Must withdraw positive amount");
        
        // Update state before external call
        balances[msg.sender] -= amount;
        
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        emit Withdrawal(msg.sender, amount);
    }
    
    function emergencyWithdraw() public onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }
}
"""
}

class VulnerabilityDetector:
    """Simplified vulnerability detector for testing"""
    
    def __init__(self):
        self.vulnerability_patterns = {
            'reentrancy': {
                'patterns': [
                    'call{value:',
                    '.call(',
                    'transfer(',
                    'send('
                ],
                'anti_patterns': [
                    'nonReentrant',
                    'ReentrancyGuard'
                ],
                'severity': 'HIGH'
            },
            'tx_origin': {
                'patterns': ['tx.origin'],
                'severity': 'MEDIUM'
            },
            'unchecked_return': {
                'patterns': [
                    '.transfer(',
                    '.send(',
                    '.call('
                ],
                'anti_patterns': [
                    'require(',
                    'assert(',
                    'if ('
                ],
                'severity': 'LOW'
            },
            'integer_overflow': {
                'patterns': [
                    '+=',
                    '-=',
                    '*=',
                    '**'
                ],
                'version_check': '0.8.0',
                'severity': 'HIGH'
            }
        }
    
    def analyze_contract(self, contract_code: str) -> List[Dict[str, Any]]:
        """Analyze contract code and return vulnerabilities"""
        findings = []
        lines = contract_code.split('\n')
        
        # Check Solidity version
        solidity_version = self._extract_solidity_version(contract_code)
        
        for vuln_type, config in self.vulnerability_patterns.items():
            vuln_findings = self._check_vulnerability(
                contract_code, lines, vuln_type, config, solidity_version
            )
            findings.extend(vuln_findings)
        
        return findings
    
    def _extract_solidity_version(self, contract_code: str) -> str:
        """Extract Solidity version from pragma statement"""
        for line in contract_code.split('\n'):
            if 'pragma solidity' in line.lower():
                return line.strip()
        return ""
    
    def _check_vulnerability(self, contract_code: str, lines: List[str], 
                           vuln_type: str, config: Dict[str, Any], 
                           solidity_version: str) -> List[Dict[str, Any]]:
        """Check for specific vulnerability type"""
        findings = []
        
        # Special handling for integer overflow in newer Solidity versions
        if vuln_type == 'integer_overflow':
            if '0.8.0' in solidity_version or '^0.8' in solidity_version:
                return []  # Protected by default in 0.8.0+
        
        for i, line in enumerate(lines):
            line_lower = line.lower().strip()
            
            # Check if any pattern matches
            pattern_found = any(pattern in line for pattern in config['patterns'])
            
            if pattern_found:
                # Check for anti-patterns that would mitigate the vulnerability
                anti_pattern_found = False
                if 'anti_patterns' in config:
                    # Check current line and surrounding context
                    context_lines = lines[max(0, i-2):min(len(lines), i+3)]
                    context = ' '.join(context_lines).lower()
                    anti_pattern_found = any(
                        anti_pattern.lower() in context 
                        for anti_pattern in config['anti_patterns']
                    )
                
                if not anti_pattern_found:
                    finding = {
                        'id': str(uuid.uuid4()),
                        'type': vuln_type,
                        'severity': config['severity'],
                        'line': i + 1,
                        'code': line.strip(),
                        'description': self._get_vulnerability_description(vuln_type),
                        'recommendation': self._get_vulnerability_recommendation(vuln_type)
                    }
                    findings.append(finding)
        
        return findings
    
    def _get_vulnerability_description(self, vuln_type: str) -> str:
        """Get description for vulnerability type"""
        descriptions = {
            'reentrancy': 'Potential reentrancy vulnerability detected. External calls should be made after state changes.',
            'tx_origin': 'Use of tx.origin detected. This can be manipulated in phishing attacks.',
            'unchecked_return': 'Unchecked return value from external call. This can lead to silent failures.',
            'integer_overflow': 'Potential integer overflow/underflow detected in older Solidity version.'
        }
        return descriptions.get(vuln_type, f'Vulnerability of type {vuln_type} detected.')
    
    def _get_vulnerability_recommendation(self, vuln_type: str) -> str:
        """Get recommendation for vulnerability type"""
        recommendations = {
            'reentrancy': 'Use the Checks-Effects-Interactions pattern or ReentrancyGuard modifier.',
            'tx_origin': 'Use msg.sender instead of tx.origin for authorization checks.',
            'unchecked_return': 'Always check return values of external calls or use SafeERC20.',
            'integer_overflow': 'Use SafeMath library or upgrade to Solidity 0.8.0+ for automatic overflow protection.'
        }
        return recommendations.get(vuln_type, f'Review and fix {vuln_type} vulnerability.')


async def test_standalone_scanner():
    """Test the vulnerability scanner as a standalone module"""
    print("üîç Testing Standalone Vulnerability Scanner")
    print("=" * 50)
    
    detector = VulnerabilityDetector()
    total_tests = len(TEST_CONTRACTS)
    passed_tests = 0
    
    for contract_name, contract_code in TEST_CONTRACTS.items():
        print(f"\nüìÑ Testing contract: {contract_name}")
        
        try:
            findings = detector.analyze_contract(contract_code)
            
            print(f"   Found {len(findings)} potential issues:")
            
            if findings:
                for finding in findings:
                    print(f"   ‚ö†Ô∏è  {finding['severity']} - {finding['type']} (Line {finding['line']})")
                    print(f"      Description: {finding['description']}")
                    print(f"      Code: {finding['code']}")
                    print(f"      Recommendation: {finding['recommendation']}")
                    print()
            else:
                print("   ‚úÖ No vulnerabilities detected")
            
            # Validate expected results
            expected_vulns = {
                'reentrancy_vulnerable': ['reentrancy'],
                'tx_origin_vulnerable': ['tx_origin'],
                'unchecked_transfer': ['unchecked_return'],
                'integer_overflow': ['integer_overflow'],
                'safe_contract': []  # Should have no vulnerabilities
            }
            
            found_types = [f['type'] for f in findings]
            expected = expected_vulns.get(contract_name, [])
            
            if set(found_types) >= set(expected):  # Allow additional findings
                print(f"   ‚úÖ Test passed - detected expected vulnerabilities")
                passed_tests += 1
            else:
                print(f"   ‚ùå Test failed - expected {expected}, found {found_types}")
            
        except Exception as e:
            print(f"   ‚ùå Error analyzing contract: {e}")
    
    print(f"\nüìä Standalone Scanner Results: {passed_tests}/{total_tests} tests passed")
    return passed_tests == total_tests


async def test_scanner_api_integration():
    """Test the scanner through API routes (simulated)"""
    print("\nüåê Testing Scanner API Integration")
    print("=" * 50)
    
    # Import scanner routes
    try:
        from scanner_routes import simulate_scan_process, active_scans, scan_results
        print("‚úÖ Successfully imported scanner_routes module")
    except ImportError as e:
        print(f"‚ùå Failed to import scanner_routes: {e}")
        return False
    
    # Test scan simulation
    scan_id = str(uuid.uuid4())
    target_contract = TEST_CONTRACTS['reentrancy_vulnerable']
    
    print(f"\nüîÑ Simulating scan for contract with ID: {scan_id}")
    
    try:
        # Initialize scan
        active_scans[scan_id] = {
            'status': 'pending',
            'target': target_contract,
            'created_at': '2025-06-24T10:30:00Z'
        }
        
        # Run scan simulation
        await simulate_scan_process(scan_id, target_contract, ['slither-static', 'reentrancy'])
        
        # Check results
        if scan_id in scan_results and active_scans[scan_id]['status'] == 'completed':
            findings = scan_results[scan_id]
            print(f"‚úÖ Scan completed successfully with {len(findings)} findings")
            
            for finding in findings[:3]:  # Show first 3 findings
                print(f"   üîç {finding.severity} - {finding.title}")
                print(f"      {finding.description}")
            
            return True
        else:
            print(f"‚ùå Scan did not complete properly")
            return False
            
    except Exception as e:
        print(f"‚ùå Error during API integration test: {e}")
        return False


async def test_scanner_with_slither():
    """Test scanner with actual Slither if available"""
    print("\nüîß Testing Scanner with Slither Integration")
    print("=" * 50)
    
    try:
        import subprocess
        
        # Check if Slither is installed
        result = subprocess.run(['slither', '--version'], 
                              capture_output=True, text=True, timeout=10)
        
        if result.returncode == 0:
            print(f"‚úÖ Slither is available: {result.stdout.strip()}")
            
            # Test with a simple contract
            with tempfile.NamedTemporaryFile(mode='w', suffix='.sol', delete=False) as f:
                f.write(TEST_CONTRACTS['reentrancy_vulnerable'])
                temp_file = f.name
            
            try:
                # Run Slither analysis
                cmd = ['slither', temp_file, '--json', '-']
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                
                print(f"Slither exit code: {result.returncode}")
                
                if result.stdout:
                    try:
                        slither_output = json.loads(result.stdout)
                        detectors = slither_output.get('results', {}).get('detectors', [])
                        print(f"‚úÖ Slither analysis completed - found {len(detectors)} issues")
                        
                        for detector in detectors[:3]:  # Show first 3
                            check = detector.get('check', 'Unknown')
                            impact = detector.get('impact', 'info')
                            print(f"   üîç {impact.upper()} - {check}")
                        
                        return True
                    except json.JSONDecodeError:
                        print("‚ö†Ô∏è  Slither output is not valid JSON")
                        print(f"Raw output: {result.stdout[:200]}...")
                        return False
                else:
                    print(f"‚ö†Ô∏è  Slither produced no output")
                    if result.stderr:
                        print(f"Stderr: {result.stderr[:200]}...")
                    return False
                    
            finally:
                os.unlink(temp_file)
                
        else:
            print("‚ö†Ô∏è  Slither is not available or not working properly")
            if result.stderr:
                print(f"Error: {result.stderr}")
            return False
            
    except subprocess.TimeoutExpired:
        print("‚ùå Slither command timed out")
        return False
    except FileNotFoundError:
        print("‚ö†Ô∏è  Slither is not installed or not in PATH")
        return False
    except Exception as e:
        print(f"‚ùå Error testing Slither: {e}")
        return False


async def test_scanner_performance():
    """Test scanner performance with multiple contracts"""
    print("\n‚ö° Testing Scanner Performance")
    print("=" * 50)
    
    import time
    
    detector = VulnerabilityDetector()
    
    # Run multiple contracts multiple times
    iterations = 10
    contracts_per_iteration = len(TEST_CONTRACTS)
    
    start_time = time.time()
    
    total_findings = 0
    for i in range(iterations):
        for contract_name, contract_code in TEST_CONTRACTS.items():
            findings = detector.analyze_contract(contract_code)
            total_findings += len(findings)
    
    end_time = time.time()
    total_time = end_time - start_time
    total_analyses = iterations * contracts_per_iteration
    
    print(f"‚úÖ Performance test completed:")
    print(f"   üìä Total analyses: {total_analyses}")
    print(f"   ‚è±Ô∏è  Total time: {total_time:.2f} seconds")
    print(f"   ‚ö° Average time per analysis: {(total_time/total_analyses)*1000:.2f}ms")
    print(f"   üîç Total findings: {total_findings}")
    print(f"   üìà Analyses per second: {total_analyses/total_time:.2f}")
    
    return total_time < 5.0  # Should complete in under 5 seconds


async def run_comprehensive_tests():
    """Run all vulnerability scanner tests"""
    print("üöÄ Starting Comprehensive Vulnerability Scanner Tests")
    print("=" * 60)
    
    tests = [
        ("Standalone Scanner", test_standalone_scanner),
        ("API Integration", test_scanner_api_integration),
        ("Slither Integration", test_scanner_with_slither),
        ("Performance Test", test_scanner_performance),
    ]
    
    results = {}
    
    for test_name, test_func in tests:
        try:
            result = await test_func()
            results[test_name] = result
        except Exception as e:
            print(f"‚ùå {test_name} failed with exception: {e}")
            results[test_name] = False
    
    print("\nüìã Final Test Results")
    print("=" * 60)
    
    passed = 0
    total = len(tests)
    
    for test_name, passed_test in results.items():
        status = "‚úÖ PASSED" if passed_test else "‚ùå FAILED"
        print(f"{test_name:.<30} {status}")
        if passed_test:
            passed += 1
    
    print(f"\nüìä Overall Results: {passed}/{total} tests passed")
    
    if passed == total:
        print("üéâ All tests passed! The vulnerability scanner is working correctly.")
    elif passed > total // 2:
        print("‚ö†Ô∏è  Most tests passed. Some integration issues may need attention.")
    else:
        print("‚ùå Multiple test failures. Scanner needs significant attention.")
    
    return passed, total


if __name__ == "__main__":
    # Run the comprehensive test suite
    asyncio.run(run_comprehensive_tests())
