"""
WebSocket routers for real-time communication
Enhanced for seamless frontend integration with structured message protocol
"""

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Query
from typing import Optional, Dict, Any
import json
import logging
from datetime import datetime

from api.websocket_manager import connection_manager
from core.engine import ScanEngine
from exploitation.simulation_engine import SimulationEngine

logger = logging.getLogger("scorpius.websocket_routes")

router = APIRouter()

# Enhanced authentication for WebSocket
async def authenticate_websocket(websocket: WebSocket, token: Optional[str] = None) -> str:
    """Authenticate WebSocket connection with JWT support"""
    if not token:
        return "anonymous_user"
    
    # Simple token validation for demo
    if token == "demo_token":
        return "demo_user"
    
    # In production, validate JWT token here
    try:
        # Placeholder JWT validation
        if token.startswith("jwt_"):
            return token.replace("jwt_", "user_")
        return f"user_{token[:8]}"
    except Exception:
        return "anonymous_user"

@router.websocket("/dashboard")
async def dashboard_websocket(
    websocket: WebSocket,
    token: Optional[str] = Query(None)
):
    """
    Main dashboard WebSocket for real-time updates
    
    Message Protocol:
    Client -> Server:
    {
        "type": "subscribe|unsubscribe|heartbeat|request",
        "data": {
            "topic": "scans|simulations|metrics|notifications",
            "action": "...", 
            ...
        }
    }
    
    Server -> Client:
    {
        "type": "scan_started|scan_progress|scan_completed|...",
        "data": { ... },
        "timestamp": "ISO timestamp",
        "message_id": "unique_id"
    }
    """
    try:
        user_id = await authenticate_websocket(websocket, token)
        connection_id = await connection_manager.connect(websocket, user_id, "dashboard")
        
        # Send welcome message with available subscriptions
        await connection_manager.send_personal_message({
            "type": "connection_established",
            "data": {
                "connection_id": connection_id,
                "user_id": user_id,
                "available_topics": [
                    "scans", "simulations", "metrics", 
                    "notifications", "plugins", "system"
                ],
                "server_time": datetime.now().isoformat(),
                "protocol_version": "2.0"
            }
        }, connection_id)
        
        while True:
            try:
                data = await websocket.receive_text()
                message = json.loads(data)
                
                message_type = message.get("type")
                message_data = message.get("data", {})
                
                if message_type == "subscribe":
                    topic = message_data.get("topic")
                    if topic in ["scans", "simulations", "metrics", "notifications", "plugins", "system"]:
                        await connection_manager.join_room(connection_id, topic)
                        await connection_manager.send_personal_message({
                            "type": "subscription_confirmed",
                            "data": {
                                "topic": topic,
                                "status": "subscribed"
                            }
                        }, connection_id)
                    else:
                        await connection_manager.send_personal_message({
                            "type": "error",
                            "data": {"message": f"Invalid topic: {topic}"}
                        }, connection_id)
                
                elif message_type == "unsubscribe":
                    topic = message_data.get("topic")
                    await connection_manager.leave_room(connection_id, topic)
                    await connection_manager.send_personal_message({
                        "type": "subscription_cancelled",
                        "data": {
                            "topic": topic,
                            "status": "unsubscribed"
                        }
                    }, connection_id)
                
                elif message_type == "request":
                    # Handle specific data requests
                    request_type = message_data.get("request_type")
                    await handle_dashboard_request(connection_id, request_type, message_data)
                
                elif message_type == "heartbeat":
                    await connection_manager.send_personal_message({
                        "type": "heartbeat_response",
                        "data": {
                            "timestamp": datetime.now().isoformat(),
                            "status": "alive"
                        }
                    }, connection_id)
                
            except WebSocketDisconnect:
                break
            except json.JSONDecodeError:
                await connection_manager.send_personal_message({
                    "type": "error",
                    "data": {"message": "Invalid JSON format"}
                }, connection_id)
            except Exception as e:
                logger.error(f"Error handling dashboard message: {e}")
                await connection_manager.send_personal_message({
                    "type": "error",
                    "data": {"message": str(e)}
                }, connection_id)
    
    except Exception as e:
        logger.error(f"Dashboard WebSocket error: {e}")
    finally:
        if 'connection_id' in locals():
            await connection_manager.disconnect(connection_id)

@router.websocket("/scan/{scan_id}")
async def scan_websocket(
    websocket: WebSocket,
    scan_id: str,
    token: Optional[str] = Query(None)
):
    """
    Scan-specific WebSocket for detailed progress updates
    
    Provides real-time updates for a specific scan including:
    - Progress updates
    - New findings
    - Plugin status changes
    - Completion status
    """
    try:
        user_id = await authenticate_websocket(websocket, token)
        room = f"scan_{scan_id}"
        connection_id = await connection_manager.connect(websocket, user_id, room)
        
        # Send scan connection confirmation
        await connection_manager.send_personal_message({
            "type": "scan_connection_established",
            "data": {
                "scan_id": scan_id,
                "connection_id": connection_id,
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            }
        }, connection_id)
        
        while True:
            try:
                data = await websocket.receive_text()
                message = json.loads(data)
                
                message_type = message.get("type")
                
                if message_type == "request_status":
                    await handle_scan_status_request(connection_id, scan_id)
                elif message_type == "abort_scan":
                    await handle_scan_abort_request(connection_id, scan_id, user_id)
                elif message_type == "pause_scan":
                    await handle_scan_pause_request(connection_id, scan_id, user_id)
                elif message_type == "resume_scan":
                    await handle_scan_resume_request(connection_id, scan_id, user_id)
                
            except WebSocketDisconnect:
                break
            except json.JSONDecodeError:
                await connection_manager.send_personal_message({
                    "type": "error",
                    "data": {"message": "Invalid JSON format"}
                }, connection_id)
    
    except Exception as e:
        logger.error(f"Scan WebSocket error: {e}")
    finally:
        if 'connection_id' in locals():
            await connection_manager.disconnect(connection_id)

@router.websocket("/simulation/{simulation_id}")
async def simulation_websocket(
    websocket: WebSocket,
    simulation_id: str,
    token: Optional[str] = Query(None)
):
    """
    Simulation-specific WebSocket for detailed progress updates
    """
    try:
        user_id = await authenticate_websocket(websocket, token)
        room = f"simulation_{simulation_id}"
        connection_id = await connection_manager.connect(websocket, user_id, room)
        
        await connection_manager.send_personal_message({
            "type": "simulation_connection_established",
            "data": {
                "simulation_id": simulation_id,
                "connection_id": connection_id,
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            }
        }, connection_id)
        
        while True:
            try:
                data = await websocket.receive_text()
                message = json.loads(data)
                
                message_type = message.get("type")
                
                if message_type == "request_status":
                    await handle_simulation_status_request(connection_id, simulation_id)
                elif message_type == "abort_simulation":
                    await handle_simulation_abort_request(connection_id, simulation_id, user_id)
                
            except WebSocketDisconnect:
                break
            except json.JSONDecodeError:
                await connection_manager.send_personal_message({
                    "type": "error",
                    "data": {"message": "Invalid JSON format"}
                }, connection_id)
    
    except Exception as e:
        logger.error(f"Simulation WebSocket error: {e}")
    finally:
        if 'connection_id' in locals():
            await connection_manager.disconnect(connection_id)

@router.websocket("/notifications")
async def notifications_websocket(
    websocket: WebSocket,
    token: Optional[str] = Query(None)
):
    """
    Dedicated WebSocket for system notifications and alerts
    """
    try:
        user_id = await authenticate_websocket(websocket, token)
        connection_id = await connection_manager.connect(websocket, user_id, "notifications")
        
        await connection_manager.send_personal_message({
            "type": "notifications_connected",
            "data": {
                "user_id": user_id,
                "timestamp": datetime.now().isoformat(),
                "notification_types": ["info", "warning", "error", "success"]
            }
        }, connection_id)
        
        while True:
            try:
                data = await websocket.receive_text()
                message = json.loads(data)
                
                # Handle notification preferences, etc.
                
            except WebSocketDisconnect:
                break
            except json.JSONDecodeError:
                pass
    
    except Exception as e:
        logger.error(f"Notifications WebSocket error: {e}")
    finally:
        if 'connection_id' in locals():
            await connection_manager.disconnect(connection_id)

# Helper functions for handling WebSocket requests
async def handle_dashboard_request(connection_id: str, request_type: str, data: Dict[str, Any]):
    """Handle dashboard data requests"""
    try:
        if request_type == "system_metrics":
            # Send current system metrics
            metrics = {
                "cpu_usage": "15%",
                "memory_usage": "45%",
                "active_scans": 2,
                "active_simulations": 1,
                "timestamp": datetime.now().isoformat()
            }
            await connection_manager.send_personal_message({
                "type": "system_metrics",
                "data": metrics
            }, connection_id)
        
        elif request_type == "recent_activity":
            # Send recent activity
            activity = {
                "recent_scans": [],
                "recent_simulations": [],
                "recent_findings": [],
                "timestamp": datetime.now().isoformat()
            }
            await connection_manager.send_personal_message({
                "type": "recent_activity",
                "data": activity
            }, connection_id)
        
    except Exception as e:
        logger.error(f"Error handling dashboard request: {e}")
        await connection_manager.send_personal_message({
            "type": "error",
            "data": {"message": f"Failed to handle request: {str(e)}"}
        }, connection_id)

async def handle_scan_status_request(connection_id: str, scan_id: str):
    """Handle scan status request"""
    try:
        # Get actual scan status (simplified)
        status = {
            "scan_id": scan_id,
            "status": "running",
            "progress": 65.5,
            "current_plugin": "slither",
            "findings_count": 3,
            "timestamp": datetime.now().isoformat()
        }
        
        await connection_manager.send_personal_message({
            "type": "scan_status_response",
            "data": status
        }, connection_id)
        
    except Exception as e:
        logger.error(f"Error handling scan status request: {e}")

async def handle_scan_abort_request(connection_id: str, scan_id: str, user_id: str):
    """Handle scan abort request"""
    try:
        # Implement scan abortion logic
        await connection_manager.send_personal_message({
            "type": "scan_abort_response",
            "data": {
                "scan_id": scan_id,
                "status": "aborting",
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            }
        }, connection_id)
        
    except Exception as e:
        logger.error(f"Error handling scan abort request: {e}")

async def handle_scan_pause_request(connection_id: str, scan_id: str, user_id: str):
    """Handle scan pause request"""
    try:
        await connection_manager.send_personal_message({
            "type": "scan_pause_response",
            "data": {
                "scan_id": scan_id,
                "status": "paused",
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            }
        }, connection_id)
        
    except Exception as e:
        logger.error(f"Error handling scan pause request: {e}")

async def handle_scan_resume_request(connection_id: str, scan_id: str, user_id: str):
    """Handle scan resume request"""
    try:
        await connection_manager.send_personal_message({
            "type": "scan_resume_response",
            "data": {
                "scan_id": scan_id,
                "status": "running",
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            }
        }, connection_id)
        
    except Exception as e:
        logger.error(f"Error handling scan resume request: {e}")

async def handle_simulation_status_request(connection_id: str, simulation_id: str):
    """Handle simulation status request"""
    try:
        status = {
            "simulation_id": simulation_id,
            "status": "running",
            "progress": 40.0,
            "current_phase": "exploit_development",
            "timestamp": datetime.now().isoformat()
        }
        
        await connection_manager.send_personal_message({
            "type": "simulation_status_response",
            "data": status
        }, connection_id)
        
    except Exception as e:
        logger.error(f"Error handling simulation status request: {e}")

async def handle_simulation_abort_request(connection_id: str, simulation_id: str, user_id: str):
    """Handle simulation abort request"""
    try:
        await connection_manager.send_personal_message({
            "type": "simulation_abort_response",
            "data": {
                "simulation_id": simulation_id,
                "status": "aborting",
                "user_id": user_id,
                "timestamp": datetime.now().isoformat()
            }
        }, connection_id)
        
    except Exception as e:
        logger.error(f"Error handling simulation abort request: {e}")

async def handle_scan_status_request(connection_id: str, scan_id: str):
    """Handle scan status requests"""
    # Mock scan status - integrate with actual scan engine
    await connection_manager.send_personal_message({
        "type": "scan_status",
        "data": {
            "scan_id": scan_id,
            "status": "running",
            "progress": 65.5,
            "current_plugin": "slither",
            "vulnerabilities_found": 3,
            "estimated_time_remaining": 120,
            "timestamp": datetime.utcnow().isoformat()
        }
    }, connection_id)

async def handle_scan_abort_request(connection_id: str, scan_id: str, user_id: str):
    """Handle scan abort requests"""
    # Implementation for aborting scans
    await connection_manager.send_personal_message({
        "type": "scan_aborted",
        "data": {
            "scan_id": scan_id,
            "user_id": user_id,
            "message": f"Scan {scan_id} abort requested",
            "timestamp": datetime.utcnow().isoformat()
        }
    }, connection_id)

async def handle_simulation_status_request(connection_id: str, simulation_id: str):
    """Handle simulation status requests"""
    # Mock simulation status - integrate with actual simulation engine
    await connection_manager.send_personal_message({
        "type": "simulation_status",
        "data": {
            "simulation_id": simulation_id,
            "status": "running",
            "progress": 40.0,
            "exploit_type": "reentrancy",
            "gas_used": 245000,
            "success_probability": 78.5,
            "timestamp": datetime.utcnow().isoformat()
        }
    }, connection_id)

async def handle_simulation_abort_request(connection_id: str, simulation_id: str, user_id: str):
    """Handle simulation abort requests"""
    # Implementation for aborting simulations
    await connection_manager.send_personal_message({
        "type": "simulation_aborted",
        "data": {
            "simulation_id": simulation_id,
            "user_id": user_id,
            "message": f"Simulation {simulation_id} abort requested",
            "timestamp": datetime.utcnow().isoformat()
        }
    }, connection_id)

async def handle_mark_notification_read(connection_id: str, data: Dict[str, Any]):
    """Handle marking notifications as read"""
    notification_id = data.get("notification_id")
    await connection_manager.send_personal_message({
        "type": "notification_marked_read",
        "data": {
            "notification_id": notification_id,
            "timestamp": datetime.utcnow().isoformat()
        }
    }, connection_id)

# Utility functions for broadcasting updates

async def broadcast_scan_progress(scan_id: str, progress_data: Dict[str, Any]):
    """Broadcast scan progress to all subscribers"""
    room = f"scan_{scan_id}"
    message = {
        "type": "scan_progress",
        "data": {
            "scan_id": scan_id,
            **progress_data,
            "timestamp": datetime.utcnow().isoformat()
        }
    }
    await connection_manager.broadcast_to_room(message, room)

async def broadcast_simulation_progress(simulation_id: str, progress_data: Dict[str, Any]):
    """Broadcast simulation progress to all subscribers"""
    room = f"simulation_{simulation_id}"
    message = {
        "type": "simulation_progress",
        "data": {
            "simulation_id": simulation_id,
            **progress_data,
            "timestamp": datetime.utcnow().isoformat()
        }
    }
    await connection_manager.broadcast_to_room(message, room)

async def broadcast_system_health(health_data: Dict[str, Any]):
    """Broadcast system health to dashboard subscribers"""
    message = {
        "type": "system_health_update",
        "data": {
            **health_data,
            "timestamp": datetime.utcnow().isoformat()
        }
    }
    await connection_manager.broadcast_to_room(message, "dashboard")

async def send_user_notification(user_id: str, notification_data: Dict[str, Any]):
    """Send notification to specific user"""
    message = {
        "type": "user_notification",
        "data": {
            **notification_data,
            "timestamp": datetime.utcnow().isoformat()
        }
    }
    await connection_manager.send_user_message(message, user_id)
