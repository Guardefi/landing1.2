# Scorpius Vulnerability Scanner API Documentation

## Version 2.0 - Enhanced for Frontend Integration

This document provides comprehensive documentation for the Scorpius Vulnerability Scanner API, designed for seamless integration with modern React/Vite frontends.

## Base URL
```
http://localhost:8080
```

## Authentication

### JWT Authentication
All API endpoints (except `/health` and `/auth/login`) require authentication via JWT token in the Authorization header:

```http
Authorization: Bearer <jwt_token>
```

### Login Endpoint
```http
POST /api/v1/auth/login
Content-Type: application/json

{
  "username": "demo",
  "password": "password"
}
```

**Response:**
```json
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
  "token_type": "bearer",
  "expires_in": 86400,
  "user_id": "demo"
}
```

## REST API Endpoints

### System Endpoints

#### Health Check
```http
GET /health
```
Returns system health status and service information.

#### System Metrics
```http
GET /api/v1/metrics
Authorization: Bearer <token>
```
Returns comprehensive system metrics including scans, simulations, plugins, and WebSocket connections.

#### Dashboard Summary
```http
GET /api/v1/dashboard/summary
Authorization: Bearer <token>
```
Returns dashboard overview data for the main UI.

### Scan Management

#### Start Scan
```http
POST /api/v1/scan
Authorization: Bearer <token>
Content-Type: application/json

{
  "target_type": "file|source_code|contract_address",
  "target_identifier": "path/to/file or source code or address",
  "scan_type": "static|dynamic|full|quick",
  "plugins": ["slither", "mythril"],  // optional
  "config": {},  // optional
  "priority": "low|normal|high"  // optional
}
```

#### List Scans
```http
GET /api/v1/scans?status_filter=running&limit=50&offset=0
Authorization: Bearer <token>
```

#### Get Scan Status
```http
GET /api/v1/scan/{scan_id}/status
Authorization: Bearer <token>
```

#### Get Scan Results
```http
GET /api/v1/scan/{scan_id}/results?include_raw=false
Authorization: Bearer <token>
```

#### Abort Scan
```http
POST /api/v1/scan/{scan_id}/abort
Authorization: Bearer <token>
```

### Simulation Management

#### Start Simulation
```http
POST /api/v1/simulation
Authorization: Bearer <token>
Content-Type: application/json

{
  "vulnerability_id": "vuln_001",
  "simulation_type": "poc|full_exploit|impact_assessment|attack_chain|mitigation_test",
  "target_identifier": "source code or contract address",
  "config": {},  // optional
  "environment": "sandbox|testnet"  // optional
}
```

#### List Simulations
```http
GET /api/v1/simulations?status_filter=running&limit=50&offset=0
Authorization: Bearer <token>
```

#### Get Simulation Status
```http
GET /api/v1/simulation/{simulation_id}/status
Authorization: Bearer <token>
```

#### Get Simulation Results
```http
GET /api/v1/simulation/{simulation_id}/results
Authorization: Bearer <token>
```

### Plugin Management

#### List Plugins
```http
GET /api/v1/plugins
Authorization: Bearer <token>
```

#### Initialize Plugin
```http
POST /api/v1/plugins/{plugin_name}/initialize?force_docker=false
Authorization: Bearer <token>
```

#### Get Plugin Status
```http
GET /api/v1/plugins/{plugin_name}/status
Authorization: Bearer <token>
```

#### Test Plugin
```http
POST /api/v1/plugins/{plugin_name}/test
Authorization: Bearer <token>
```

### Report Generation

#### Generate Report
```http
POST /api/v1/reports
Authorization: Bearer <token>
Content-Type: application/json

{
  "scan_id": "scan_123",
  "format": "html|pdf|json|markdown",
  "include_details": true,
  "include_remediation": true
}
```

### Vulnerability Database

#### List Vulnerabilities
```http
GET /api/v1/vulnerabilities?severity=high&category=reentrancy&limit=50&offset=0
Authorization: Bearer <token>
```

### Notifications

#### Send Notification
```http
POST /api/v1/notifications
Authorization: Bearer <token>
Content-Type: application/json

{
  "level": "info|warning|error|success",
  "message": "Notification message",
  "details": {},  // optional
  "target_users": ["user1", "user2"]  // optional, broadcasts to all if empty
}
```

## WebSocket Protocol

### Connection URLs
- Dashboard: `ws://localhost:8080/ws/dashboard?token=<jwt_token>`
- Scan Progress: `ws://localhost:8080/ws/scan/{scan_id}?token=<jwt_token>`
- Simulation Progress: `ws://localhost:8080/ws/simulation/{simulation_id}?token=<jwt_token>`
- Notifications: `ws://localhost:8080/ws/notifications?token=<jwt_token>`

### Message Protocol

#### Client to Server Messages

**Subscribe to Topic:**
```json
{
  "type": "subscribe",
  "data": {
    "topic": "scans|simulations|metrics|notifications|plugins|system"
  }
}
```

**Unsubscribe from Topic:**
```json
{
  "type": "unsubscribe",
  "data": {
    "topic": "scans"
  }
}
```

**Request Data:**
```json
{
  "type": "request",
  "data": {
    "request_type": "system_metrics|recent_activity",
    "parameters": {}
  }
}
```

**Heartbeat:**
```json
{
  "type": "heartbeat"
}
```

**Scan Control:**
```json
{
  "type": "request_status|abort_scan|pause_scan|resume_scan",
  "data": {
    "scan_id": "scan_123"
  }
}
```

#### Server to Client Messages

**Connection Established:**
```json
{
  "type": "connection_established",
  "data": {
    "connection_id": "conn_123",
    "user_id": "demo_user",
    "available_topics": ["scans", "simulations", "metrics"],
    "server_time": "2024-01-01T12:00:00Z",
    "protocol_version": "2.0"
  },
  "timestamp": "2024-01-01T12:00:00Z",
  "message_id": "msg_uuid"
}
```

**Scan Events:**
```json
{
  "type": "scan_started|scan_progress|scan_completed|scan_failed|scan_finding",
  "data": {
    "scan_id": "scan_123",
    "progress": 65.5,
    "current_plugin": "slither",
    "findings_count": 3,
    "status": "running",
    "finding": { /* finding object for scan_finding type */ }
  },
  "timestamp": "2024-01-01T12:00:00Z",
  "message_id": "msg_uuid"
}
```

**Simulation Events:**
```json
{
  "type": "simulation_started|simulation_progress|simulation_completed|simulation_failed",
  "data": {
    "simulation_id": "sim_456",
    "vulnerability_id": "vuln_001",
    "progress": 40.0,
    "current_phase": "exploit_development",
    "status": "running"
  },
  "timestamp": "2024-01-01T12:00:00Z",
  "message_id": "msg_uuid"
}
```

**System Events:**
```json
{
  "type": "system_metrics|system_health",
  "data": {
    "cpu_usage": "15%",
    "memory_usage": "45%",
    "active_scans": 2,
    "active_simulations": 1,
    "websocket_connections": 5
  },
  "timestamp": "2024-01-01T12:00:00Z",
  "message_id": "msg_uuid"
}
```

**Plugin Events:**
```json
{
  "type": "plugin_initialized|plugin_failed|plugin_status",
  "data": {
    "plugin_name": "slither",
    "status": "initialized",
    "docker_mode": false
  },
  "timestamp": "2024-01-01T12:00:00Z",
  "message_id": "msg_uuid"
}
```

**Notifications:**
```json
{
  "type": "notification",
  "data": {
    "level": "info|warning|error|success",
    "message": "Notification message",
    "details": {},
    "sender": "system|user_id"
  },
  "timestamp": "2024-01-01T12:00:00Z",
  "message_id": "msg_uuid"
}
```

**Error Messages:**
```json
{
  "type": "error",
  "data": {
    "message": "Error description",
    "code": "ERROR_CODE",
    "details": {}
  },
  "timestamp": "2024-01-01T12:00:00Z",
  "message_id": "msg_uuid"
}
```

## Frontend Integration Guide

### React/TypeScript Example

#### Authentication Hook
```typescript
import { useState, useEffect } from 'react';

interface AuthState {
  token: string | null;
  user: any | null;
  isAuthenticated: boolean;
}

export const useAuth = () => {
  const [auth, setAuth] = useState<AuthState>({
    token: localStorage.getItem('scorpius_token'),
    user: null,
    isAuthenticated: false
  });

  const login = async (username: string, password: string) => {
    const response = await fetch('/api/v1/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    });
    
    const data = await response.json();
    
    if (response.ok) {
      localStorage.setItem('scorpius_token', data.access_token);
      setAuth({
        token: data.access_token,
        user: { id: data.user_id },
        isAuthenticated: true
      });
    }
    
    return response.ok;
  };

  return { auth, login };
};
```

#### WebSocket Hook
```typescript
import { useEffect, useRef, useState } from 'react';

interface WebSocketMessage {
  type: string;
  data: any;
  timestamp: string;
  message_id: string;
}

export const useWebSocket = (endpoint: string, token: string) => {
  const ws = useRef<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [messages, setMessages] = useState<WebSocketMessage[]>([]);

  useEffect(() => {
    if (!token) return;

    const wsUrl = `ws://localhost:8080/ws/${endpoint}?token=${token}`;
    ws.current = new WebSocket(wsUrl);

    ws.current.onopen = () => {
      setIsConnected(true);
    };

    ws.current.onmessage = (event) => {
      const message: WebSocketMessage = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };

    ws.current.onclose = () => {
      setIsConnected(false);
    };

    return () => {
      ws.current?.close();
    };
  }, [endpoint, token]);

  const sendMessage = (type: string, data: any = {}) => {
    if (ws.current?.readyState === WebSocket.OPEN) {
      ws.current.send(JSON.stringify({ type, data }));
    }
  };

  const subscribe = (topic: string) => {
    sendMessage('subscribe', { topic });
  };

  return { isConnected, messages, sendMessage, subscribe };
};
```

#### API Client
```typescript
class ScorpiusAPI {
  private baseUrl: string;
  private token: string;

  constructor(baseUrl: string = 'http://localhost:8080', token: string = '') {
    this.baseUrl = baseUrl;
    this.token = token;
  }

  private async request(endpoint: string, options: RequestInit = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${this.token}`,
      ...options.headers
    };

    const response = await fetch(url, { ...options, headers });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.status} ${response.statusText}`);
    }

    return response.json();
  }

  async startScan(scanRequest: {
    target_type: string;
    target_identifier: string;
    scan_type?: string;
    plugins?: string[];
    priority?: string;
  }) {
    return this.request('/api/v1/scan', {
      method: 'POST',
      body: JSON.stringify(scanRequest)
    });
  }

  async getScans(filters: {
    status_filter?: string;
    limit?: number;
    offset?: number;
  } = {}) {
    const params = new URLSearchParams(filters as any);
    return this.request(`/api/v1/scans?${params}`);
  }

  async getScanResults(scanId: string, includeRaw = false) {
    return this.request(`/api/v1/scan/${scanId}/results?include_raw=${includeRaw}`);
  }

  async getMetrics() {
    return this.request('/api/v1/metrics');
  }
}
```

### Error Handling

#### HTTP Error Responses
```json
{
  "error": "Error Type",
  "message": "Human readable error message",
  "details": {},
  "timestamp": "2024-01-01T12:00:00Z"
}
```

#### WebSocket Error Messages
```json
{
  "type": "error",
  "data": {
    "message": "Error description",
    "code": "WEBSOCKET_ERROR",
    "recoverable": true
  }
}
```

### Rate Limiting

- API endpoints: 100 requests per minute per user
- WebSocket connections: 5 concurrent connections per user
- File uploads: 10MB maximum size

### CORS Configuration

The API is configured to accept requests from:
- `http://localhost:3000` (React dev server)
- `http://localhost:5173` (Vite dev server)
- `http://localhost:4173` (Vite preview)
- `https://*.netlify.app` (Netlify deployments)
- `https://*.vercel.app` (Vercel deployments)

### Security Considerations

1. **JWT Token Storage**: Store tokens securely (httpOnly cookies recommended for production)
2. **Token Refresh**: Implement automatic token refresh before expiration
3. **HTTPS**: Use HTTPS in production environments
4. **Input Validation**: Validate all user inputs on the frontend
5. **Error Handling**: Don't expose sensitive error details to users

### Performance Optimization

1. **WebSocket Connection Management**: Implement connection pooling and automatic reconnection
2. **Message Throttling**: Limit message processing rate for high-frequency updates
3. **Data Pagination**: Use pagination for large datasets
4. **Caching**: Implement appropriate caching strategies for frequently accessed data

### Deployment Considerations

1. **Environment Variables**: Configure API base URL via environment variables
2. **Load Balancing**: Use sticky sessions for WebSocket connections
3. **Monitoring**: Implement proper logging and monitoring
4. **Backup**: Regular database backups for scan results and configurations
