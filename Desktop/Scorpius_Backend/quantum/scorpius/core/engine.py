"""
Scorpius Enterprise Core Engine
"""

import asyncio
import logging
from typing import Dict, Any, Optional, List
from dataclasses import dataclass
from datetime import datetime

from .config import ScorpiusConfig
from .monitoring import EnterpriseMonitoring
from .health import HealthChecker
from ..bridge import (
    EnterpriseQuantumEngine,
    EnterpriseSecurityEngine,
    EnterpriseAnalyticsEngine,
    EnterpriseIntegrationHub
)

@dataclass
class ModuleStatus:
    """Status of a platform module."""
    name: str
    version: str
    status: str
    health_score: float
    last_check: datetime
    error_count: int
    uptime: float

class ScorpiusEngine:
    """
    Main Scorpius Enterprise Engine.
    
    Orchestrates all platform modules and provides unified interface.
    """
    
    def __init__(self, config: ScorpiusConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Core modules - now using enterprise bridge modules
        self.quantum_engine: Optional[EnterpriseQuantumEngine] = None
        self.security_engine: Optional[EnterpriseSecurityEngine] = None
        self.analytics_engine: Optional[EnterpriseAnalyticsEngine] = None
        self.integration_hub: Optional[EnterpriseIntegrationHub] = None
        
        # Management components
        self.health_checker = HealthChecker()
        self.module_registry: Dict[str, Any] = {}
        self.startup_time = datetime.now()
        
        # State tracking
        self.is_initialized = False
        self.is_shutting_down = False
        
    async def initialize(self) -> None:
        """Initialize all platform modules."""
        try:
            self.logger.info("Initializing Scorpius Enterprise Engine...")
            
            # Initialize modules in dependency order
            await self._initialize_quantum_engine()
            await self._initialize_security_engine()
            await self._initialize_analytics_engine()
            await self._initialize_integration_hub()
            
            # Start background tasks
            asyncio.create_task(self._health_monitor_task())
            asyncio.create_task(self._metrics_collection_task())
            asyncio.create_task(self._maintenance_task())
            
            self.is_initialized = True
            self.logger.info("Scorpius Engine initialization complete")
            
        except Exception as e:
            self.logger.error(f"Engine initialization failed: {e}")
            raise Exception(f"Failed to initialize engine: {e}") from e
    
    async def _initialize_quantum_engine(self) -> None:
        """Initialize quantum cryptography engine."""
        self.logger.info("Initializing Quantum Cryptography Engine...")
        
        # Use the enterprise bridge to connect to your existing quantum engine
        self.quantum_engine = EnterpriseQuantumEngine(
            self.config.quantum_config
        )
        await self.quantum_engine.initialize()
        
        self.module_registry["quantum"] = {
            "instance": self.quantum_engine,
            "status": "active",
            "startup_time": datetime.now()
        }
    
    async def _initialize_security_engine(self) -> None:
        """Initialize elite security engine."""
        self.logger.info("Initializing Elite Security Engine...")
        
        # Use the enterprise bridge to connect to your existing security engine
        self.security_engine = EnterpriseSecurityEngine(
            self.config.security_config
        )
        await self.security_engine.initialize()
        
        self.module_registry["security"] = {
            "instance": self.security_engine,
            "status": "active", 
            "startup_time": datetime.now()
        }
    
    async def _initialize_analytics_engine(self) -> None:
        """Initialize analytics engine."""
        self.logger.info("Initializing Analytics Engine...")
        
        # Use the enterprise bridge to connect to your existing analytics engine
        self.analytics_engine = EnterpriseAnalyticsEngine(
            self.config.analytics_config
        )
        await self.analytics_engine.initialize()
        
        self.module_registry["analytics"] = {
            "instance": self.analytics_engine,
            "status": "active",
            "startup_time": datetime.now()
        }
    
    async def _initialize_integration_hub(self) -> None:
        """Initialize integration hub."""
        self.logger.info("Initializing Integration Hub...")
        
        # Use the enterprise bridge to connect to your existing integration hub
        self.integration_hub = EnterpriseIntegrationHub(
            self.config.integration_config,
            {
                "quantum": self.quantum_engine,
                "security": self.security_engine,
                "analytics": self.analytics_engine
            }
        )
        await self.integration_hub.initialize()
        
        self.module_registry["integration"] = {
            "instance": self.integration_hub,
            "status": "active",
            "startup_time": datetime.now()
        }
    
    # High-level API methods
    async def quantum_encrypt(
        self, 
        message: bytes, 
        algorithm: str = "lattice_based",
        security_level: int = 3
    ) -> Dict[str, Any]:
        """Encrypt message using quantum-resistant cryptography."""
        if not self.quantum_engine:
            raise Exception("Quantum engine not initialized")
        
        return await self.quantum_engine.encrypt_message(
            message, algorithm, security_level
        )
    
    async def security_scan(
        self, 
        target: str, 
        scan_type: str = "comprehensive"
    ) -> Dict[str, Any]:
        """Perform comprehensive security scan."""
        if not self.security_engine:
            raise Exception("Security engine not initialized")
        
        return await self.security_engine.scan_target(target, scan_type)
    
    async def generate_analytics_report(
        self,
        report_type: str,
        timeframe: str = "24h"
    ) -> Dict[str, Any]:
        """Generate analytics report."""
        if not self.analytics_engine:
            raise Exception("Analytics engine not initialized")
        
        return await self.analytics_engine.generate_report(report_type, timeframe)
    
    async def get_platform_status(self) -> Dict[str, Any]:
        """Get comprehensive platform status."""
        uptime = (datetime.now() - self.startup_time).total_seconds()
        
        module_statuses = []
        for name, module_info in self.module_registry.items():
            health_score = await self.health_checker.check_module_health(
                module_info["instance"]
            )
            
            module_statuses.append(ModuleStatus(
                name=name,
                version=getattr(module_info["instance"], "version", "2.0.0"),
                status=module_info["status"],
                health_score=health_score,
                last_check=datetime.now(),
                error_count=0,
                uptime=(datetime.now() - module_info["startup_time"]).total_seconds()
            ))
        
        return {
            "platform_version": "2.0.0",
            "uptime_seconds": uptime,
            "total_modules": len(self.module_registry),
            "active_modules": len([m for m in module_statuses if m.status == "active"]),
            "overall_health": sum(m.health_score for m in module_statuses) / len(module_statuses) if module_statuses else 1.0,
            "modules": [m.__dict__ for m in module_statuses],
            "is_enterprise": True,
            "license_valid": True  # Would check with license manager
        }
    
    # Background tasks
    async def _health_monitor_task(self):
        """Background health monitoring task."""
        while not self.is_shutting_down:
            try:
                for name, module_info in self.module_registry.items():
                    health_score = await self.health_checker.check_module_health(
                        module_info["instance"]
                    )
                    
                    if health_score < 0.5:  # Health threshold
                        self.logger.warning(
                            f"Module {name} health degraded: {health_score:.2f}"
                        )
                        # Could trigger alerts or auto-recovery
                
                await asyncio.sleep(30)  # Check every 30 seconds
                
            except Exception as e:
                self.logger.error(f"Health monitor error: {e}")
                await asyncio.sleep(60)
    
    async def _metrics_collection_task(self):
        """Background metrics collection task."""
        while not self.is_shutting_down:
            try:
                # Collect performance metrics from all modules
                for name, module_info in self.module_registry.items():
                    instance = module_info["instance"]
                    # Store metrics in analytics engine
                    metrics = {
                        "timestamp": datetime.now().isoformat(),
                        "module": name,
                        "status": "active"
                    }
                    self.logger.debug(f"Collected metrics for module {name}: {metrics}")
                
                await asyncio.sleep(60)  # Collect every minute
                
            except Exception as e:
                self.logger.error(f"Metrics collection error: {e}")
                await asyncio.sleep(60)
    
    async def _maintenance_task(self):
        """Background maintenance task."""
        while not self.is_shutting_down:
            try:
                # Perform routine maintenance
                await self._cleanup_expired_data()
                await self._rotate_logs()
                await self._update_threat_intelligence()
                
                await asyncio.sleep(3600)  # Run every hour
                
            except Exception as e:
                self.logger.error(f"Maintenance task error: {e}")
                await asyncio.sleep(3600)
    
    async def _cleanup_expired_data(self):
        """Clean up expired data across modules."""
        for name, module_info in self.module_registry.items():
            self.logger.debug(f"Cleaning up expired data for module {name}")
    
    async def _rotate_logs(self):
        """Rotate log files."""
        # Implementation would depend on logging configuration
        pass
    
    async def _update_threat_intelligence(self):
        """Update threat intelligence feeds."""
        self.logger.debug("Updating threat intelligence feeds")
    
    async def shutdown(self):
        """Gracefully shutdown the engine."""
        self.is_shutting_down = True
        self.logger.info("Shutting down Scorpius Engine...")
        
        # Shutdown modules in reverse order
        for name in reversed(list(self.module_registry.keys())):
            module_info = self.module_registry[name]
            
            try:
                self.logger.info(f"Module {name} shut down successfully")
            except Exception as e:
                self.logger.error(f"Error shutting down module {name}: {e}")
        
        self.logger.info("Scorpius Engine shutdown complete")
